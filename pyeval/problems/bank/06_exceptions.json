[
  {
    "id": "exc_001",
    "category": "exceptions",
    "difficulty": "easy",
    "title": "Safe Divide",
    "prompt": "def safe_divide(a, b):\n    \"\"\"Divide a by b safely.\n\n    Args:\n        a: The numerator.\n        b: The denominator.\n\n    Returns:\n        The result of a / b, or None if b is zero.\n\n    Raises:\n        TypeError: If either a or b is not a number (int or float).\n    \"\"\"\n",
    "reference_solution": "def safe_divide(a, b):\n    \"\"\"Divide a by b safely.\"\"\"\n    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):\n        raise TypeError(\"Both arguments must be numeric (int or float)\")\n    try:\n        return a / b\n    except ZeroDivisionError:\n        return None\n",
    "test_code": "import unittest\n\n\nclass TestSafeDivide(unittest.TestCase):\n    def test_normal_division(self):\n        self.assertEqual(safe_divide(10, 2), 5.0)\n\n    def test_float_division(self):\n        self.assertAlmostEqual(safe_divide(7.5, 2.5), 3.0)\n\n    def test_negative_numbers(self):\n        self.assertEqual(safe_divide(-10, 2), -5.0)\n\n    def test_divide_by_zero_returns_none(self):\n        self.assertIsNone(safe_divide(5, 0))\n\n    def test_zero_divided_by_zero(self):\n        self.assertIsNone(safe_divide(0, 0))\n\n    def test_divide_zero_by_nonzero(self):\n        self.assertEqual(safe_divide(0, 5), 0.0)\n\n    def test_int_and_float_mix(self):\n        self.assertAlmostEqual(safe_divide(7, 2.0), 3.5)\n\n    def test_type_error_string_numerator(self):\n        with self.assertRaises(TypeError):\n            safe_divide('10', 2)\n\n    def test_type_error_string_denominator(self):\n        with self.assertRaises(TypeError):\n            safe_divide(10, '2')\n\n    def test_type_error_both_strings(self):\n        with self.assertRaises(TypeError):\n            safe_divide('a', 'b')\n\n    def test_type_error_none(self):\n        with self.assertRaises(TypeError):\n            safe_divide(None, 5)\n\n    def test_type_error_list(self):\n        with self.assertRaises(TypeError):\n            safe_divide([1], 2)\n\n    def test_large_numbers(self):\n        result = safe_divide(1e15, 1e10)\n        self.assertAlmostEqual(result, 1e5)\n",
    "tags": ["exceptions", "error-handling", "type-checking"],
    "time_limit_seconds": 5
  },
  {
    "id": "exc_002",
    "category": "exceptions",
    "difficulty": "medium",
    "title": "Retry Decorator",
    "prompt": "import time\nimport functools\n\n\ndef retry(max_attempts=3, exceptions=(Exception,), delay=0):\n    \"\"\"A decorator that retries a function on failure.\n\n    Args:\n        max_attempts (int): Maximum number of attempts (including the first call).\n            Must be >= 1.\n        exceptions (tuple): A tuple of exception types to catch and retry on.\n            Any other exception types should propagate immediately.\n        delay (float): Seconds to wait between retries. Defaults to 0.\n\n    Returns:\n        A decorator that wraps the target function with retry logic.\n\n    Behavior:\n        - Call the decorated function. If it succeeds, return its result.\n        - If it raises one of the specified exception types and attempts remain,\n          wait `delay` seconds, then retry.\n        - If all attempts are exhausted, raise the last exception.\n        - The decorator should preserve the original function's name and docstring\n          (use functools.wraps).\n    \"\"\"\n",
    "reference_solution": "import time\nimport functools\n\n\ndef retry(max_attempts=3, exceptions=(Exception,), delay=0):\n    \"\"\"A decorator that retries a function on failure.\"\"\"\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            last_exception = None\n            for attempt in range(max_attempts):\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    last_exception = e\n                    if attempt < max_attempts - 1 and delay > 0:\n                        time.sleep(delay)\n            raise last_exception\n        return wrapper\n    return decorator\n",
    "test_code": "import unittest\nimport time\nimport functools\n\n\nclass TestRetryDecorator(unittest.TestCase):\n    def test_succeeds_first_try(self):\n        call_count = 0\n\n        @retry(max_attempts=3)\n        def always_works():\n            nonlocal call_count\n            call_count += 1\n            return 'ok'\n\n        self.assertEqual(always_works(), 'ok')\n        self.assertEqual(call_count, 1)\n\n    def test_succeeds_after_retries(self):\n        call_count = 0\n\n        @retry(max_attempts=3, exceptions=(ValueError,))\n        def fails_twice():\n            nonlocal call_count\n            call_count += 1\n            if call_count < 3:\n                raise ValueError('not yet')\n            return 'done'\n\n        self.assertEqual(fails_twice(), 'done')\n        self.assertEqual(call_count, 3)\n\n    def test_exhausts_all_attempts(self):\n        call_count = 0\n\n        @retry(max_attempts=2, exceptions=(RuntimeError,))\n        def always_fails():\n            nonlocal call_count\n            call_count += 1\n            raise RuntimeError('fail')\n\n        with self.assertRaises(RuntimeError):\n            always_fails()\n        self.assertEqual(call_count, 2)\n\n    def test_only_catches_specified_exceptions(self):\n        call_count = 0\n\n        @retry(max_attempts=3, exceptions=(ValueError,))\n        def raises_type_error():\n            nonlocal call_count\n            call_count += 1\n            raise TypeError('wrong type')\n\n        with self.assertRaises(TypeError):\n            raises_type_error()\n        self.assertEqual(call_count, 1)\n\n    def test_preserves_function_name(self):\n        @retry(max_attempts=2)\n        def my_function():\n            \"\"\"My docstring.\"\"\"\n            pass\n\n        self.assertEqual(my_function.__name__, 'my_function')\n        self.assertEqual(my_function.__doc__, 'My docstring.')\n\n    def test_passes_args_and_kwargs(self):\n        @retry(max_attempts=2, exceptions=(Exception,))\n        def add(a, b, extra=0):\n            return a + b + extra\n\n        self.assertEqual(add(1, 2, extra=3), 6)\n\n    def test_delay_is_applied(self):\n        call_count = 0\n\n        @retry(max_attempts=2, exceptions=(ValueError,), delay=0.1)\n        def fails_once():\n            nonlocal call_count\n            call_count += 1\n            if call_count < 2:\n                raise ValueError('retry')\n            return 'ok'\n\n        start = time.time()\n        result = fails_once()\n        elapsed = time.time() - start\n        self.assertEqual(result, 'ok')\n        self.assertGreaterEqual(elapsed, 0.08)\n\n    def test_single_attempt(self):\n        call_count = 0\n\n        @retry(max_attempts=1, exceptions=(ValueError,))\n        def fragile():\n            nonlocal call_count\n            call_count += 1\n            raise ValueError('fail')\n\n        with self.assertRaises(ValueError):\n            fragile()\n        self.assertEqual(call_count, 1)\n\n    def test_multiple_exception_types(self):\n        call_count = 0\n\n        @retry(max_attempts=3, exceptions=(ValueError, KeyError))\n        def mixed_errors():\n            nonlocal call_count\n            call_count += 1\n            if call_count == 1:\n                raise ValueError('val')\n            if call_count == 2:\n                raise KeyError('key')\n            return 'success'\n\n        self.assertEqual(mixed_errors(), 'success')\n        self.assertEqual(call_count, 3)\n\n    def test_return_value_preserved(self):\n        @retry(max_attempts=1)\n        def returns_dict():\n            return {'key': [1, 2, 3]}\n\n        self.assertEqual(returns_dict(), {'key': [1, 2, 3]})\n",
    "tags": ["decorator", "exceptions", "retry", "functools"],
    "time_limit_seconds": 10
  },
  {
    "id": "exc_003",
    "category": "exceptions",
    "difficulty": "hard",
    "title": "Custom Exception Hierarchy and Schema Validation",
    "prompt": "import re\n\n\nclass ValidationError(Exception):\n    \"\"\"Base exception for validation errors.\n\n    Constructor:\n        __init__(self, field: str, message: str)\n            Store field and message as instance attributes.\n            Call super().__init__() with a formatted string.\n\n    Instance Attributes:\n        field (str): The name of the field that failed validation.\n        message (str): A human-readable error message.\n    \"\"\"\n\n\nclass TypeValidationError(ValidationError):\n    \"\"\"Raised when a field has the wrong type.\n\n    Constructor:\n        __init__(self, field: str, expected_type: type, actual_type: type)\n            Store expected_type and actual_type as instance attributes.\n            Call super().__init__(field, <message>).\n\n    Instance Attributes (in addition to inherited field, message):\n        expected_type (type): The expected type.\n        actual_type (type): The actual type received.\n    \"\"\"\n\n\nclass RangeValidationError(ValidationError):\n    \"\"\"Raised when a numeric field is out of range.\n\n    Constructor:\n        __init__(self, field: str, value, min_value=None, max_value=None)\n            Store value, min_value, max_value as instance attributes.\n            Call super().__init__(field, <message>).\n\n    Instance Attributes (in addition to inherited field, message):\n        value: The actual value.\n        min_value: The minimum allowed value (or None).\n        max_value: The maximum allowed value (or None).\n    \"\"\"\n\n\nclass PatternValidationError(ValidationError):\n    \"\"\"Raised when a string field does not match a regex pattern.\n\n    Constructor:\n        __init__(self, field: str, pattern: str, value: str)\n            Store pattern and value as instance attributes.\n            Call super().__init__(field, <message>).\n\n    Instance Attributes (in addition to inherited field, message):\n        pattern (str): The regex pattern that was expected.\n        value (str): The actual string value.\n    \"\"\"\n\n\ndef validate_data(schema, data):\n    \"\"\"Validate data against a schema, raising appropriate exceptions.\n\n    Args:\n        schema (dict): A dict mapping field names to rule dicts. Each rule dict\n            can have:\n            - 'type' (type): required type (e.g., int, str, float)\n            - 'min' (number): minimum value (only for numeric types)\n            - 'max' (number): maximum value (only for numeric types)\n            - 'pattern' (str): regex pattern the string must match fully\n            - 'required' (bool): if True, field must exist in data (default True)\n\n        data (dict): The data to validate.\n\n    Raises:\n        TypeValidationError: if a field has the wrong type.\n        RangeValidationError: if a numeric field is out of range.\n        PatternValidationError: if a string field doesn't match the pattern.\n        ValidationError: if a required field is missing.\n\n    Returns:\n        True if all validations pass.\n\n    Note:\n        Validate fields in the order they appear in the schema.\n        Raise on the first validation failure (do not collect all errors).\n    \"\"\"\n",
    "reference_solution": "import re\n\n\nclass ValidationError(Exception):\n    \"\"\"Base exception for validation errors.\"\"\"\n\n    def __init__(self, field, message):\n        self.field = field\n        self.message = message\n        super().__init__(f\"{field}: {message}\")\n\n\nclass TypeValidationError(ValidationError):\n    \"\"\"Raised when a field has the wrong type.\"\"\"\n\n    def __init__(self, field, expected_type, actual_type):\n        self.expected_type = expected_type\n        self.actual_type = actual_type\n        super().__init__(\n            field,\n            f\"expected {expected_type.__name__}, got {actual_type.__name__}\"\n        )\n\n\nclass RangeValidationError(ValidationError):\n    \"\"\"Raised when a numeric field is out of range.\"\"\"\n\n    def __init__(self, field, value, min_value=None, max_value=None):\n        self.value = value\n        self.min_value = min_value\n        self.max_value = max_value\n        parts = []\n        if min_value is not None:\n            parts.append(f\">= {min_value}\")\n        if max_value is not None:\n            parts.append(f\"<= {max_value}\")\n        constraint = \" and \".join(parts)\n        super().__init__(\n            field,\n            f\"value {value} is out of range ({constraint})\"\n        )\n\n\nclass PatternValidationError(ValidationError):\n    \"\"\"Raised when a string field does not match a regex pattern.\"\"\"\n\n    def __init__(self, field, pattern, value):\n        self.pattern = pattern\n        self.value = value\n        super().__init__(\n            field,\n            f\"value '{value}' does not match pattern '{pattern}'\"\n        )\n\n\ndef validate_data(schema, data):\n    \"\"\"Validate data against a schema, raising appropriate exceptions.\"\"\"\n    for field_name, rules in schema.items():\n        required = rules.get('required', True)\n\n        if field_name not in data:\n            if required:\n                raise ValidationError(field_name, \"required field is missing\")\n            continue\n\n        value = data[field_name]\n\n        # Type check\n        if 'type' in rules:\n            expected = rules['type']\n            if not isinstance(value, expected):\n                raise TypeValidationError(field_name, expected, type(value))\n\n        # Range check (for numeric types)\n        min_val = rules.get('min')\n        max_val = rules.get('max')\n        if min_val is not None and value < min_val:\n            raise RangeValidationError(field_name, value, min_value=min_val, max_value=max_val)\n        if max_val is not None and value > max_val:\n            raise RangeValidationError(field_name, value, min_value=min_val, max_value=max_val)\n\n        # Pattern check (for string types)\n        if 'pattern' in rules:\n            pattern = rules['pattern']\n            if not re.fullmatch(pattern, value):\n                raise PatternValidationError(field_name, pattern, value)\n\n    return True\n",
    "test_code": "import unittest\nimport re\n\n\nclass TestExceptionHierarchy(unittest.TestCase):\n    def test_validation_error_is_exception(self):\n        self.assertTrue(issubclass(ValidationError, Exception))\n\n    def test_type_validation_error_inherits(self):\n        self.assertTrue(issubclass(TypeValidationError, ValidationError))\n\n    def test_range_validation_error_inherits(self):\n        self.assertTrue(issubclass(RangeValidationError, ValidationError))\n\n    def test_pattern_validation_error_inherits(self):\n        self.assertTrue(issubclass(PatternValidationError, ValidationError))\n\n    def test_validation_error_attributes(self):\n        e = ValidationError('name', 'is missing')\n        self.assertEqual(e.field, 'name')\n        self.assertEqual(e.message, 'is missing')\n\n    def test_type_validation_error_attributes(self):\n        e = TypeValidationError('age', int, str)\n        self.assertEqual(e.field, 'age')\n        self.assertEqual(e.expected_type, int)\n        self.assertEqual(e.actual_type, str)\n\n    def test_range_validation_error_attributes(self):\n        e = RangeValidationError('age', -5, min_value=0, max_value=200)\n        self.assertEqual(e.field, 'age')\n        self.assertEqual(e.value, -5)\n        self.assertEqual(e.min_value, 0)\n        self.assertEqual(e.max_value, 200)\n\n    def test_pattern_validation_error_attributes(self):\n        e = PatternValidationError('email', r'.+@.+', 'bad')\n        self.assertEqual(e.field, 'email')\n        self.assertEqual(e.pattern, r'.+@.+')\n        self.assertEqual(e.value, 'bad')\n\n    def test_catch_by_base_class(self):\n        with self.assertRaises(ValidationError):\n            raise TypeValidationError('x', int, str)\n        with self.assertRaises(ValidationError):\n            raise RangeValidationError('x', -1, min_value=0)\n        with self.assertRaises(ValidationError):\n            raise PatternValidationError('x', r'\\d+', 'abc')\n\n\nclass TestValidateData(unittest.TestCase):\n    def test_valid_data(self):\n        schema = {\n            'name': {'type': str},\n            'age': {'type': int, 'min': 0, 'max': 200},\n        }\n        data = {'name': 'Alice', 'age': 30}\n        self.assertTrue(validate_data(schema, data))\n\n    def test_missing_required_field(self):\n        schema = {'name': {'type': str, 'required': True}}\n        with self.assertRaises(ValidationError) as ctx:\n            validate_data(schema, {})\n        self.assertEqual(ctx.exception.field, 'name')\n\n    def test_missing_optional_field_ok(self):\n        schema = {'nickname': {'type': str, 'required': False}}\n        self.assertTrue(validate_data(schema, {}))\n\n    def test_default_required_is_true(self):\n        schema = {'name': {'type': str}}\n        with self.assertRaises(ValidationError):\n            validate_data(schema, {})\n\n    def test_wrong_type_raises_type_error(self):\n        schema = {'age': {'type': int}}\n        with self.assertRaises(TypeValidationError) as ctx:\n            validate_data(schema, {'age': '30'})\n        self.assertEqual(ctx.exception.field, 'age')\n        self.assertEqual(ctx.exception.expected_type, int)\n        self.assertEqual(ctx.exception.actual_type, str)\n\n    def test_below_min_raises_range_error(self):\n        schema = {'score': {'type': int, 'min': 0}}\n        with self.assertRaises(RangeValidationError) as ctx:\n            validate_data(schema, {'score': -1})\n        self.assertEqual(ctx.exception.field, 'score')\n        self.assertEqual(ctx.exception.value, -1)\n\n    def test_above_max_raises_range_error(self):\n        schema = {'score': {'type': int, 'max': 100}}\n        with self.assertRaises(RangeValidationError) as ctx:\n            validate_data(schema, {'score': 101})\n        self.assertEqual(ctx.exception.field, 'score')\n\n    def test_pattern_match_ok(self):\n        schema = {'email': {'type': str, 'pattern': r'.+@.+\\..+'}}\n        data = {'email': 'alice@example.com'}\n        self.assertTrue(validate_data(schema, data))\n\n    def test_pattern_no_match_raises(self):\n        schema = {'email': {'type': str, 'pattern': r'.+@.+\\..+'}}\n        with self.assertRaises(PatternValidationError) as ctx:\n            validate_data(schema, {'email': 'bad-email'})\n        self.assertEqual(ctx.exception.field, 'email')\n        self.assertEqual(ctx.exception.value, 'bad-email')\n\n    def test_boundary_min_ok(self):\n        schema = {'val': {'type': int, 'min': 0}}\n        self.assertTrue(validate_data(schema, {'val': 0}))\n\n    def test_boundary_max_ok(self):\n        schema = {'val': {'type': int, 'max': 100}}\n        self.assertTrue(validate_data(schema, {'val': 100}))\n\n    def test_type_checked_before_range(self):\n        schema = {'age': {'type': int, 'min': 0}}\n        with self.assertRaises(TypeValidationError):\n            validate_data(schema, {'age': 'twenty'})\n\n    def test_type_checked_before_pattern(self):\n        schema = {'code': {'type': str, 'pattern': r'\\d+'}}\n        with self.assertRaises(TypeValidationError):\n            validate_data(schema, {'code': 123})\n\n    def test_validates_in_schema_order(self):\n        schema = {\n            'first': {'type': str},\n            'second': {'type': int},\n        }\n        with self.assertRaises(ValidationError) as ctx:\n            validate_data(schema, {'second': 'wrong'})\n        self.assertEqual(ctx.exception.field, 'first')\n\n    def test_complex_schema(self):\n        schema = {\n            'username': {'type': str, 'pattern': r'[a-zA-Z][a-zA-Z0-9_]{2,19}'},\n            'age': {'type': int, 'min': 13, 'max': 120},\n            'score': {'type': float, 'min': 0.0, 'max': 100.0},\n        }\n        valid = {'username': 'alice_123', 'age': 25, 'score': 95.5}\n        self.assertTrue(validate_data(schema, valid))\n\n    def test_float_range(self):\n        schema = {'rating': {'type': float, 'min': 0.0, 'max': 5.0}}\n        self.assertTrue(validate_data(schema, {'rating': 3.5}))\n        with self.assertRaises(RangeValidationError):\n            validate_data(schema, {'rating': 5.1})\n\n    def test_pattern_fullmatch(self):\n        schema = {'code': {'type': str, 'pattern': r'\\d{3}'}}\n        self.assertTrue(validate_data(schema, {'code': '123'}))\n        with self.assertRaises(PatternValidationError):\n            validate_data(schema, {'code': '1234'})\n\n    def test_empty_schema(self):\n        self.assertTrue(validate_data({}, {'anything': 'goes'}))\n",
    "tags": ["exceptions", "custom-exceptions", "inheritance", "validation", "regex"],
    "time_limit_seconds": 5
  }
]

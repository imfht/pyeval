[
  {
    "id": "algo_001",
    "category": "algorithms",
    "difficulty": "easy",
    "title": "Binary Search",
    "passed": false,
    "error": "API error: HTTP Error 429: Too Many Requests",
    "generated_code": "",
    "stdout": "",
    "stderr": "",
    "attempts": 3,
    "successful_attempt": null,
    "score_weight": 0.0
  },
  {
    "id": "algo_002",
    "category": "algorithms",
    "difficulty": "easy",
    "title": "Bubble Sort",
    "passed": false,
    "error": "API error: HTTP Error 429: Too Many Requests",
    "generated_code": "",
    "stdout": "",
    "stderr": "",
    "attempts": 3,
    "successful_attempt": null,
    "score_weight": 0.0
  },
  {
    "id": "algo_003",
    "category": "algorithms",
    "difficulty": "medium",
    "title": "Merge Sort",
    "passed": false,
    "error": "API error: HTTP Error 429: Too Many Requests",
    "generated_code": "",
    "stdout": "",
    "stderr": "",
    "attempts": 3,
    "successful_attempt": null,
    "score_weight": 0.0
  },
  {
    "id": "algo_004",
    "category": "algorithms",
    "difficulty": "medium",
    "title": "Longest Common Subsequence",
    "passed": false,
    "error": "API error: HTTP Error 429: Too Many Requests",
    "generated_code": "",
    "stdout": "",
    "stderr": "",
    "attempts": 3,
    "successful_attempt": null,
    "score_weight": 0.0
  },
  {
    "id": "algo_005",
    "category": "algorithms",
    "difficulty": "medium",
    "title": "Valid Parentheses",
    "passed": false,
    "error": "API error: HTTP Error 429: Too Many Requests",
    "generated_code": "",
    "stdout": "",
    "stderr": "",
    "attempts": 3,
    "successful_attempt": null,
    "score_weight": 0.0
  },
  {
    "id": "algo_006",
    "category": "algorithms",
    "difficulty": "hard",
    "title": "0/1 Knapsack",
    "passed": false,
    "error": "API error: HTTP Error 429: Too Many Requests",
    "generated_code": "",
    "stdout": "",
    "stderr": "",
    "attempts": 3,
    "successful_attempt": null,
    "score_weight": 0.0
  },
  {
    "id": "algo_007",
    "category": "algorithms",
    "difficulty": "hard",
    "title": "Topological Sort",
    "passed": false,
    "error": "API error: HTTP Error 429: Too Many Requests",
    "generated_code": "",
    "stdout": "",
    "stderr": "",
    "attempts": 3,
    "successful_attempt": null,
    "score_weight": 0.0
  },
  {
    "id": "bs_001",
    "category": "basic_syntax",
    "difficulty": "easy",
    "title": "FizzBuzz",
    "passed": false,
    "error": "API error: HTTP Error 429: Too Many Requests",
    "generated_code": "",
    "stdout": "",
    "stderr": "",
    "attempts": 3,
    "successful_attempt": null,
    "score_weight": 0.0
  },
  {
    "id": "bs_002",
    "category": "basic_syntax",
    "difficulty": "easy",
    "title": "Swap Variables",
    "passed": true,
    "error": null,
    "generated_code": "def swap_variables(d: dict) -> dict:\n    \"\"\"\n    Given a dictionary with keys 'a' and 'b', return a new dictionary\n    where the values of 'a' and 'b' are swapped.\n\n    The original dictionary must not be modified.\n\n    Example:\n        swap_variables({'a': 1, 'b': 2}) -> {'a': 2, 'b': 1}\n        swap_variables({'a': 'hello', 'b': 'world'}) -> {'a': 'world', 'b': 'hello'}\n    \"\"\"\n    return {'a': d['b'], 'b': d['a']}",
    "stdout": "",
    "stderr": ".......\n----------------------------------------------------------------------\nRan 7 tests in 0.000s\n\nOK\n",
    "attempts": 1,
    "successful_attempt": 1,
    "score_weight": 1.0
  },
  {
    "id": "bs_003",
    "category": "basic_syntax",
    "difficulty": "easy",
    "title": "Number to Words",
    "passed": true,
    "error": null,
    "generated_code": "def number_to_words(n: int) -> str:\n    \"\"\"\n    Convert an integer from 0 to 999 (inclusive) to its English words representation.\n\n    Rules:\n    - 0 -> \"Zero\"\n    - Use standard English number names\n    - Hyphenate compound numbers 21-99 (e.g., \"Twenty-One\")\n    - Use title case (e.g., \"One Hundred Forty-Five\")\n    - No \"and\" between hundred and tens/ones (e.g., \"One Hundred Twelve\", not \"One Hundred and Twelve\")\n\n    Examples:\n        number_to_words(0) -> \"Zero\"\n        number_to_words(5) -> \"Five\"\n        number_to_words(42) -> \"Forty-Two\"\n        number_to_words(100) -> \"One Hundred\"\n        number_to_words(999) -> \"Nine Hundred Ninety-Nine\"\n        number_to_words(115) -> \"One Hundred Fifteen\"\n    \"\"\"\n    ones = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n    teens = [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n    tens = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n    \n    if n == 0:\n        return \"Zero\"\n    \n    result = []\n    \n    # Handle hundreds\n    if n >= 100:\n        result.append(ones[n // 100])\n        result.append(\"Hundred\")\n        n %= 100\n    \n    # Handle tens and ones\n    if n >= 20:\n        ten_word = tens[n // 10]\n        n %= 10\n        if n > 0:\n            ten_word += \"-\" + ones[n]\n        result.append(ten_word)\n    elif n >= 10:\n        result.append(teens[n - 10])\n    elif n > 0:\n        result.append(ones[n])\n    \n    return \" \".join(result)",
    "stdout": "",
    "stderr": "..........\n----------------------------------------------------------------------\nRan 10 tests in 0.000s\n\nOK\n",
    "attempts": 1,
    "successful_attempt": 1,
    "score_weight": 1.0
  },
  {
    "id": "bs_004",
    "category": "basic_syntax",
    "difficulty": "medium",
    "title": "Flatten Nested List",
    "passed": false,
    "error": "API error: HTTP Error 429: Too Many Requests",
    "generated_code": "",
    "stdout": "",
    "stderr": "",
    "attempts": 3,
    "successful_attempt": null,
    "score_weight": 0.0
  },
  {
    "id": "bs_005",
    "category": "basic_syntax",
    "difficulty": "hard",
    "title": "Matrix Spiral Order",
    "passed": false,
    "error": "API error: HTTP Error 429: Too Many Requests",
    "generated_code": "",
    "stdout": "",
    "stderr": "",
    "attempts": 3,
    "successful_attempt": null,
    "score_weight": 0.0
  },
  {
    "id": "con_001",
    "category": "concurrency",
    "difficulty": "easy",
    "title": "Thread-Safe Counter",
    "passed": true,
    "error": null,
    "generated_code": "import threading\n\nclass ThreadSafeCounter:\n    \"\"\"\n    A thread-safe counter that can be safely incremented and decremented\n    from multiple threads simultaneously.\n\n    Methods:\n        __init__(self, initial=0): Initialize the counter with an optional\n            starting value (default 0).\n        increment(self): Atomically increase the counter by 1.\n        decrement(self): Atomically decrease the counter by 1.\n        get_value(self): Return the current counter value.\n\n    The counter must use threading.Lock to ensure thread safety.\n\n    Examples:\n        counter = ThreadSafeCounter()\n        counter.increment()\n        counter.increment()\n        counter.get_value()  # -> 2\n        counter.decrement()\n        counter.get_value()  # -> 1\n\n        counter = ThreadSafeCounter(10)\n        counter.get_value()  # -> 10\n    \"\"\"\n\n    def __init__(self, initial=0):\n        self._value = initial\n        self._lock = threading.Lock()\n\n    def increment(self):\n        with self._lock:\n            self._value += 1\n\n    def decrement(self):\n        with self._lock:\n            self._value -= 1\n\n    def get_value(self):\n        with self._lock:\n            return self._value",
    "stdout": "",
    "stderr": "..........\n----------------------------------------------------------------------\nRan 10 tests in 0.307s\n\nOK\n",
    "attempts": 1,
    "successful_attempt": 1,
    "score_weight": 1.0
  },
  {
    "id": "con_002",
    "category": "concurrency",
    "difficulty": "medium",
    "title": "Parallel Map",
    "passed": true,
    "error": null,
    "generated_code": "from concurrent.futures import ThreadPoolExecutor\n\ndef parallel_map(func, items: list, max_workers: int = 4) -> list:\n    \"\"\"\n    Apply a function to each item in a list using parallel execution with\n    a thread pool. Return the results in the same order as the input items.\n\n    Args:\n        func: A callable to apply to each item.\n        items: A list of items to process.\n        max_workers: Maximum number of threads to use (default 4).\n\n    Returns:\n        A list of results in the same order as the input.\n\n    Examples:\n        parallel_map(lambda x: x ** 2, [1, 2, 3, 4])  # -> [1, 4, 9, 16]\n        parallel_map(str.upper, [\"hello\", \"world\"])  # -> [\"HELLO\", \"WORLD\"]\n        parallel_map(lambda x: x + 1, [], max_workers=2)  # -> []\n    \"\"\"\n    if not items:\n        return []\n    \n    with ThreadPoolExecutor(max_workers=max_workers) as executor:\n        results = list(executor.map(func, items))\n    \n    return results",
    "stdout": "",
    "stderr": "..........\n----------------------------------------------------------------------\nRan 10 tests in 0.116s\n\nOK\n",
    "attempts": 1,
    "successful_attempt": 1,
    "score_weight": 1.0
  },
  {
    "id": "con_003",
    "category": "concurrency",
    "difficulty": "medium",
    "title": "Producer Consumer",
    "passed": true,
    "error": null,
    "generated_code": "import threading\nimport queue\n\ndef producer_consumer(producers: list, consumers: list, queue_size: int = 10) -> list:\n    \"\"\"\n    Implement the producer-consumer pattern using threading and queue.Queue.\n\n    Args:\n        producers: A list of callables. Each producer callable, when called,\n            returns a list of items to be placed on the queue.\n        consumers: A list of callables. Each consumer callable takes a single\n            item from the queue and returns a processed result.\n        queue_size: Maximum size of the shared queue (default 10).\n\n    Behavior:\n        - Create a bounded Queue with the given queue_size.\n        - Start one thread per consumer FIRST. Each consumer thread loops:\n          gets an item from the queue, and if it's None (sentinel), stops.\n          Otherwise, calls its consumer callable on the item and collects\n          the result.\n        - Start one thread per producer. Each producer thread calls its callable\n          to get items, then puts each item on the queue.\n        - Wait for all producer threads to finish.\n        - Put one sentinel None per consumer on the queue.\n        - Wait for all consumer threads to finish.\n        - Return ALL consumed (processed) results as a single flat list.\n          The order of results does not need to match input order.\n\n    Examples:\n        results = producer_consumer(\n            producers=[lambda: [1, 2, 3], lambda: [4, 5]],\n            consumers=[lambda x: x * 2],\n            queue_size=5\n        )\n        sorted(results)  # -> [2, 4, 6, 8, 10]\n    \"\"\"\n    q = queue.Queue(maxsize=queue_size)\n    results = []\n    results_lock = threading.Lock()\n    \n    def consumer_worker(consumer_func):\n        while True:\n            item = q.get()\n            if item is None:\n                q.task_done()\n                break\n            result = consumer_func(item)\n            with results_lock:\n                results.append(result)\n            q.task_done()\n    \n    def producer_worker(producer_func):\n        items = producer_func()\n        for item in items:\n            q.put(item)\n    \n    # Start consumer threads first\n    consumer_threads = []\n    for consumer in consumers:\n        t = threading.Thread(target=consumer_worker, args=(consumer,))\n        t.start()\n        consumer_threads.append(t)\n    \n    # Start producer threads\n    producer_threads = []\n    for producer in producers:\n        t = threading.Thread(target=producer_worker, args=(producer,))\n        t.start()\n        producer_threads.append(t)\n    \n    # Wait for all producers to finish\n    for t in producer_threads:\n        t.join()\n    \n    # Send sentinel values to stop consumers\n    for _ in consumers:\n        q.put(None)\n    \n    # Wait for all consumers to finish\n    for t in consumer_threads:\n        t.join()\n    \n    return results",
    "stdout": "",
    "stderr": ".........\n----------------------------------------------------------------------\nRan 9 tests in 0.009s\n\nOK\n",
    "attempts": 1,
    "successful_attempt": 1,
    "score_weight": 1.0
  },
  {
    "id": "con_004",
    "category": "concurrency",
    "difficulty": "hard",
    "title": "Async Gather with Timeout",
    "passed": true,
    "error": null,
    "generated_code": "import asyncio\n\nasync def async_gather_results(async_callables: list, timeout: float = None) -> list:\n    \"\"\"\n    Run a list of async callables (coroutine functions) concurrently and\n    return their results.\n\n    Args:\n        async_callables: A list of async callables (coroutine functions that\n            take no arguments). Each one, when called, returns a coroutine.\n        timeout: Optional timeout in seconds. If provided and the total\n            execution exceeds this duration, raise asyncio.TimeoutError.\n            If None, no timeout is applied.\n\n    Returns:\n        A list of results in the same order as the input callables.\n\n    Behavior:\n        - Call each async callable to create a coroutine.\n        - Run all coroutines concurrently using asyncio.gather.\n        - If timeout is specified, use asyncio.wait_for to enforce the timeout\n          around the gather call.\n        - Return the list of results.\n\n    Examples:\n        async def make_value(v):\n            await asyncio.sleep(0.01)\n            return v\n\n        results = await async_gather_results([\n            lambda: make_value(1),\n            lambda: make_value(2),\n            lambda: make_value(3)\n        ])\n        # results -> [1, 2, 3]\n\n        # With timeout (this would raise asyncio.TimeoutError if too slow):\n        results = await async_gather_results(\n            [lambda: make_value(42)],\n            timeout=5.0\n        )\n        # results -> [42]\n    \"\"\"\n    coroutines = [callable_() for callable_ in async_callables]\n    gather_task = asyncio.gather(*coroutines)\n    \n    if timeout is not None:\n        return await asyncio.wait_for(gather_task, timeout=timeout)\n    else:\n        return await gather_task",
    "stdout": "",
    "stderr": "/tmp/tmpphoux98n.py:61: DeprecationWarning: There is no current event loop\n  self.loop = asyncio.get_event_loop()\n...........\n----------------------------------------------------------------------\nRan 11 tests in 0.265s\n\nOK\n",
    "attempts": 1,
    "successful_attempt": 1,
    "score_weight": 1.0
  },
  {
    "id": "ds_001",
    "category": "data_structures",
    "difficulty": "easy",
    "title": "Two Sum",
    "passed": false,
    "error": "API error: HTTP Error 429: Too Many Requests",
    "generated_code": "",
    "stdout": "",
    "stderr": "",
    "attempts": 3,
    "successful_attempt": null,
    "score_weight": 0.0
  },
  {
    "id": "ds_002",
    "category": "data_structures",
    "difficulty": "easy",
    "title": "Reverse Linked List",
    "passed": false,
    "error": "API error: HTTP Error 429: Too Many Requests",
    "generated_code": "",
    "stdout": "",
    "stderr": "",
    "attempts": 3,
    "successful_attempt": null,
    "score_weight": 0.0
  },
  {
    "id": "ds_003",
    "category": "data_structures",
    "difficulty": "medium",
    "title": "LRU Cache",
    "passed": false,
    "error": "API error: HTTP Error 429: Too Many Requests",
    "generated_code": "",
    "stdout": "",
    "stderr": "",
    "attempts": 3,
    "successful_attempt": null,
    "score_weight": 0.0
  },
  {
    "id": "ds_004",
    "category": "data_structures",
    "difficulty": "medium",
    "title": "Group Anagrams",
    "passed": false,
    "error": "API error: HTTP Error 429: Too Many Requests",
    "generated_code": "",
    "stdout": "",
    "stderr": "",
    "attempts": 3,
    "successful_attempt": null,
    "score_weight": 0.0
  },
  {
    "id": "ds_005",
    "category": "data_structures",
    "difficulty": "hard",
    "title": "Merge K Sorted Lists",
    "passed": false,
    "error": "API error: HTTP Error 429: Too Many Requests",
    "generated_code": "",
    "stdout": "",
    "stderr": "",
    "attempts": 3,
    "successful_attempt": null,
    "score_weight": 0.0
  },
  {
    "id": "exc_001",
    "category": "exceptions",
    "difficulty": "easy",
    "title": "Safe Divide",
    "passed": false,
    "error": "API error: HTTP Error 429: Too Many Requests",
    "generated_code": "",
    "stdout": "",
    "stderr": "",
    "attempts": 3,
    "successful_attempt": null,
    "score_weight": 0.0
  },
  {
    "id": "exc_002",
    "category": "exceptions",
    "difficulty": "medium",
    "title": "Retry Decorator",
    "passed": false,
    "error": "API error: HTTP Error 429: Too Many Requests",
    "generated_code": "",
    "stdout": "",
    "stderr": "",
    "attempts": 3,
    "successful_attempt": null,
    "score_weight": 0.0
  },
  {
    "id": "exc_003",
    "category": "exceptions",
    "difficulty": "hard",
    "title": "Custom Exception Hierarchy and Schema Validation",
    "passed": false,
    "error": "API error: HTTP Error 429: Too Many Requests",
    "generated_code": "",
    "stdout": "",
    "stderr": "",
    "attempts": 3,
    "successful_attempt": null,
    "score_weight": 0.0
  },
  {
    "id": "fio_001",
    "category": "file_io",
    "difficulty": "easy",
    "title": "Read CSV Data",
    "passed": true,
    "error": null,
    "generated_code": "import csv\nimport io\n\ndef read_csv_data(csv_string: str) -> list:\n    \"\"\"\n    Parse a CSV-formatted string into a list of dictionaries.\n\n    The first row of the CSV string contains the headers, which become\n    the dictionary keys. Each subsequent row becomes a dictionary with\n    values mapped to the corresponding headers.\n\n    Use the csv module for parsing. Handle quoted fields correctly.\n\n    Args:\n        csv_string: A string containing CSV-formatted data\n\n    Returns:\n        A list of dictionaries, one per data row\n\n    Examples:\n        read_csv_data('name,age\\nAlice,30\\nBob,25')\n        -> [{'name': 'Alice', 'age': '30'}, {'name': 'Bob', 'age': '25'}]\n\n        read_csv_data('a,b\\n1,2')\n        -> [{'a': '1', 'b': '2'}]\n    \"\"\"\n    f = io.StringIO(csv_string)\n    reader = csv.DictReader(f)\n    return list(reader)",
    "stdout": "",
    "stderr": "........\n----------------------------------------------------------------------\nRan 8 tests in 0.000s\n\nOK\n",
    "attempts": 3,
    "successful_attempt": 3,
    "score_weight": 0.3
  },
  {
    "id": "fio_002",
    "category": "file_io",
    "difficulty": "medium",
    "title": "Merge JSON Files",
    "passed": true,
    "error": null,
    "generated_code": "import json\n\ndef merge_json_files(json_strings: list) -> dict:\n    \"\"\"\n    Merge a list of JSON strings into a single dictionary.\n\n    Each JSON string represents a dictionary. Merge them left to right so\n    that later values override earlier ones for the same keys. For nested\n    dictionaries, perform a deep merge: if both the existing and new values\n    for a key are dicts, merge them recursively instead of replacing.\n\n    Non-dict values always override (even if the existing value is a dict).\n\n    Args:\n        json_strings: A list of strings, each a valid JSON object\n\n    Returns:\n        A single merged dictionary\n\n    Examples:\n        merge_json_files(['{\"a\": 1}', '{\"b\": 2}'])\n        -> {'a': 1, 'b': 2}\n\n        merge_json_files(['{\"a\": 1}', '{\"a\": 2}'])\n        -> {'a': 2}\n\n        merge_json_files(['{\"x\": {\"a\": 1, \"b\": 2}}', '{\"x\": {\"b\": 3, \"c\": 4}}'])\n        -> {'x': {'a': 1, 'b': 3, 'c': 4}}\n    \"\"\"\n    def deep_merge(base: dict, update: dict) -> dict:\n        result = base.copy()\n        for key, value in update.items():\n            if key in result and isinstance(result[key], dict) and isinstance(value, dict):\n                result[key] = deep_merge(result[key], value)\n            else:\n                result[key] = value\n        return result\n    \n    result = {}\n    for json_str in json_strings:\n        data = json.loads(json_str)\n        result = deep_merge(result, data)\n    return result",
    "stdout": "",
    "stderr": "...........\n----------------------------------------------------------------------\nRan 11 tests in 0.001s\n\nOK\n",
    "attempts": 2,
    "successful_attempt": 2,
    "score_weight": 0.6
  },
  {
    "id": "fio_003",
    "category": "file_io",
    "difficulty": "hard",
    "title": "Log Parser",
    "passed": true,
    "error": null,
    "generated_code": "import re\n\ndef log_parser(log_lines: list) -> dict:\n    \"\"\"\n    Parse a list of log line strings and extract structured information.\n\n    Each log line is in the format:\n        [TIMESTAMP] LEVEL: message\n    where TIMESTAMP is in 'YYYY-MM-DD HH:MM:SS' format and LEVEL is one\n    of DEBUG, INFO, WARNING, ERROR, CRITICAL.\n\n    Returns a dictionary with:\n        - 'counts': dict mapping each log level to its count\n        - 'errors': list of message strings from ERROR and CRITICAL lines\n          (in order of appearance)\n        - 'timestamp_range': tuple of (earliest, latest) timestamp strings,\n          or None if no log lines are provided\n\n    Args:\n        log_lines: List of log line strings\n\n    Returns:\n        Dict with 'counts', 'errors', and 'timestamp_range' keys\n\n    Examples:\n        log_parser(['[2024-01-15 10:30:45] ERROR: Connection failed',\n                     '[2024-01-15 10:31:00] INFO: Retrying'])\n        -> {\n            'counts': {'ERROR': 1, 'INFO': 1},\n            'errors': ['Connection failed'],\n            'timestamp_range': ('2024-01-15 10:30:45', '2024-01-15 10:31:00')\n        }\n    \"\"\"\n    # Pattern to match log lines: [TIMESTAMP] LEVEL: message\n    pattern = r'\\[(\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2})\\] (DEBUG|INFO|WARNING|ERROR|CRITICAL): (.+)'\n    \n    counts = {}\n    errors = []\n    timestamps = []\n    \n    for line in log_lines:\n        match = re.match(pattern, line.strip())\n        if match:\n            timestamp, level, message = match.groups()\n            \n            # Update counts\n            counts[level] = counts.get(level, 0) + 1\n            \n            # Collect error messages\n            if level in ('ERROR', 'CRITICAL'):\n                errors.append(message)\n            \n            # Collect timestamps\n            timestamps.append(timestamp)\n    \n    # Determine timestamp range\n    if timestamps:\n        timestamp_range = (min(timestamps), max(timestamps))\n    else:\n        timestamp_range = None\n    \n    return {\n        'counts': counts,\n        'errors': errors,\n        'timestamp_range': timestamp_range\n    }",
    "stdout": "",
    "stderr": "..........\n----------------------------------------------------------------------\nRan 10 tests in 0.001s\n\nOK\n",
    "attempts": 1,
    "successful_attempt": 1,
    "score_weight": 1.0
  },
  {
    "id": "fn_001",
    "category": "functional",
    "difficulty": "easy",
    "title": "Apply Pipeline",
    "passed": true,
    "error": null,
    "generated_code": "def apply_pipeline(value, functions: list):\n    \"\"\"\n    Given an initial value and a list of single-argument functions,\n    apply each function in sequence (left to right) to the value,\n    passing the result of each function as input to the next.\n    Return the final result.\n\n    If the functions list is empty, return the original value.\n\n    Examples:\n        apply_pipeline(5, [lambda x: x + 1, lambda x: x * 2]) -> 12\n        apply_pipeline(\"hello\", [str.upper, lambda s: s + \"!\"]) -> \"HELLO!\"\n        apply_pipeline(10, []) -> 10\n        apply_pipeline(-3, [abs, lambda x: x ** 2]) -> 9\n    \"\"\"\n    result = value\n    for func in functions:\n        result = func(result)\n    return result",
    "stdout": "",
    "stderr": "..........\n----------------------------------------------------------------------\nRan 10 tests in 0.000s\n\nOK\n",
    "attempts": 1,
    "successful_attempt": 1,
    "score_weight": 1.0
  },
  {
    "id": "fn_002",
    "category": "functional",
    "difficulty": "medium",
    "title": "Memoize Decorator",
    "passed": true,
    "error": null,
    "generated_code": "def memoize(func):\n    \"\"\"\n    Implement a memoize decorator that caches the results of function calls.\n    If the function is called again with the same positional arguments,\n    return the cached result instead of recomputing.\n\n    Assume all arguments are hashable (can be used as dict keys via tuple).\n    Only positional arguments need to be supported (no kwargs).\n\n    The decorated function should also have a .cache attribute that is\n    the dictionary used for caching (mapping argument tuples to results).\n\n    Examples:\n        @memoize\n        def add(a, b):\n            return a + b\n\n        add(1, 2)  # computes and caches\n        add(1, 2)  # returns cached result\n        add.cache  # {(1, 2): 3}\n    \"\"\"\n    cache = {}\n    \n    def wrapper(*args):\n        if args not in cache:\n            cache[args] = func(*args)\n        return cache[args]\n    \n    wrapper.cache = cache\n    return wrapper",
    "stdout": "",
    "stderr": "........\n----------------------------------------------------------------------\nRan 8 tests in 0.000s\n\nOK\n",
    "attempts": 1,
    "successful_attempt": 1,
    "score_weight": 1.0
  },
  {
    "id": "fn_003",
    "category": "functional",
    "difficulty": "medium",
    "title": "Group By",
    "passed": true,
    "error": null,
    "generated_code": "def group_by(items: list, key_func) -> dict:\n    \"\"\"\n    Group elements of a list by the result of applying key_func to each element.\n    Return a dictionary where keys are the results of key_func and values are\n    lists of items that produced that key, in their original order.\n\n    Examples:\n        group_by([1, 2, 3, 4, 5, 6], lambda x: x % 2 == 0)\n        # -> {False: [1, 3, 5], True: [2, 4, 6]}\n\n        group_by([\"apple\", \"banana\", \"avocado\", \"blueberry\"], lambda s: s[0])\n        # -> {\"a\": [\"apple\", \"avocado\"], \"b\": [\"banana\", \"blueberry\"]}\n\n        group_by([], lambda x: x)\n        # -> {}\n\n        group_by([1, 2, 3, 4, 5], lambda x: \"even\" if x % 2 == 0 else \"odd\")\n        # -> {\"odd\": [1, 3, 5], \"even\": [2, 4]}\n    \"\"\"\n    result = {}\n    for item in items:\n        key = key_func(item)\n        if key not in result:\n            result[key] = []\n        result[key].append(item)\n    return result",
    "stdout": "",
    "stderr": "..........\n----------------------------------------------------------------------\nRan 10 tests in 0.000s\n\nOK\n",
    "attempts": 1,
    "successful_attempt": 1,
    "score_weight": 1.0
  },
  {
    "id": "fn_004",
    "category": "functional",
    "difficulty": "hard",
    "title": "Lazy Evaluation",
    "passed": true,
    "error": null,
    "generated_code": "class Lazy:\n    \"\"\"\n    A lazy evaluation class that wraps an iterable and supports chaining\n    map and filter operations. Operations are NOT executed until\n    .evaluate() is called.\n\n    Methods:\n        __init__(self, iterable): Store the iterable and initialize an empty\n            list of pending operations.\n        map(self, func): Register a map operation. Returns self for chaining.\n        filter(self, predicate): Register a filter operation. Returns self for chaining.\n        evaluate(self): Execute all registered operations in order on the\n            iterable and return the result as a list.\n\n    The Lazy object should be reusable - after calling evaluate(), the\n    pending operations are cleared but the original iterable is preserved,\n    so new chains can be built.\n\n    Examples:\n        Lazy([1, 2, 3, 4, 5]).filter(lambda x: x % 2 == 0).map(lambda x: x * 10).evaluate()\n        # -> [20, 40]\n\n        lazy = Lazy(range(10))\n        lazy.map(lambda x: x ** 2).filter(lambda x: x > 10).evaluate()\n        # -> [16, 25, 36, 49, 64, 81]\n\n        Lazy([]).evaluate()  # -> []\n    \"\"\"\n\n    def __init__(self, iterable):\n        self._iterable = iterable\n        self._operations = []\n\n    def map(self, func):\n        self._operations.append(('map', func))\n        return self\n\n    def filter(self, predicate):\n        self._operations.append(('filter', predicate))\n        return self\n\n    def evaluate(self):\n        result = list(self._iterable)\n        for op_type, func in self._operations:\n            if op_type == 'map':\n                result = [func(x) for x in result]\n            elif op_type == 'filter':\n                result = [x for x in result if func(x)]\n        self._operations = []\n        return result",
    "stdout": "",
    "stderr": "..............\n----------------------------------------------------------------------\nRan 14 tests in 0.001s\n\nOK\n",
    "attempts": 1,
    "successful_attempt": 1,
    "score_weight": 1.0
  },
  {
    "id": "oop_001",
    "category": "oop",
    "difficulty": "easy",
    "title": "Stack Class",
    "passed": false,
    "error": "API error: HTTP Error 429: Too Many Requests",
    "generated_code": "",
    "stdout": "",
    "stderr": "",
    "attempts": 3,
    "successful_attempt": null,
    "score_weight": 0.0
  },
  {
    "id": "oop_002",
    "category": "oop",
    "difficulty": "medium",
    "title": "Shape Hierarchy with Abstract Base Class",
    "passed": false,
    "error": "API error: HTTP Error 429: Too Many Requests",
    "generated_code": "",
    "stdout": "",
    "stderr": "",
    "attempts": 3,
    "successful_attempt": null,
    "score_weight": 0.0
  },
  {
    "id": "oop_003",
    "category": "oop",
    "difficulty": "medium",
    "title": "BankAccount with Transaction History",
    "passed": false,
    "error": "API error: HTTP Error 429: Too Many Requests",
    "generated_code": "",
    "stdout": "",
    "stderr": "",
    "attempts": 3,
    "successful_attempt": null,
    "score_weight": 0.0
  },
  {
    "id": "oop_004",
    "category": "oop",
    "difficulty": "hard",
    "title": "EventEmitter - Observer Pattern",
    "passed": false,
    "error": "API error: HTTP Error 429: Too Many Requests",
    "generated_code": "",
    "stdout": "",
    "stderr": "",
    "attempts": 3,
    "successful_attempt": null,
    "score_weight": 0.0
  },
  {
    "id": "oop_005",
    "category": "oop",
    "difficulty": "hard",
    "title": "ValidatedField Descriptor",
    "passed": false,
    "error": "API error: HTTP Error 429: Too Many Requests",
    "generated_code": "",
    "stdout": "",
    "stderr": "",
    "attempts": 3,
    "successful_attempt": null,
    "score_weight": 0.0
  },
  {
    "id": "std_001",
    "category": "stdlib",
    "difficulty": "easy",
    "title": "Count Words",
    "passed": false,
    "error": "API error: HTTP Error 429: Too Many Requests",
    "generated_code": "",
    "stdout": "",
    "stderr": "",
    "attempts": 3,
    "successful_attempt": null,
    "score_weight": 0.0
  },
  {
    "id": "std_002",
    "category": "stdlib",
    "difficulty": "easy",
    "title": "Parse Date",
    "passed": false,
    "error": "API error: HTTP Error 429: Too Many Requests",
    "generated_code": "",
    "stdout": "",
    "stderr": "",
    "attempts": 3,
    "successful_attempt": null,
    "score_weight": 0.0
  },
  {
    "id": "std_003",
    "category": "stdlib",
    "difficulty": "medium",
    "title": "Validate Email",
    "passed": false,
    "error": "API error: HTTP Error 429: Too Many Requests",
    "generated_code": "",
    "stdout": "",
    "stderr": "",
    "attempts": 3,
    "successful_attempt": null,
    "score_weight": 0.0
  },
  {
    "id": "std_004",
    "category": "stdlib",
    "difficulty": "medium",
    "title": "Cartesian Product Filter",
    "passed": false,
    "error": "API error: HTTP Error 429: Too Many Requests",
    "generated_code": "",
    "stdout": "",
    "stderr": "",
    "attempts": 3,
    "successful_attempt": null,
    "score_weight": 0.0
  },
  {
    "id": "std_005",
    "category": "stdlib",
    "difficulty": "hard",
    "title": "Parallel Map",
    "passed": false,
    "error": "API error: HTTP Error 429: Too Many Requests",
    "generated_code": "",
    "stdout": "",
    "stderr": "",
    "attempts": 3,
    "successful_attempt": null,
    "score_weight": 0.0
  },
  {
    "id": "str_001",
    "category": "string_processing",
    "difficulty": "easy",
    "title": "Is Palindrome",
    "passed": true,
    "error": null,
    "generated_code": "import re\n\ndef is_palindrome(s: str) -> bool:\n    \"\"\"\n    Check if a string is a palindrome, ignoring case, spaces, and punctuation.\n\n    Only consider alphanumeric characters when determining if the string\n    is a palindrome.\n\n    Args:\n        s: The input string\n\n    Returns:\n        True if the string is a palindrome, False otherwise\n\n    Examples:\n        is_palindrome('racecar') -> True\n        is_palindrome('A man, a plan, a canal: Panama') -> True\n        is_palindrome('hello') -> False\n        is_palindrome('') -> True\n    \"\"\"\n    # Remove all non-alphanumeric characters and convert to lowercase\n    cleaned = re.sub(r'[^a-zA-Z0-9]', '', s).lower()\n    \n    # Check if the cleaned string equals its reverse\n    return cleaned == cleaned[::-1]",
    "stdout": "",
    "stderr": ".............\n----------------------------------------------------------------------\nRan 13 tests in 0.001s\n\nOK\n",
    "attempts": 1,
    "successful_attempt": 1,
    "score_weight": 1.0
  },
  {
    "id": "str_002",
    "category": "string_processing",
    "difficulty": "easy",
    "title": "Caesar Cipher",
    "passed": true,
    "error": null,
    "generated_code": "def caesar_cipher(text: str, shift: int, mode: str = 'encrypt') -> str:\n    \"\"\"\n    Encrypt or decrypt text using a Caesar cipher.\n\n    Shift each letter by the given amount. Preserve case. Non-alphabetic\n    characters (spaces, punctuation, digits) are left unchanged.\n\n    For encryption, shift letters forward in the alphabet.\n    For decryption, shift letters backward.\n\n    The shift value can be any integer and will be normalized mod 26.\n\n    Args:\n        text: The input string\n        shift: Integer shift value\n        mode: 'encrypt' or 'decrypt'\n\n    Returns:\n        The encrypted or decrypted string\n\n    Examples:\n        caesar_cipher('Hello, World!', 3, 'encrypt') -> 'Khoor, Zruog!'\n        caesar_cipher('Khoor, Zruog!', 3, 'decrypt') -> 'Hello, World!'\n        caesar_cipher('abc', 1, 'encrypt') -> 'bcd'\n        caesar_cipher('xyz', 3, 'encrypt') -> 'abc'\n    \"\"\"\n    # Normalize shift to be within 0-25\n    shift = shift % 26\n    \n    # Adjust shift for decryption\n    if mode == 'decrypt':\n        shift = -shift\n    elif mode != 'encrypt':\n        raise ValueError(\"mode must be 'encrypt' or 'decrypt'\")\n    \n    result = []\n    \n    for char in text:\n        if char.isalpha():\n            # Determine base ASCII value ('A' for uppercase, 'a' for lowercase)\n            base = ord('A') if char.isupper() else ord('a')\n            # Calculate shifted position\n            shifted = (ord(char) - base + shift) % 26\n            # Convert back to character\n            new_char = chr(base + shifted)\n            result.append(new_char)\n        else:\n            # Non-alphabetic characters remain unchanged\n            result.append(char)\n    \n    return ''.join(result)",
    "stdout": "",
    "stderr": ".............\n----------------------------------------------------------------------\nRan 13 tests in 0.000s\n\nOK\n",
    "attempts": 1,
    "successful_attempt": 1,
    "score_weight": 1.0
  },
  {
    "id": "str_003",
    "category": "string_processing",
    "difficulty": "medium",
    "title": "Extract URLs",
    "passed": true,
    "error": null,
    "generated_code": "import re\n\ndef extract_urls(text: str) -> list:\n    \"\"\"\n    Extract all URLs from a text string.\n\n    Find all URLs that start with http:// or https:// followed by\n    one or more non-whitespace characters. URLs should not end with\n    trailing punctuation marks (period, comma, semicolon, exclamation\n    mark, question mark, closing parenthesis) that are likely part of\n    the surrounding text rather than the URL itself.\n\n    Args:\n        text: The input string that may contain URLs\n\n    Returns:\n        A list of URL strings found in the text, in order of appearance\n\n    Examples:\n        extract_urls('Visit https://example.com for more info')\n        -> ['https://example.com']\n\n        extract_urls('No URLs here')\n        -> []\n\n        extract_urls('Go to http://a.com and https://b.com/path')\n        -> ['http://a.com', 'https://b.com/path']\n    \"\"\"\n    # Pattern to match URLs starting with http:// or https://\n    # followed by non-whitespace characters\n    pattern = r'https?://\\S+'\n    \n    # Find all potential URLs\n    matches = re.findall(pattern, text)\n    \n    # Strip trailing punctuation that is likely not part of the URL\n    result = []\n    for url in matches:\n        # Remove trailing punctuation marks\n        stripped_url = url.rstrip('.,;!?)]')\n        result.append(stripped_url)\n    \n    return result",
    "stdout": "",
    "stderr": ".............\n----------------------------------------------------------------------\nRan 13 tests in 0.001s\n\nOK\n",
    "attempts": 1,
    "successful_attempt": 1,
    "score_weight": 1.0
  },
  {
    "id": "str_004",
    "category": "string_processing",
    "difficulty": "hard",
    "title": "Template Engine",
    "passed": true,
    "error": null,
    "generated_code": "import re\n\ndef template_engine(template: str, context: dict) -> str:\n    \"\"\"\n    Implement a simple template engine that replaces placeholders with values.\n\n    Placeholders are enclosed in double curly braces: {{key}}\n\n    Features:\n    - Simple replacement: {{name}} is replaced with context['name']\n    - Nested access: {{user.name}} accesses context['user']['name']\n    - Default values: {{key|default}} uses 'default' if key is missing\n    - If a key is not found and no default is given, leave the placeholder as-is\n    - Strip whitespace inside braces: {{ name }} is the same as {{name}}\n    - Values are converted to strings using str()\n\n    Args:\n        template: A string with {{placeholder}} markers\n        context: A dictionary of values for substitution\n\n    Returns:\n        The template string with placeholders replaced\n\n    Examples:\n        template_engine('Hello {{name}}!', {'name': 'World'})\n        -> 'Hello World!'\n\n        template_engine('{{user.name}} is {{user.age}}',\n                        {'user': {'name': 'Alice', 'age': 30}})\n        -> 'Alice is 30'\n\n        template_engine('{{missing|default_val}}', {})\n        -> 'default_val'\n\n        template_engine('{{missing}}', {})\n        -> '{{missing}}'\n    \"\"\"\n    def get_value(key_path: str, ctx: dict):\n        \"\"\"Get value from nested dictionary using dot notation.\"\"\"\n        keys = key_path.split('.')\n        current = ctx\n        for key in keys:\n            if isinstance(current, dict) and key in current:\n                current = current[key]\n            else:\n                return None\n        return current\n    \n    def replace_placeholder(match):\n        content = match.group(1).strip()\n        \n        # Check for default value\n        if '|' in content:\n            key_path, default = content.split('|', 1)\n            key_path = key_path.strip()\n            default = default.strip()\n        else:\n            key_path = content\n            default = None\n        \n        value = get_value(key_path, context)\n        \n        if value is None:\n            if default is not None:\n                return default\n            else:\n                # Return original placeholder if key not found and no default\n                return match.group(0)\n        else:\n            return str(value)\n    \n    # Pattern to match {{...}}\n    pattern = r'\\{\\{(.*?)\\}\\}'\n    return re.sub(pattern, replace_placeholder, template)",
    "stdout": "",
    "stderr": ".................\n----------------------------------------------------------------------\nRan 17 tests in 0.001s\n\nOK\n",
    "attempts": 1,
    "successful_attempt": 1,
    "score_weight": 1.0
  }
]
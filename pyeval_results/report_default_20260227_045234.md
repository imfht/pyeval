# PyEval Report: default

**Date:** 2026-02-27 04:52:34 UTC  
**Overall Pass Rate:** 100.0%  
**Weighted Score:** 100.0% (easy=1x, medium=2x, hard=3x)  
**Total:** 3/3

## Summary

| Category | Easy | Medium | Hard | Total |
|----------|------|--------|------|-------|
| OOP | - | 1/1 | 1/1 | 2/2 |
| Exceptions | - | - | 1/1 | 1/1 |
| **TOTAL** | **-** | **1/1** | **2/2** | **3/3** |

## Detailed Results

### [PASS] exc_003: Custom Exception Hierarchy and Schema Validation

- **Category:** exceptions
- **Difficulty:** hard

<details><summary>Generated Code</summary>

```python
import re


class ValidationError(Exception):
    """Base exception for validation errors."""

    def __init__(self, field, message):
        self.field = field
        self.message = message
        super().__init__(f"{field}: {message}")


class TypeValidationError(ValidationError):
    """Raised when a field has the wrong type."""

    def __init__(self, field, expected_type, actual_type):
        self.expected_type = expected_type
        self.actual_type = actual_type
        super().__init__(
            field,
            f"expected {expected_type.__name__}, got {actual_type.__name__}"
        )


class RangeValidationError(ValidationError):
    """Raised when a numeric field is out of range."""

    def __init__(self, field, value, min_value=None, max_value=None):
        self.value = value
        self.min_value = min_value
        self.max_value = max_value
        parts = []
        if min_value is not None:
            parts.append(f">= {min_value}")
        if max_value is not None:
            parts.append(f"<= {max_value}")
        constraint = " and ".join(parts)
        super().__init__(
            field,
            f"value {value} is out of range ({constraint})"
        )


class PatternValidationError(ValidationError):
    """Raised when a string field does not match a regex pattern."""

    def __init__(self, field, pattern, value):
        self.pattern = pattern
        self.value = value
        super().__init__(
            field,
            f"value '{value}' does not match pattern '{pattern}'"
        )


def validate_data(schema, data):
    """Validate data against a schema, raising appropriate exceptions."""
    for field_name, rules in schema.items():
        required = rules.get('required', True)

        if field_name not in data:
            if required:
                raise ValidationError(field_name, "required field is missing")
            continue

        value = data[field_name]

        # Type check
        if 'type' in rules:
            expected = rules['type']
            if not isinstance(value, expected):
                raise TypeValidationError(field_name, expected, type(value))

        # Range check (for numeric types)
        min_val = rules.get('min')
        max_val = rules.get('max')
        if min_val is not None and value < min_val:
            raise RangeValidationError(field_name, value, min_value=min_val, max_value=max_val)
        if max_val is not None and value > max_val:
            raise RangeValidationError(field_name, value, min_value=min_val, max_value=max_val)

        # Pattern check (for string types)
        if 'pattern' in rules:
            pattern = rules['pattern']
            if not re.fullmatch(pattern, value):
                raise PatternValidationError(field_name, pattern, value)

    return True

```

</details>

### [PASS] oop_003: BankAccount with Transaction History

- **Category:** oop
- **Difficulty:** medium

<details><summary>Generated Code</summary>

```python
class BankAccount:
    """A bank account with deposit, withdraw, transfer, and transaction history."""

    def __init__(self, owner: str, initial_balance: float = 0.0):
        if initial_balance < 0:
            raise ValueError("initial_balance cannot be negative")
        self.owner = owner
        self._balance = initial_balance
        self._history = []

    @property
    def balance(self) -> float:
        """The current balance (read-only)."""
        return self._balance

    def deposit(self, amount: float) -> None:
        """Add amount to balance."""
        if amount <= 0:
            raise ValueError("deposit amount must be positive")
        self._balance += amount
        self._history.append(('deposit', amount))

    def withdraw(self, amount: float) -> None:
        """Subtract amount from balance."""
        if amount <= 0:
            raise ValueError("withdraw amount must be positive")
        if amount > self._balance:
            raise ValueError("insufficient funds")
        self._balance -= amount
        self._history.append(('withdraw', amount))

    def transfer_to(self, other_account: 'BankAccount', amount: float) -> None:
        """Transfer amount from this account to other_account."""
        if amount <= 0:
            raise ValueError("transfer amount must be positive")
        if amount > self._balance:
            raise ValueError("insufficient funds")
        self._balance -= amount
        other_account._balance += amount
        self._history.append(('transfer_out', amount))
        other_account._history.append(('transfer_in', amount))

    def get_history(self) -> list:
        """Return a list of all transaction tuples in chronological order."""
        return list(self._history)

```

</details>

### [PASS] oop_005: ValidatedField Descriptor

- **Category:** oop
- **Difficulty:** hard

<details><summary>Generated Code</summary>

```python
class ValidatedField:
    """A descriptor that validates field values on assignment."""

    def __init__(self, field_type, *, min_value=None, max_value=None, max_length=None):
        self.field_type = field_type
        self.min_value = min_value
        self.max_value = max_value
        self.max_length = max_length

    def __set_name__(self, owner, name):
        self.attr_name = '_validated_' + name
        self.public_name = name

    def __get__(self, obj, objtype=None):
        if obj is None:
            return self
        if not hasattr(obj, self.attr_name):
            raise AttributeError(f"'{type(obj).__name__}' object has no attribute '{self.public_name}'")
        return getattr(obj, self.attr_name)

    def __set__(self, obj, value):
        if not isinstance(value, self.field_type):
            raise TypeError(
                f"Expected {self.field_type.__name__} for '{self.public_name}', "
                f"got {type(value).__name__}"
            )
        if self.field_type in (int, float):
            if self.min_value is not None and value < self.min_value:
                raise ValueError(
                    f"'{self.public_name}' must be >= {self.min_value}, got {value}"
                )
            if self.max_value is not None and value > self.max_value:
                raise ValueError(
                    f"'{self.public_name}' must be <= {self.max_value}, got {value}"
                )
        if self.field_type is str:
            if self.max_length is not None and len(value) > self.max_length:
                raise ValueError(
                    f"'{self.public_name}' length must be <= {self.max_length}, got {len(value)}"
                )
        setattr(obj, self.attr_name, value)


class Person:
    """A class using ValidatedField descriptors."""
    name = ValidatedField(str, max_length=50)
    age = ValidatedField(int, min_value=0, max_value=200)
    email = ValidatedField(str, max_length=100)

    def __init__(self, name: str, age: int, email: str):
        self.name = name
        self.age = age
        self.email = email

```

</details>

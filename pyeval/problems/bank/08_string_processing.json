[
  {
    "id": "str_001",
    "category": "string_processing",
    "difficulty": "easy",
    "title": "Is Palindrome",
    "prompt": "import re\n\ndef is_palindrome(s: str) -> bool:\n    \"\"\"\n    Check if a string is a palindrome, ignoring case, spaces, and punctuation.\n\n    Only consider alphanumeric characters when determining if the string\n    is a palindrome.\n\n    Args:\n        s: The input string\n\n    Returns:\n        True if the string is a palindrome, False otherwise\n\n    Examples:\n        is_palindrome('racecar') -> True\n        is_palindrome('A man, a plan, a canal: Panama') -> True\n        is_palindrome('hello') -> False\n        is_palindrome('') -> True\n    \"\"\"",
    "reference_solution": "import re\n\ndef is_palindrome(s: str) -> bool:\n    \"\"\"\n    Check if a string is a palindrome, ignoring case, spaces, and punctuation.\n\n    Only consider alphanumeric characters when determining if the string\n    is a palindrome.\n\n    Args:\n        s: The input string\n\n    Returns:\n        True if the string is a palindrome, False otherwise\n\n    Examples:\n        is_palindrome('racecar') -> True\n        is_palindrome('A man, a plan, a canal: Panama') -> True\n        is_palindrome('hello') -> False\n        is_palindrome('') -> True\n    \"\"\"\n    cleaned = re.sub(r'[^a-zA-Z0-9]', '', s).lower()\n    return cleaned == cleaned[::-1]",
    "test_code": "import unittest\n\nclass TestIsPalindrome(unittest.TestCase):\n    def test_simple_palindrome(self):\n        self.assertTrue(is_palindrome('racecar'))\n\n    def test_mixed_case_and_punctuation(self):\n        self.assertTrue(is_palindrome('A man, a plan, a canal: Panama'))\n\n    def test_not_palindrome(self):\n        self.assertFalse(is_palindrome('hello'))\n\n    def test_empty_string(self):\n        self.assertTrue(is_palindrome(''))\n\n    def test_single_char(self):\n        self.assertTrue(is_palindrome('a'))\n\n    def test_with_spaces(self):\n        self.assertTrue(is_palindrome('Was it a car or a cat I saw'))\n\n    def test_numeric_palindrome(self):\n        self.assertTrue(is_palindrome('12321'))\n\n    def test_numeric_not_palindrome(self):\n        self.assertFalse(is_palindrome('12345'))\n\n    def test_mixed_alphanumeric(self):\n        self.assertTrue(is_palindrome('A1b2b1a'))\n\n    def test_only_punctuation(self):\n        self.assertTrue(is_palindrome('!!..,,'))\n\n    def test_two_chars_palindrome(self):\n        self.assertTrue(is_palindrome('aa'))\n\n    def test_two_chars_not_palindrome(self):\n        self.assertFalse(is_palindrome('ab'))\n\n    def test_sentence_palindrome(self):\n        self.assertTrue(is_palindrome('No lemon, no melon'))",
    "tags": ["string", "palindrome", "regex", "cleaning"],
    "time_limit_seconds": 5
  },
  {
    "id": "str_002",
    "category": "string_processing",
    "difficulty": "easy",
    "title": "Caesar Cipher",
    "prompt": "def caesar_cipher(text: str, shift: int, mode: str = 'encrypt') -> str:\n    \"\"\"\n    Encrypt or decrypt text using a Caesar cipher.\n\n    Shift each letter by the given amount. Preserve case. Non-alphabetic\n    characters (spaces, punctuation, digits) are left unchanged.\n\n    For encryption, shift letters forward in the alphabet.\n    For decryption, shift letters backward.\n\n    The shift value can be any integer and will be normalized mod 26.\n\n    Args:\n        text: The input string\n        shift: Integer shift value\n        mode: 'encrypt' or 'decrypt'\n\n    Returns:\n        The encrypted or decrypted string\n\n    Examples:\n        caesar_cipher('Hello, World!', 3, 'encrypt') -> 'Khoor, Zruog!'\n        caesar_cipher('Khoor, Zruog!', 3, 'decrypt') -> 'Hello, World!'\n        caesar_cipher('abc', 1, 'encrypt') -> 'bcd'\n        caesar_cipher('xyz', 3, 'encrypt') -> 'abc'\n    \"\"\"",
    "reference_solution": "def caesar_cipher(text: str, shift: int, mode: str = 'encrypt') -> str:\n    \"\"\"\n    Encrypt or decrypt text using a Caesar cipher.\n\n    Shift each letter by the given amount. Preserve case. Non-alphabetic\n    characters (spaces, punctuation, digits) are left unchanged.\n\n    For encryption, shift letters forward in the alphabet.\n    For decryption, shift letters backward.\n\n    The shift value can be any integer and will be normalized mod 26.\n\n    Args:\n        text: The input string\n        shift: Integer shift value\n        mode: 'encrypt' or 'decrypt'\n\n    Returns:\n        The encrypted or decrypted string\n\n    Examples:\n        caesar_cipher('Hello, World!', 3, 'encrypt') -> 'Khoor, Zruog!'\n        caesar_cipher('Khoor, Zruog!', 3, 'decrypt') -> 'Hello, World!'\n        caesar_cipher('abc', 1, 'encrypt') -> 'bcd'\n        caesar_cipher('xyz', 3, 'encrypt') -> 'abc'\n    \"\"\"\n    if mode == 'decrypt':\n        shift = -shift\n    shift = shift % 26\n    result = []\n    for ch in text:\n        if ch.isalpha():\n            base = ord('A') if ch.isupper() else ord('a')\n            result.append(chr((ord(ch) - base + shift) % 26 + base))\n        else:\n            result.append(ch)\n    return ''.join(result)",
    "test_code": "import unittest\n\nclass TestCaesarCipher(unittest.TestCase):\n    def test_encrypt_basic(self):\n        self.assertEqual(caesar_cipher('Hello, World!', 3, 'encrypt'), 'Khoor, Zruog!')\n\n    def test_decrypt_basic(self):\n        self.assertEqual(caesar_cipher('Khoor, Zruog!', 3, 'decrypt'), 'Hello, World!')\n\n    def test_encrypt_lowercase(self):\n        self.assertEqual(caesar_cipher('abc', 1, 'encrypt'), 'bcd')\n\n    def test_wrap_around(self):\n        self.assertEqual(caesar_cipher('xyz', 3, 'encrypt'), 'abc')\n\n    def test_shift_26(self):\n        self.assertEqual(caesar_cipher('ABC', 26, 'encrypt'), 'ABC')\n\n    def test_shift_zero(self):\n        self.assertEqual(caesar_cipher('Hello', 0, 'encrypt'), 'Hello')\n\n    def test_preserve_digits(self):\n        self.assertEqual(caesar_cipher('Test 123!', 13, 'encrypt'), 'Grfg 123!')\n\n    def test_roundtrip(self):\n        original = 'The quick brown fox jumps over the lazy dog!'\n        encrypted = caesar_cipher(original, 7, 'encrypt')\n        decrypted = caesar_cipher(encrypted, 7, 'decrypt')\n        self.assertEqual(decrypted, original)\n\n    def test_large_shift(self):\n        self.assertEqual(caesar_cipher('abc', 27, 'encrypt'), 'bcd')\n\n    def test_negative_effective_shift(self):\n        self.assertEqual(caesar_cipher('bcd', 1, 'decrypt'), 'abc')\n\n    def test_all_uppercase(self):\n        self.assertEqual(caesar_cipher('ABC', 3, 'encrypt'), 'DEF')\n\n    def test_preserve_spaces_only(self):\n        self.assertEqual(caesar_cipher('   ', 5, 'encrypt'), '   ')\n\n    def test_empty_string(self):\n        self.assertEqual(caesar_cipher('', 5, 'encrypt'), '')",
    "tags": ["string", "cipher", "encryption", "ascii"],
    "time_limit_seconds": 5
  },
  {
    "id": "str_003",
    "category": "string_processing",
    "difficulty": "medium",
    "title": "Extract URLs",
    "prompt": "import re\n\ndef extract_urls(text: str) -> list:\n    \"\"\"\n    Extract all URLs from a text string.\n\n    Find all URLs that start with http:// or https:// followed by\n    one or more non-whitespace characters. URLs should not end with\n    trailing punctuation marks (period, comma, semicolon, exclamation\n    mark, question mark, closing parenthesis) that are likely part of\n    the surrounding text rather than the URL itself.\n\n    Args:\n        text: The input string that may contain URLs\n\n    Returns:\n        A list of URL strings found in the text, in order of appearance\n\n    Examples:\n        extract_urls('Visit https://example.com for more info')\n        -> ['https://example.com']\n\n        extract_urls('No URLs here')\n        -> []\n\n        extract_urls('Go to http://a.com and https://b.com/path')\n        -> ['http://a.com', 'https://b.com/path']\n    \"\"\"",
    "reference_solution": "import re\n\ndef extract_urls(text: str) -> list:\n    \"\"\"\n    Extract all URLs from a text string.\n\n    Find all URLs that start with http:// or https:// followed by\n    one or more non-whitespace characters. URLs should not end with\n    trailing punctuation marks (period, comma, semicolon, exclamation\n    mark, question mark, closing parenthesis) that are likely part of\n    the surrounding text rather than the URL itself.\n\n    Args:\n        text: The input string that may contain URLs\n\n    Returns:\n        A list of URL strings found in the text, in order of appearance\n\n    Examples:\n        extract_urls('Visit https://example.com for more info')\n        -> ['https://example.com']\n\n        extract_urls('No URLs here')\n        -> []\n\n        extract_urls('Go to http://a.com and https://b.com/path')\n        -> ['http://a.com', 'https://b.com/path']\n    \"\"\"\n    pattern = r'https?://[^\\s]+'\n    urls = re.findall(pattern, text)\n    cleaned = []\n    for url in urls:\n        while url and url[-1] in '.,;!?)':\n            url = url[:-1]\n        cleaned.append(url)\n    return cleaned",
    "test_code": "import unittest\n\nclass TestExtractUrls(unittest.TestCase):\n    def test_single_url(self):\n        result = extract_urls('Visit https://example.com for more info')\n        self.assertEqual(result, ['https://example.com'])\n\n    def test_no_urls(self):\n        result = extract_urls('No URLs here')\n        self.assertEqual(result, [])\n\n    def test_multiple_urls(self):\n        result = extract_urls('Go to http://a.com and https://b.com/path')\n        self.assertEqual(result, ['http://a.com', 'https://b.com/path'])\n\n    def test_url_with_query_params(self):\n        result = extract_urls('See https://example.com/page?q=1&r=2 ok')\n        self.assertEqual(result, ['https://example.com/page?q=1&r=2'])\n\n    def test_url_followed_by_period(self):\n        result = extract_urls('Check https://example.com.')\n        self.assertEqual(result, ['https://example.com'])\n\n    def test_url_followed_by_comma(self):\n        result = extract_urls('Link: https://x.com/a, and https://y.com/b.')\n        self.assertEqual(result, ['https://x.com/a', 'https://y.com/b'])\n\n    def test_url_in_parentheses(self):\n        result = extract_urls('(see https://example.com)')\n        self.assertEqual(result, ['https://example.com'])\n\n    def test_http_url(self):\n        result = extract_urls('Old site: http://legacy.example.org/page')\n        self.assertEqual(result, ['http://legacy.example.org/page'])\n\n    def test_url_with_path(self):\n        result = extract_urls('Read https://docs.example.com/en/latest/guide.html here')\n        self.assertEqual(result, ['https://docs.example.com/en/latest/guide.html'])\n\n    def test_url_with_fragment(self):\n        result = extract_urls('Go to https://example.com/page#section now')\n        self.assertEqual(result, ['https://example.com/page#section'])\n\n    def test_empty_string(self):\n        result = extract_urls('')\n        self.assertEqual(result, [])\n\n    def test_url_at_end_of_string(self):\n        result = extract_urls('Link: https://example.com/final')\n        self.assertEqual(result, ['https://example.com/final'])\n\n    def test_multiple_trailing_punctuation(self):\n        result = extract_urls('See https://example.com!!!')\n        self.assertEqual(result, ['https://example.com'])",
    "tags": ["regex", "url", "string", "extraction"],
    "time_limit_seconds": 5
  },
  {
    "id": "str_004",
    "category": "string_processing",
    "difficulty": "hard",
    "title": "Template Engine",
    "prompt": "import re\n\ndef template_engine(template: str, context: dict) -> str:\n    \"\"\"\n    Implement a simple template engine that replaces placeholders with values.\n\n    Placeholders are enclosed in double curly braces: {{key}}\n\n    Features:\n    - Simple replacement: {{name}} is replaced with context['name']\n    - Nested access: {{user.name}} accesses context['user']['name']\n    - Default values: {{key|default}} uses 'default' if key is missing\n    - If a key is not found and no default is given, leave the placeholder as-is\n    - Strip whitespace inside braces: {{ name }} is the same as {{name}}\n    - Values are converted to strings using str()\n\n    Args:\n        template: A string with {{placeholder}} markers\n        context: A dictionary of values for substitution\n\n    Returns:\n        The template string with placeholders replaced\n\n    Examples:\n        template_engine('Hello {{name}}!', {'name': 'World'})\n        -> 'Hello World!'\n\n        template_engine('{{user.name}} is {{user.age}}',\n                        {'user': {'name': 'Alice', 'age': 30}})\n        -> 'Alice is 30'\n\n        template_engine('{{missing|default_val}}', {})\n        -> 'default_val'\n\n        template_engine('{{missing}}', {})\n        -> '{{missing}}'\n    \"\"\"",
    "reference_solution": "import re\n\ndef template_engine(template: str, context: dict) -> str:\n    \"\"\"\n    Implement a simple template engine that replaces placeholders with values.\n\n    Placeholders are enclosed in double curly braces: {{key}}\n\n    Features:\n    - Simple replacement: {{name}} is replaced with context['name']\n    - Nested access: {{user.name}} accesses context['user']['name']\n    - Default values: {{key|default}} uses 'default' if key is missing\n    - If a key is not found and no default is given, leave the placeholder as-is\n    - Strip whitespace inside braces: {{ name }} is the same as {{name}}\n    - Values are converted to strings using str()\n\n    Args:\n        template: A string with {{placeholder}} markers\n        context: A dictionary of values for substitution\n\n    Returns:\n        The template string with placeholders replaced\n\n    Examples:\n        template_engine('Hello {{name}}!', {'name': 'World'})\n        -> 'Hello World!'\n\n        template_engine('{{user.name}} is {{user.age}}',\n                        {'user': {'name': 'Alice', 'age': 30}})\n        -> 'Alice is 30'\n\n        template_engine('{{missing|default_val}}', {})\n        -> 'default_val'\n\n        template_engine('{{missing}}', {})\n        -> '{{missing}}'\n    \"\"\"\n    def resolve(key, ctx):\n        parts = key.split('.')\n        current = ctx\n        for part in parts:\n            if isinstance(current, dict) and part in current:\n                current = current[part]\n            else:\n                return None\n        return current\n\n    def replacer(match):\n        content = match.group(1).strip()\n        default = None\n        if '|' in content:\n            key_part, default = content.split('|', 1)\n            key_part = key_part.strip()\n            default = default.strip()\n        else:\n            key_part = content\n\n        value = resolve(key_part, context)\n        if value is not None:\n            return str(value)\n        elif default is not None:\n            return default\n        else:\n            return match.group(0)\n\n    return re.sub(r'\\{\\{(.*?)\\}\\}', replacer, template)",
    "test_code": "import unittest\n\nclass TestTemplateEngine(unittest.TestCase):\n    def test_simple_replacement(self):\n        self.assertEqual(template_engine('Hello {{name}}!', {'name': 'World'}), 'Hello World!')\n\n    def test_nested_access(self):\n        ctx = {'user': {'name': 'Alice', 'age': 30}}\n        self.assertEqual(template_engine('{{user.name}} is {{user.age}}', ctx), 'Alice is 30')\n\n    def test_default_value(self):\n        self.assertEqual(template_engine('{{missing|default_val}}', {}), 'default_val')\n\n    def test_missing_no_default(self):\n        self.assertEqual(template_engine('{{missing}}', {}), '{{missing}}')\n\n    def test_whitespace_in_braces(self):\n        self.assertEqual(template_engine('{{ name }}', {'name': 'Test'}), 'Test')\n\n    def test_no_placeholders(self):\n        self.assertEqual(template_engine('No placeholders here', {'a': 1}), 'No placeholders here')\n\n    def test_deep_nested(self):\n        ctx = {'a': {'b': {'c': 'deep'}}}\n        self.assertEqual(template_engine('{{a.b.c}}', ctx), 'deep')\n\n    def test_mixed_found_and_missing(self):\n        self.assertEqual(template_engine('{{x|fallback}} and {{y}}', {'y': 'found'}), 'fallback and found')\n\n    def test_numeric_value(self):\n        self.assertEqual(template_engine('{{val}}', {'val': 42}), '42')\n\n    def test_multiple_placeholders(self):\n        ctx = {'first': 'John', 'last': 'Doe'}\n        self.assertEqual(template_engine('{{first}} {{last}}', ctx), 'John Doe')\n\n    def test_empty_template(self):\n        self.assertEqual(template_engine('', {'a': 1}), '')\n\n    def test_empty_context(self):\n        self.assertEqual(template_engine('{{a}} {{b}}', {}), '{{a}} {{b}}')\n\n    def test_boolean_value(self):\n        self.assertEqual(template_engine('{{flag}}', {'flag': True}), 'True')\n\n    def test_default_with_existing_key(self):\n        self.assertEqual(template_engine('{{name|fallback}}', {'name': 'Alice'}), 'Alice')\n\n    def test_nested_missing_intermediate(self):\n        self.assertEqual(template_engine('{{a.b.c}}', {'a': 'not_a_dict'}), '{{a.b.c}}')\n\n    def test_pipe_in_default(self):\n        self.assertEqual(template_engine('{{x|a|b}}', {}), 'a|b')\n\n    def test_list_value(self):\n        self.assertEqual(template_engine('{{items}}', {'items': [1, 2, 3]}), '[1, 2, 3]')",
    "tags": ["regex", "template", "string", "nested-access", "recursion"],
    "time_limit_seconds": 10
  }
]

[
  {
    "id": "bf_011",
    "category": "bugfix",
    "difficulty": "hard",
    "title": "Thread race condition - missing lock",
    "buggy_code": "import threading\n\nclass Counter:\n    \"\"\"A thread-safe counter.\"\"\"\n    def __init__(self):\n        self.value = 0\n\n    def increment(self):\n        self.value += 1\n\n    def get(self) -> int:\n        return self.value\n\n\ndef parallel_increment(n: int, num_threads: int = 4) -> int:\n    \"\"\"Increment a counter n times using multiple threads.\n    Returns the final counter value which should equal n.\"\"\"\n    counter = Counter()\n    threads = []\n    per_thread = n // num_threads\n\n    def worker(count):\n        for _ in range(count):\n            counter.increment()\n\n    for i in range(num_threads):\n        count = per_thread + (1 if i < n % num_threads else 0)\n        t = threading.Thread(target=worker, args=(count,))\n        threads.append(t)\n        t.start()\n\n    for t in threads:\n        t.join()\n\n    return counter.get()",
    "bug_description": "The Counter class is not thread-safe. The 'self.value += 1' operation is not atomic, causing race conditions when multiple threads increment simultaneously. A threading.Lock is needed.",
    "reference_solution": "import threading\n\nclass Counter:\n    \"\"\"A thread-safe counter.\"\"\"\n    def __init__(self):\n        self.value = 0\n        self._lock = threading.Lock()\n\n    def increment(self):\n        with self._lock:\n            self.value += 1\n\n    def get(self) -> int:\n        return self.value\n\n\ndef parallel_increment(n: int, num_threads: int = 4) -> int:\n    \"\"\"Increment a counter n times using multiple threads.\n    Returns the final counter value which should equal n.\"\"\"\n    counter = Counter()\n    threads = []\n    per_thread = n // num_threads\n\n    def worker(count):\n        for _ in range(count):\n            counter.increment()\n\n    for i in range(num_threads):\n        count = per_thread + (1 if i < n % num_threads else 0)\n        t = threading.Thread(target=worker, args=(count,))\n        threads.append(t)\n        t.start()\n\n    for t in threads:\n        t.join()\n\n    return counter.get()",
    "test_code": "import unittest\n\nclass TestParallelIncrement(unittest.TestCase):\n    def test_small(self):\n        self.assertEqual(parallel_increment(100, num_threads=4), 100)\n\n    def test_medium(self):\n        self.assertEqual(parallel_increment(10000, num_threads=4), 10000)\n\n    def test_large(self):\n        self.assertEqual(parallel_increment(100000, num_threads=8), 100000)\n\n    def test_single_thread(self):\n        self.assertEqual(parallel_increment(1000, num_threads=1), 1000)\n\n    def test_many_threads(self):\n        self.assertEqual(parallel_increment(10000, num_threads=10), 10000)",
    "tags": ["threading", "race-condition", "lock", "concurrency"],
    "time_limit_seconds": 10
  },
  {
    "id": "bf_012",
    "category": "bugfix",
    "difficulty": "hard",
    "title": "Generator exhaustion on second iteration",
    "buggy_code": "def multi_pass_stats(data) -> dict:\n    \"\"\"Compute statistics over data in multiple passes.\n    \n    Args:\n        data: an iterable of numbers\n    \n    Returns:\n        dict with 'sum', 'count', 'mean', and 'max' keys.\n    \"\"\"\n    total = sum(data)\n    count = sum(1 for _ in data)\n    mean = total / count if count > 0 else 0.0\n    maximum = max(data) if count > 0 else None\n    return {'sum': total, 'count': count, 'mean': mean, 'max': maximum}",
    "bug_description": "If 'data' is a generator or single-use iterator, it gets exhausted after the first sum() call. Subsequent iterations over 'data' yield nothing, causing count=0 and a division-by-zero or wrong results.",
    "reference_solution": "def multi_pass_stats(data) -> dict:\n    \"\"\"Compute statistics over data in multiple passes.\n    \n    Args:\n        data: an iterable of numbers\n    \n    Returns:\n        dict with 'sum', 'count', 'mean', and 'max' keys.\n    \"\"\"\n    data = list(data)\n    total = sum(data)\n    count = len(data)\n    mean = total / count if count > 0 else 0.0\n    maximum = max(data) if count > 0 else None\n    return {'sum': total, 'count': count, 'mean': mean, 'max': maximum}",
    "test_code": "import unittest\n\nclass TestMultiPassStats(unittest.TestCase):\n    def test_list(self):\n        result = multi_pass_stats([1, 2, 3, 4, 5])\n        self.assertEqual(result['sum'], 15)\n        self.assertEqual(result['count'], 5)\n        self.assertAlmostEqual(result['mean'], 3.0)\n        self.assertEqual(result['max'], 5)\n\n    def test_generator(self):\n        gen = (x for x in [10, 20, 30])\n        result = multi_pass_stats(gen)\n        self.assertEqual(result['sum'], 60)\n        self.assertEqual(result['count'], 3)\n        self.assertAlmostEqual(result['mean'], 20.0)\n        self.assertEqual(result['max'], 30)\n\n    def test_range(self):\n        result = multi_pass_stats(range(1, 6))\n        self.assertEqual(result['sum'], 15)\n        self.assertEqual(result['count'], 5)\n\n    def test_single(self):\n        result = multi_pass_stats([42])\n        self.assertEqual(result['sum'], 42)\n        self.assertEqual(result['count'], 1)\n        self.assertEqual(result['max'], 42)\n\n    def test_empty_generator(self):\n        result = multi_pass_stats(x for x in [])\n        self.assertEqual(result['sum'], 0)\n        self.assertEqual(result['count'], 0)\n        self.assertIsNone(result['max'])",
    "tags": ["generator", "iterator", "exhaustion", "multiple-iteration"],
    "time_limit_seconds": 5
  },
  {
    "id": "bf_013",
    "category": "bugfix",
    "difficulty": "hard",
    "title": "Decorator missing functools.wraps",
    "buggy_code": "import time\n\ndef timing_decorator(func):\n    \"\"\"Decorator that measures and stores execution time.\n    The decorated function should preserve the original function's\n    __name__ and __doc__ attributes.\"\"\"\n    def wrapper(*args, **kwargs):\n        start = time.time()\n        result = func(*args, **kwargs)\n        end = time.time()\n        wrapper.last_elapsed = end - start\n        return result\n    wrapper.last_elapsed = 0.0\n    return wrapper",
    "bug_description": "The decorator doesn't use functools.wraps(func), so the decorated function loses its original __name__ and __doc__ attributes. wrapper.__name__ will be 'wrapper' instead of the original function name.",
    "reference_solution": "import time\nimport functools\n\ndef timing_decorator(func):\n    \"\"\"Decorator that measures and stores execution time.\n    The decorated function should preserve the original function's\n    __name__ and __doc__ attributes.\"\"\"\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        start = time.time()\n        result = func(*args, **kwargs)\n        end = time.time()\n        wrapper.last_elapsed = end - start\n        return result\n    wrapper.last_elapsed = 0.0\n    return wrapper",
    "test_code": "import unittest\n\nclass TestTimingDecorator(unittest.TestCase):\n    def test_preserves_name(self):\n        @timing_decorator\n        def my_function():\n            \"\"\"My docstring.\"\"\"\n            return 42\n        self.assertEqual(my_function.__name__, 'my_function')\n\n    def test_preserves_doc(self):\n        @timing_decorator\n        def my_function():\n            \"\"\"My docstring.\"\"\"\n            return 42\n        self.assertEqual(my_function.__doc__, 'My docstring.')\n\n    def test_function_works(self):\n        @timing_decorator\n        def add(a, b):\n            \"\"\"Add two numbers.\"\"\"\n            return a + b\n        self.assertEqual(add(2, 3), 5)\n\n    def test_timing_recorded(self):\n        @timing_decorator\n        def slow_func():\n            \"\"\"Slow function.\"\"\"\n            total = 0\n            for i in range(100000):\n                total += i\n            return total\n        slow_func()\n        self.assertGreater(slow_func.last_elapsed, 0)",
    "tags": ["decorator", "functools.wraps", "metadata"],
    "time_limit_seconds": 5
  },
  {
    "id": "bf_014",
    "category": "bugfix",
    "difficulty": "hard",
    "title": "Diamond inheritance MRO issue",
    "buggy_code": "class Animal:\n    def __init__(self, name: str):\n        self.name = name\n        self.traits = []\n\n    def describe(self) -> str:\n        return f\"{self.name}: {', '.join(self.traits)}\"\n\n\nclass Swimmer(Animal):\n    def __init__(self, name: str):\n        Animal.__init__(self, name)\n        self.traits.append('can swim')\n\n\nclass Flyer(Animal):\n    def __init__(self, name: str):\n        Animal.__init__(self, name)\n        self.traits.append('can fly')\n\n\nclass Duck(Swimmer, Flyer):\n    \"\"\"A duck can both swim and fly.\n    Duck('Donald').describe() should return 'Donald: can swim, can fly'\"\"\"\n    def __init__(self, name: str):\n        Swimmer.__init__(self, name)\n        Flyer.__init__(self, name)",
    "bug_description": "Direct parent __init__ calls bypass cooperative MRO. When Duck.__init__ calls Flyer.__init__, it calls Animal.__init__ again which resets self.traits to [], losing the 'can swim' trait added by Swimmer. Should use super() for cooperative inheritance.",
    "reference_solution": "class Animal:\n    def __init__(self, name: str, **kwargs):\n        super().__init__(**kwargs)\n        self.name = name\n        self.traits = []\n\n    def describe(self) -> str:\n        return f\"{self.name}: {', '.join(self.traits)}\"\n\n\nclass Swimmer(Animal):\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.traits.append('can swim')\n\n\nclass Flyer(Animal):\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.traits.append('can fly')\n\n\nclass Duck(Swimmer, Flyer):\n    \"\"\"A duck can both swim and fly.\n    Duck(name='Donald').describe() should return 'Donald: can swim, can fly'\"\"\"\n    def __init__(self, name: str):\n        super().__init__(name=name)",
    "test_code": "import unittest\n\nclass TestDuck(unittest.TestCase):\n    def test_duck_traits(self):\n        d = Duck(name='Donald')\n        self.assertIn('can swim', d.traits)\n        self.assertIn('can fly', d.traits)\n\n    def test_duck_name(self):\n        d = Duck(name='Donald')\n        self.assertEqual(d.name, 'Donald')\n\n    def test_describe(self):\n        d = Duck(name='Daisy')\n        desc = d.describe()\n        self.assertIn('Daisy', desc)\n        self.assertIn('can swim', desc)\n        self.assertIn('can fly', desc)\n\n    def test_trait_count(self):\n        d = Duck(name='Donald')\n        self.assertEqual(len(d.traits), 2)",
    "tags": ["MRO", "diamond-inheritance", "super", "cooperative"],
    "time_limit_seconds": 5
  },
  {
    "id": "bf_015",
    "category": "bugfix",
    "difficulty": "hard",
    "title": "Async context manager misuse",
    "buggy_code": "import asyncio\n\nclass AsyncResource:\n    \"\"\"An async resource that must be properly opened and closed.\"\"\"\n    def __init__(self, name: str):\n        self.name = name\n        self.is_open = False\n        self.operations = []\n\n    async def open(self):\n        await asyncio.sleep(0)  # simulate async I/O\n        self.is_open = True\n\n    async def close(self):\n        await asyncio.sleep(0)\n        self.is_open = False\n\n    def __enter__(self):\n        self.open()\n        return self\n\n    def __exit__(self, *args):\n        self.close()\n\n    async def do_work(self, item: str):\n        if not self.is_open:\n            raise RuntimeError('Resource is not open')\n        await asyncio.sleep(0)\n        self.operations.append(item)\n\n\nasync def process_items(items: list[str]) -> list[str]:\n    \"\"\"Process items using AsyncResource. Returns list of processed items.\"\"\"\n    async with AsyncResource('processor') as res:\n        for item in items:\n            await res.do_work(item)\n        return res.operations.copy()",
    "bug_description": "AsyncResource implements __enter__/__exit__ (sync context manager) but is used with 'async with' which requires __aenter__/__aexit__. Also, the sync __enter__/__exit__ call coroutines without await.",
    "reference_solution": "import asyncio\n\nclass AsyncResource:\n    \"\"\"An async resource that must be properly opened and closed.\"\"\"\n    def __init__(self, name: str):\n        self.name = name\n        self.is_open = False\n        self.operations = []\n\n    async def open(self):\n        await asyncio.sleep(0)  # simulate async I/O\n        self.is_open = True\n\n    async def close(self):\n        await asyncio.sleep(0)\n        self.is_open = False\n\n    async def __aenter__(self):\n        await self.open()\n        return self\n\n    async def __aexit__(self, *args):\n        await self.close()\n\n    async def do_work(self, item: str):\n        if not self.is_open:\n            raise RuntimeError('Resource is not open')\n        await asyncio.sleep(0)\n        self.operations.append(item)\n\n\nasync def process_items(items: list[str]) -> list[str]:\n    \"\"\"Process items using AsyncResource. Returns list of processed items.\"\"\"\n    async with AsyncResource('processor') as res:\n        for item in items:\n            await res.do_work(item)\n        return res.operations.copy()",
    "test_code": "import asyncio\nimport unittest\n\nclass TestAsyncResource(unittest.TestCase):\n    def test_process_items(self):\n        result = asyncio.run(process_items(['a', 'b', 'c']))\n        self.assertEqual(result, ['a', 'b', 'c'])\n\n    def test_empty(self):\n        result = asyncio.run(process_items([]))\n        self.assertEqual(result, [])\n\n    def test_single(self):\n        result = asyncio.run(process_items(['hello']))\n        self.assertEqual(result, ['hello'])\n\n    def test_resource_closed_after(self):\n        async def check():\n            res = AsyncResource('test')\n            async with res:\n                pass\n            return res.is_open\n        self.assertFalse(asyncio.run(check()))",
    "tags": ["async", "context-manager", "aenter", "aexit"],
    "time_limit_seconds": 5
  }
]

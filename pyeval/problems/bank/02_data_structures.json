[
  {
    "id": "ds_001",
    "category": "data_structures",
    "difficulty": "easy",
    "title": "Two Sum",
    "prompt": "def two_sum(nums: list, target: int) -> list:\n    \"\"\"\n    Given a list of integers and a target integer, return the indices of the\n    two numbers that add up to the target.\n\n    Assumptions:\n    - Each input has exactly one solution.\n    - You may not use the same element twice.\n    - Return the indices in ascending order.\n\n    Examples:\n        two_sum([2, 7, 11, 15], 9) -> [0, 1]\n        two_sum([3, 2, 4], 6) -> [1, 2]\n        two_sum([3, 3], 6) -> [0, 1]\n    \"\"\"",
    "reference_solution": "def two_sum(nums: list, target: int) -> list:\n    \"\"\"\n    Given a list of integers and a target integer, return the indices of the\n    two numbers that add up to the target.\n\n    Assumptions:\n    - Each input has exactly one solution.\n    - You may not use the same element twice.\n    - Return the indices in ascending order.\n\n    Examples:\n        two_sum([2, 7, 11, 15], 9) -> [0, 1]\n        two_sum([3, 2, 4], 6) -> [1, 2]\n        two_sum([3, 3], 6) -> [0, 1]\n    \"\"\"\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return sorted([seen[complement], i])\n        seen[num] = i\n    return []",
    "test_code": "import unittest\n\nclass TestTwoSum(unittest.TestCase):\n    def test_basic(self):\n        self.assertEqual(two_sum([2, 7, 11, 15], 9), [0, 1])\n\n    def test_middle_elements(self):\n        self.assertEqual(two_sum([3, 2, 4], 6), [1, 2])\n\n    def test_duplicate_values(self):\n        self.assertEqual(two_sum([3, 3], 6), [0, 1])\n\n    def test_negative_numbers(self):\n        self.assertEqual(two_sum([-1, -2, -3, -4, -5], -8), [2, 4])\n\n    def test_mixed_signs(self):\n        self.assertEqual(two_sum([1, -1, 2, -2], 0), [0, 1])\n\n    def test_larger_list(self):\n        result = two_sum([1, 5, 3, 7, 8, 2], 10), \n        # 3 + 7 = 10 -> indices [2, 3]\n        self.assertEqual(two_sum([1, 5, 3, 7, 8, 2], 10), [2, 3])\n\n    def test_returns_list(self):\n        result = two_sum([2, 7, 11, 15], 9)\n        self.assertIsInstance(result, list)\n        self.assertEqual(len(result), 2)\n\n    def test_ascending_order(self):\n        result = two_sum([15, 11, 7, 2], 9)\n        self.assertEqual(result[0], 2)\n        self.assertEqual(result[1], 3)\n        self.assertLess(result[0], result[1])",
    "tags": ["hash-map", "array", "search"],
    "time_limit_seconds": 5
  },
  {
    "id": "ds_002",
    "category": "data_structures",
    "difficulty": "easy",
    "title": "Reverse Linked List",
    "prompt": "def reverse_linked_list(values: list) -> list:\n    \"\"\"\n    Given a list of values representing a singly linked list (head to tail),\n    return a new list with the values in reversed order.\n\n    This simulates reversing a linked list using list representation.\n    You should implement the reversal logic iteratively, simulating\n    pointer manipulation (not just using built-in reverse).\n\n    Examples:\n        reverse_linked_list([1, 2, 3, 4, 5]) -> [5, 4, 3, 2, 1]\n        reverse_linked_list([1]) -> [1]\n        reverse_linked_list([]) -> []\n    \"\"\"",
    "reference_solution": "def reverse_linked_list(values: list) -> list:\n    \"\"\"\n    Given a list of values representing a singly linked list (head to tail),\n    return a new list with the values in reversed order.\n\n    This simulates reversing a linked list using list representation.\n    You should implement the reversal logic iteratively, simulating\n    pointer manipulation (not just using built-in reverse).\n\n    Examples:\n        reverse_linked_list([1, 2, 3, 4, 5]) -> [5, 4, 3, 2, 1]\n        reverse_linked_list([1]) -> [1]\n        reverse_linked_list([]) -> []\n    \"\"\"\n    # Simulate linked list reversal with node-like dicts\n    if not values:\n        return []\n\n    # Build linked list\n    nodes = []\n    for v in values:\n        nodes.append({'val': v, 'next': None})\n    for i in range(len(nodes) - 1):\n        nodes[i]['next'] = nodes[i + 1]\n\n    # Reverse using three-pointer technique\n    prev = None\n    current = nodes[0]\n    while current is not None:\n        next_node = current['next']\n        current['next'] = prev\n        prev = current\n        current = next_node\n\n    # Collect values from reversed list\n    result = []\n    node = prev\n    while node is not None:\n        result.append(node['val'])\n        node = node['next']\n    return result",
    "test_code": "import unittest\n\nclass TestReverseLinkedList(unittest.TestCase):\n    def test_basic(self):\n        self.assertEqual(reverse_linked_list([1, 2, 3, 4, 5]), [5, 4, 3, 2, 1])\n\n    def test_single(self):\n        self.assertEqual(reverse_linked_list([1]), [1])\n\n    def test_empty(self):\n        self.assertEqual(reverse_linked_list([]), [])\n\n    def test_two_elements(self):\n        self.assertEqual(reverse_linked_list([1, 2]), [2, 1])\n\n    def test_strings(self):\n        self.assertEqual(reverse_linked_list(['a', 'b', 'c']), ['c', 'b', 'a'])\n\n    def test_duplicates(self):\n        self.assertEqual(reverse_linked_list([1, 1, 2, 2]), [2, 2, 1, 1])\n\n    def test_preserves_original(self):\n        original = [1, 2, 3]\n        result = reverse_linked_list(original)\n        self.assertEqual(original, [1, 2, 3])\n        self.assertEqual(result, [3, 2, 1])\n\n    def test_large_list(self):\n        values = list(range(100))\n        expected = list(range(99, -1, -1))\n        self.assertEqual(reverse_linked_list(values), expected)",
    "tags": ["linked-list", "pointers", "iterative"],
    "time_limit_seconds": 5
  },
  {
    "id": "ds_003",
    "category": "data_structures",
    "difficulty": "medium",
    "title": "LRU Cache",
    "prompt": "from collections import OrderedDict\n\nclass LRUCache:\n    \"\"\"\n    Implement a Least Recently Used (LRU) Cache.\n\n    The cache has a fixed capacity. When the cache is full and a new key\n    is inserted, the least recently used key is evicted.\n\n    Both get and put operations count as \"using\" a key.\n\n    Methods:\n        __init__(capacity: int) - Initialize the cache with positive capacity.\n        get(key: int) -> int - Return the value if key exists, otherwise -1.\n        put(key: int, value: int) -> None - Insert or update the key-value pair.\n\n    Example:\n        cache = LRUCache(2)\n        cache.put(1, 1)\n        cache.put(2, 2)\n        cache.get(1)       # returns 1\n        cache.put(3, 3)    # evicts key 2\n        cache.get(2)       # returns -1 (not found)\n        cache.get(3)       # returns 3\n    \"\"\"",
    "reference_solution": "from collections import OrderedDict\n\nclass LRUCache:\n    \"\"\"\n    Implement a Least Recently Used (LRU) Cache.\n\n    The cache has a fixed capacity. When the cache is full and a new key\n    is inserted, the least recently used key is evicted.\n\n    Both get and put operations count as \"using\" a key.\n\n    Methods:\n        __init__(capacity: int) - Initialize the cache with positive capacity.\n        get(key: int) -> int - Return the value if key exists, otherwise -1.\n        put(key: int, value: int) -> None - Insert or update the key-value pair.\n\n    Example:\n        cache = LRUCache(2)\n        cache.put(1, 1)\n        cache.put(2, 2)\n        cache.get(1)       # returns 1\n        cache.put(3, 3)    # evicts key 2\n        cache.get(2)       # returns -1 (not found)\n        cache.get(3)       # returns 3\n    \"\"\"\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        self.cache.move_to_end(key)\n        return self.cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.cache.move_to_end(key)\n        self.cache[key] = value\n        if len(self.cache) > self.capacity:\n            self.cache.popitem(last=False)",
    "test_code": "import unittest\nfrom collections import OrderedDict\n\nclass TestLRUCache(unittest.TestCase):\n    def test_basic_operations(self):\n        cache = LRUCache(2)\n        cache.put(1, 1)\n        cache.put(2, 2)\n        self.assertEqual(cache.get(1), 1)\n        cache.put(3, 3)\n        self.assertEqual(cache.get(2), -1)\n        cache.put(4, 4)\n        self.assertEqual(cache.get(1), -1)\n        self.assertEqual(cache.get(3), 3)\n        self.assertEqual(cache.get(4), 4)\n\n    def test_get_missing_key(self):\n        cache = LRUCache(2)\n        self.assertEqual(cache.get(1), -1)\n\n    def test_update_existing_key(self):\n        cache = LRUCache(2)\n        cache.put(1, 1)\n        cache.put(1, 10)\n        self.assertEqual(cache.get(1), 10)\n\n    def test_capacity_one(self):\n        cache = LRUCache(1)\n        cache.put(1, 1)\n        cache.put(2, 2)\n        self.assertEqual(cache.get(1), -1)\n        self.assertEqual(cache.get(2), 2)\n\n    def test_get_refreshes_usage(self):\n        cache = LRUCache(2)\n        cache.put(1, 1)\n        cache.put(2, 2)\n        cache.get(1)  # refreshes key 1\n        cache.put(3, 3)  # should evict key 2, not key 1\n        self.assertEqual(cache.get(1), 1)\n        self.assertEqual(cache.get(2), -1)\n        self.assertEqual(cache.get(3), 3)\n\n    def test_put_refreshes_usage(self):\n        cache = LRUCache(2)\n        cache.put(1, 1)\n        cache.put(2, 2)\n        cache.put(1, 10)  # refreshes key 1\n        cache.put(3, 3)  # should evict key 2\n        self.assertEqual(cache.get(1), 10)\n        self.assertEqual(cache.get(2), -1)\n\n    def test_larger_capacity(self):\n        cache = LRUCache(3)\n        cache.put(1, 1)\n        cache.put(2, 2)\n        cache.put(3, 3)\n        cache.put(4, 4)  # evicts 1\n        self.assertEqual(cache.get(1), -1)\n        self.assertEqual(cache.get(2), 2)\n        self.assertEqual(cache.get(3), 3)\n        self.assertEqual(cache.get(4), 4)",
    "tags": ["hash-map", "ordered-dict", "cache", "design"],
    "time_limit_seconds": 5
  },
  {
    "id": "ds_004",
    "category": "data_structures",
    "difficulty": "medium",
    "title": "Group Anagrams",
    "prompt": "def group_anagrams(strs: list) -> list:\n    \"\"\"\n    Given a list of strings, group the anagrams together.\n    Return a list of groups, where each group is a sorted list of anagram strings.\n    The groups themselves should be sorted by their first element.\n\n    Two strings are anagrams if they contain the same characters with the\n    same frequencies, regardless of order.\n\n    Examples:\n        group_anagrams([\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"])\n        -> [[\"ate\", \"eat\", \"tea\"], [\"bat\"], [\"nat\", \"tan\"]]\n\n        group_anagrams([\"\"]) -> [[\"\"]]\n        group_anagrams([\"a\"]) -> [[\"a\"]]\n    \"\"\"",
    "reference_solution": "def group_anagrams(strs: list) -> list:\n    \"\"\"\n    Given a list of strings, group the anagrams together.\n    Return a list of groups, where each group is a sorted list of anagram strings.\n    The groups themselves should be sorted by their first element.\n\n    Two strings are anagrams if they contain the same characters with the\n    same frequencies, regardless of order.\n\n    Examples:\n        group_anagrams([\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"])\n        -> [[\"ate\", \"eat\", \"tea\"], [\"bat\"], [\"nat\", \"tan\"]]\n\n        group_anagrams([\"\"]) -> [[\"\"]]\n        group_anagrams([\"a\"]) -> [[\"a\"]]\n    \"\"\"\n    groups = {}\n    for s in strs:\n        key = tuple(sorted(s))\n        if key not in groups:\n            groups[key] = []\n        groups[key].append(s)\n\n    result = []\n    for group in groups.values():\n        result.append(sorted(group))\n    result.sort(key=lambda g: g[0])\n    return result",
    "test_code": "import unittest\n\nclass TestGroupAnagrams(unittest.TestCase):\n    def test_basic(self):\n        result = group_anagrams([\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"])\n        self.assertEqual(result, [[\"ate\", \"eat\", \"tea\"], [\"bat\"], [\"nat\", \"tan\"]])\n\n    def test_empty_string(self):\n        self.assertEqual(group_anagrams([\"\"]), [[\"\"]])\n\n    def test_single_string(self):\n        self.assertEqual(group_anagrams([\"a\"]), [[\"a\"]])\n\n    def test_no_anagrams(self):\n        result = group_anagrams([\"abc\", \"def\", \"ghi\"])\n        self.assertEqual(result, [[\"abc\"], [\"def\"], [\"ghi\"]])\n\n    def test_all_anagrams(self):\n        result = group_anagrams([\"abc\", \"bca\", \"cab\"])\n        self.assertEqual(result, [[\"abc\", \"bca\", \"cab\"]])\n\n    def test_groups_sorted_internally(self):\n        result = group_anagrams([\"tea\", \"eat\", \"ate\"])\n        self.assertEqual(result, [[\"ate\", \"eat\", \"tea\"]])\n\n    def test_groups_sorted_by_first_element(self):\n        result = group_anagrams([\"zzz\", \"aaa\"])\n        self.assertEqual(result[0], [\"aaa\"])\n        self.assertEqual(result[1], [\"zzz\"])\n\n    def test_duplicate_strings(self):\n        result = group_anagrams([\"ab\", \"ba\", \"ab\"])\n        self.assertEqual(result, [[\"ab\", \"ab\", \"ba\"]])\n\n    def test_different_lengths(self):\n        result = group_anagrams([\"a\", \"ab\", \"ba\"])\n        self.assertEqual(len(result), 2)",
    "tags": ["hash-map", "sorting", "string", "grouping"],
    "time_limit_seconds": 5
  },
  {
    "id": "ds_005",
    "category": "data_structures",
    "difficulty": "hard",
    "title": "Merge K Sorted Lists",
    "prompt": "import heapq\n\ndef merge_k_sorted(lists: list) -> list:\n    \"\"\"\n    Merge k sorted lists into one sorted list.\n\n    Use a min-heap for efficient merging. Each input list is sorted\n    in ascending order. Return a single sorted list containing all elements.\n\n    Examples:\n        merge_k_sorted([[1, 4, 5], [1, 3, 4], [2, 6]])\n        -> [1, 1, 2, 3, 4, 4, 5, 6]\n\n        merge_k_sorted([]) -> []\n        merge_k_sorted([[], []]) -> []\n        merge_k_sorted([[1]]) -> [1]\n    \"\"\"",
    "reference_solution": "import heapq\n\ndef merge_k_sorted(lists: list) -> list:\n    \"\"\"\n    Merge k sorted lists into one sorted list.\n\n    Use a min-heap for efficient merging. Each input list is sorted\n    in ascending order. Return a single sorted list containing all elements.\n\n    Examples:\n        merge_k_sorted([[1, 4, 5], [1, 3, 4], [2, 6]])\n        -> [1, 1, 2, 3, 4, 4, 5, 6]\n\n        merge_k_sorted([]) -> []\n        merge_k_sorted([[], []]) -> []\n        merge_k_sorted([[1]]) -> [1]\n    \"\"\"\n    heap = []\n    for i, lst in enumerate(lists):\n        if lst:\n            heapq.heappush(heap, (lst[0], i, 0))\n\n    result = []\n    while heap:\n        val, list_idx, elem_idx = heapq.heappop(heap)\n        result.append(val)\n        if elem_idx + 1 < len(lists[list_idx]):\n            next_val = lists[list_idx][elem_idx + 1]\n            heapq.heappush(heap, (next_val, list_idx, elem_idx + 1))\n\n    return result",
    "test_code": "import unittest\nimport heapq\n\nclass TestMergeKSorted(unittest.TestCase):\n    def test_basic(self):\n        result = merge_k_sorted([[1, 4, 5], [1, 3, 4], [2, 6]])\n        self.assertEqual(result, [1, 1, 2, 3, 4, 4, 5, 6])\n\n    def test_empty_input(self):\n        self.assertEqual(merge_k_sorted([]), [])\n\n    def test_empty_lists(self):\n        self.assertEqual(merge_k_sorted([[], []]), [])\n\n    def test_single_list(self):\n        self.assertEqual(merge_k_sorted([[1, 2, 3]]), [1, 2, 3])\n\n    def test_single_elements(self):\n        self.assertEqual(merge_k_sorted([[1], [2], [3]]), [1, 2, 3])\n\n    def test_one_empty_list(self):\n        self.assertEqual(merge_k_sorted([[1, 3], [], [2, 4]]), [1, 2, 3, 4])\n\n    def test_duplicates(self):\n        result = merge_k_sorted([[1, 1], [1, 1]])\n        self.assertEqual(result, [1, 1, 1, 1])\n\n    def test_negative_numbers(self):\n        result = merge_k_sorted([[-5, -1, 3], [-3, 0, 2]])\n        self.assertEqual(result, [-5, -3, -1, 0, 2, 3])\n\n    def test_result_is_sorted(self):\n        result = merge_k_sorted([[10, 20], [5, 15], [1, 25]])\n        for i in range(len(result) - 1):\n            self.assertLessEqual(result[i], result[i + 1])\n\n    def test_total_count(self):\n        lists = [[1, 2, 3], [4, 5], [6]]\n        result = merge_k_sorted(lists)\n        self.assertEqual(len(result), 6)\n\n    def test_large_k(self):\n        lists = [[i] for i in range(100, 0, -1)]\n        result = merge_k_sorted(lists)\n        self.assertEqual(result, list(range(1, 101)))",
    "tags": ["heap", "merge", "sorting", "priority-queue"],
    "time_limit_seconds": 10
  }
]

[
  {
    "id": "exc_003",
    "category": "exceptions",
    "difficulty": "hard",
    "title": "Custom Exception Hierarchy and Schema Validation",
    "passed": true,
    "error": null,
    "generated_code": "import re\n\n\nclass ValidationError(Exception):\n    \"\"\"Base exception for validation errors.\n\n    Constructor:\n        __init__(self, field: str, message: str)\n            Store field and message as instance attributes.\n            Call super().__init__() with a formatted string.\n\n    Instance Attributes:\n        field (str): The name of the field that failed validation.\n        message (str): A human-readable error message.\n    \"\"\"\n\n    def __init__(self, field: str, message: str):\n        self.field = field\n        self.message = message\n        super().__init__(f\"Field '{field}': {message}\")\n\n\nclass TypeValidationError(ValidationError):\n    \"\"\"Raised when a field has the wrong type.\n\n    Constructor:\n        __init__(self, field: str, expected_type: type, actual_type: type)\n            Store expected_type and actual_type as instance attributes.\n            Call super().__init__(field, <message>).\n\n    Instance Attributes (in addition to inherited field, message):\n        expected_type (type): The expected type.\n        actual_type (type): The actual type received.\n    \"\"\"\n\n    def __init__(self, field: str, expected_type: type, actual_type: type):\n        self.expected_type = expected_type\n        self.actual_type = actual_type\n        message = f\"Expected type {expected_type.__name__}, got {actual_type.__name__}\"\n        super().__init__(field, message)\n\n\nclass RangeValidationError(ValidationError):\n    \"\"\"Raised when a numeric field is out of range.\n\n    Constructor:\n        __init__(self, field: str, value, min_value=None, max_value=None)\n            Store value, min_value, max_value as instance attributes.\n            Call super().__init__(field, <message>).\n\n    Instance Attributes (in addition to inherited field, message):\n        value: The actual value.\n        min_value: The minimum allowed value (or None).\n        max_value: The maximum allowed value (or None).\n    \"\"\"\n\n    def __init__(self, field: str, value, min_value=None, max_value=None):\n        self.value = value\n        self.min_value = min_value\n        self.max_value = max_value\n        if min_value is not None and max_value is not None:\n            message = f\"Value {value} is not in range [{min_value}, {max_value}]\"\n        elif min_value is not None:\n            message = f\"Value {value} is less than minimum {min_value}\"\n        else:\n            message = f\"Value {value} is greater than maximum {max_value}\"\n        super().__init__(field, message)\n\n\nclass PatternValidationError(ValidationError):\n    \"\"\"Raised when a string field does not match a regex pattern.\n\n    Constructor:\n        __init__(self, field: str, pattern: str, value: str)\n            Store pattern and value as instance attributes.\n            Call super().__init__(field, <message>).\n\n    Instance Attributes (in addition to inherited field, message):\n        pattern (str): The regex pattern that was expected.\n        value (str): The actual string value.\n    \"\"\"\n\n    def __init__(self, field: str, pattern: str, value: str):\n        self.pattern = pattern\n        self.value = value\n        message = f\"Value '{value}' does not match pattern '{pattern}'\"\n        super().__init__(field, message)\n\n\ndef validate_data(schema, data):\n    \"\"\"Validate data against a schema, raising appropriate exceptions.\n\n    Args:\n        schema (dict): A dict mapping field names to rule dicts. Each rule dict\n            can have:\n            - 'type' (type): required type (e.g., int, str, float)\n            - 'min' (number): minimum value (only for numeric types)\n            - 'max' (number): maximum value (only for numeric types)\n            - 'pattern' (str): regex pattern the string must match fully\n            - 'required' (bool): if True, field must exist in data (default True)\n\n        data (dict): The data to validate.\n\n    Raises:\n        TypeValidationError: if a field has the wrong type.\n        RangeValidationError: if a numeric field is out of range.\n        PatternValidationError: if a string field doesn't match the pattern.\n        ValidationError: if a required field is missing.\n\n    Returns:\n        True if all validations pass.\n\n    Note:\n        Validate fields in the order they appear in the schema.\n        Raise on the first validation failure (do not collect all errors).\n    \"\"\"\n    for field, rules in schema.items():\n        required = rules.get('required', True)\n        \n        # Check if field exists\n        if field not in data:\n            if required:\n                raise ValidationError(field, \"Field is required but missing\")\n            continue\n        \n        value = data[field]\n        \n        # Type validation\n        if 'type' in rules:\n            expected_type = rules['type']\n            if not isinstance(value, expected_type):\n                actual_type = type(value)\n                raise TypeValidationError(field, expected_type, actual_type)\n        \n        # Range validation (only for numeric types)\n        if 'min' in rules or 'max' in rules:\n            if isinstance(value, (int, float)) and not isinstance(value, bool):\n                min_val = rules.get('min')\n                max_val = rules.get('max')\n                \n                if min_val is not None and value < min_val:\n                    raise RangeValidationError(field, value, min_value=min_val, max_value=max_val)\n                if max_val is not None and value > max_val:\n                    raise RangeValidationError(field, value, min_value=min_val, max_value=max_val)\n        \n        # Pattern validation (only for strings)\n        if 'pattern' in rules:\n            if isinstance(value, str):\n                pattern = rules['pattern']\n                if not re.fullmatch(pattern, value):\n                    raise PatternValidationError(field, pattern, value)\n    \n    return True",
    "stdout": "",
    "stderr": "...........................\n----------------------------------------------------------------------\nRan 27 tests in 0.001s\n\nOK\n"
  },
  {
    "id": "oop_003",
    "category": "oop",
    "difficulty": "medium",
    "title": "BankAccount with Transaction History",
    "passed": true,
    "error": null,
    "generated_code": "class BankAccount:\n    \"\"\"A bank account with deposit, withdraw, transfer, and transaction history.\n\n    Constructor:\n        __init__(self, owner: str, initial_balance: float = 0.0)\n            Store owner as a public attribute (self.owner).\n            Store balance internally; expose via read-only property.\n            Initialize an empty transaction history list.\n            Raise ValueError if initial_balance < 0.\n            Do NOT record the initial balance as a transaction.\n\n    Public Attributes:\n        owner (str): The name of the account owner (directly accessible).\n\n    Properties:\n        balance (float): The current balance (read-only property).\n\n    Methods:\n        deposit(amount) -> None:\n            Add amount to balance. Raise ValueError if amount <= 0.\n            Record transaction as ('deposit', amount) in history.\n\n        withdraw(amount) -> None:\n            Subtract amount from balance.\n            Raise ValueError if amount <= 0.\n            Raise ValueError if insufficient funds.\n            Record transaction as ('withdraw', amount) in history.\n\n        transfer_to(other_account, amount) -> None:\n            Withdraw amount from this account and deposit into other_account.\n            Raise ValueError if amount <= 0.\n            Raise ValueError if insufficient funds.\n            Record transaction as ('transfer_out', amount) in this account's history.\n            Record transaction as ('transfer_in', amount) in other account's history.\n\n        get_history() -> list:\n            Return a copy of all transaction tuples in chronological order.\n    \"\"\"\n\n    def __init__(self, owner: str, initial_balance: float = 0.0):\n        if initial_balance < 0:\n            raise ValueError(\"Initial balance cannot be negative.\")\n        self.owner = owner\n        self._balance = initial_balance\n        self._history = []\n\n    @property\n    def balance(self) -> float:\n        return self._balance\n\n    def deposit(self, amount: float) -> None:\n        if amount <= 0:\n            raise ValueError(\"Deposit amount must be positive.\")\n        self._balance += amount\n        self._history.append(('deposit', amount))\n\n    def withdraw(self, amount: float) -> None:\n        if amount <= 0:\n            raise ValueError(\"Withdrawal amount must be positive.\")\n        if amount > self._balance:\n            raise ValueError(\"Insufficient funds.\")\n        self._balance -= amount\n        self._history.append(('withdraw', amount))\n\n    def transfer_to(self, other_account: 'BankAccount', amount: float) -> None:\n        if amount <= 0:\n            raise ValueError(\"Transfer amount must be positive.\")\n        if amount > self._balance:\n            raise ValueError(\"Insufficient funds.\")\n        \n        self._balance -= amount\n        self._history.append(('transfer_out', amount))\n        \n        other_account._balance += amount\n        other_account._history.append(('transfer_in', amount))\n\n    def get_history(self) -> list:\n        return list(self._history)",
    "stdout": "",
    "stderr": ".................\n----------------------------------------------------------------------\nRan 17 tests in 0.001s\n\nOK\n"
  },
  {
    "id": "oop_005",
    "category": "oop",
    "difficulty": "hard",
    "title": "ValidatedField Descriptor",
    "passed": true,
    "error": null,
    "generated_code": "class ValidatedField:\n    \"\"\"A descriptor that validates field values on assignment.\n\n    Constructor:\n        __init__(self, field_type, *, min_value=None, max_value=None, max_length=None)\n\n    Descriptor Protocol:\n        __set_name__(self, owner, name):\n            Store the field name. Use a private storage attribute like\n            '_validated_' + name on the instance to avoid conflicts.\n\n        __get__(self, obj, objtype=None):\n            If obj is None (class-level access), return the descriptor itself.\n            Otherwise return the stored value.\n            Raise AttributeError if the value has not been set yet.\n\n        __set__(self, obj, value):\n            Validate the value before storing:\n            1. Check isinstance(value, field_type). Raise TypeError if not.\n            2. If field_type is int or float and min_value is set, raise ValueError\n               if value < min_value.\n            3. If field_type is int or float and max_value is set, raise ValueError\n               if value > max_value.\n            4. If field_type is str and max_length is set, raise ValueError\n               if len(value) > max_length.\n    \"\"\"\n\n    def __init__(self, field_type, *, min_value=None, max_value=None, max_length=None):\n        self.field_type = field_type\n        self.min_value = min_value\n        self.max_value = max_value\n        self.max_length = max_length\n        self.name = None\n\n    def __set_name__(self, owner, name):\n        self.name = name\n\n    def __get__(self, obj, objtype=None):\n        if obj is None:\n            return self\n        attr_name = f'_validated_{self.name}'\n        try:\n            return getattr(obj, attr_name)\n        except AttributeError:\n            raise AttributeError(f\"'{objtype.__name__}' object has no attribute '{self.name}'\")\n\n    def __set__(self, obj, value):\n        # Validation 1: Type check\n        if not isinstance(value, self.field_type):\n            raise TypeError(f\"Expected {self.field_type.__name__}, got {type(value).__name__}\")\n\n        # Validation 2 & 3: Numeric range checks\n        if self.field_type in (int, float):\n            if self.min_value is not None and value < self.min_value:\n                raise ValueError(f\"Value {value} is less than minimum allowed value {self.min_value}\")\n            if self.max_value is not None and value > self.max_value:\n                raise ValueError(f\"Value {value} is greater than maximum allowed value {self.max_value}\")\n\n        # Validation 4: String length check\n        if self.field_type is str and self.max_length is not None:\n            if len(value) > self.max_length:\n                raise ValueError(f\"String length {len(value)} exceeds maximum allowed length {self.max_length}\")\n\n        # Store the validated value\n        attr_name = f'_validated_{self.name}'\n        setattr(obj, attr_name, value)\n\n\nclass Person:\n    \"\"\"A class using ValidatedField descriptors.\n\n    Class-level descriptor fields:\n        name = ValidatedField(str, max_length=50)\n        age = ValidatedField(int, min_value=0, max_value=200)\n        email = ValidatedField(str, max_length=100)\n\n    Constructor:\n        __init__(self, name: str, age: int, email: str)\n            Assign all three arguments to self (triggering descriptor validation).\n    \"\"\"\n\n    name = ValidatedField(str, max_length=50)\n    age = ValidatedField(int, min_value=0, max_value=200)\n    email = ValidatedField(str, max_length=100)\n\n    def __init__(self, name: str, age: int, email: str):\n        self.name = name\n        self.age = age\n        self.email = email",
    "stdout": "",
    "stderr": "..................\n----------------------------------------------------------------------\nRan 18 tests in 0.001s\n\nOK\n"
  }
]
[
  {
    "id": "fn_001",
    "category": "functional",
    "difficulty": "easy",
    "title": "Apply Pipeline",
    "prompt": "def apply_pipeline(value, functions: list):\n    \"\"\"\n    Given an initial value and a list of single-argument functions,\n    apply each function in sequence (left to right) to the value,\n    passing the result of each function as input to the next.\n    Return the final result.\n\n    If the functions list is empty, return the original value.\n\n    Examples:\n        apply_pipeline(5, [lambda x: x + 1, lambda x: x * 2]) -> 12\n        apply_pipeline(\"hello\", [str.upper, lambda s: s + \"!\"]) -> \"HELLO!\"\n        apply_pipeline(10, []) -> 10\n        apply_pipeline(-3, [abs, lambda x: x ** 2]) -> 9\n    \"\"\"",
    "reference_solution": "def apply_pipeline(value, functions: list):\n    \"\"\"\n    Given an initial value and a list of single-argument functions,\n    apply each function in sequence (left to right) to the value,\n    passing the result of each function as input to the next.\n    Return the final result.\n\n    If the functions list is empty, return the original value.\n\n    Examples:\n        apply_pipeline(5, [lambda x: x + 1, lambda x: x * 2]) -> 12\n        apply_pipeline(\"hello\", [str.upper, lambda s: s + \"!\"]) -> \"HELLO!\"\n        apply_pipeline(10, []) -> 10\n        apply_pipeline(-3, [abs, lambda x: x ** 2]) -> 9\n    \"\"\"\n    result = value\n    for func in functions:\n        result = func(result)\n    return result",
    "test_code": "import unittest\n\nclass TestApplyPipeline(unittest.TestCase):\n    def test_basic_arithmetic(self):\n        result = apply_pipeline(5, [lambda x: x + 1, lambda x: x * 2])\n        self.assertEqual(result, 12)\n\n    def test_empty_pipeline(self):\n        self.assertEqual(apply_pipeline(10, []), 10)\n\n    def test_single_function(self):\n        self.assertEqual(apply_pipeline(4, [lambda x: x ** 2]), 16)\n\n    def test_string_functions(self):\n        result = apply_pipeline(\"hello\", [str.upper, lambda s: s + \"!\"])\n        self.assertEqual(result, \"HELLO!\")\n\n    def test_type_changing(self):\n        result = apply_pipeline(\"42\", [int, lambda x: x * 2, str])\n        self.assertEqual(result, \"84\")\n\n    def test_abs_and_square(self):\n        result = apply_pipeline(-3, [abs, lambda x: x ** 2])\n        self.assertEqual(result, 9)\n\n    def test_three_functions(self):\n        result = apply_pipeline(2, [lambda x: x + 3, lambda x: x * 2, lambda x: x - 1])\n        self.assertEqual(result, 9)\n\n    def test_identity_functions(self):\n        result = apply_pipeline(7, [lambda x: x, lambda x: x, lambda x: x])\n        self.assertEqual(result, 7)\n\n    def test_list_operations(self):\n        result = apply_pipeline([3, 1, 2], [sorted, lambda lst: lst[-1]])\n        self.assertEqual(result, 3)\n\n    def test_none_value(self):\n        result = apply_pipeline(None, [lambda x: x is None])\n        self.assertEqual(result, True)",
    "tags": ["functional", "pipeline", "higher-order-functions", "composition"],
    "time_limit_seconds": 5
  },
  {
    "id": "fn_002",
    "category": "functional",
    "difficulty": "medium",
    "title": "Memoize Decorator",
    "prompt": "def memoize(func):\n    \"\"\"\n    Implement a memoize decorator that caches the results of function calls.\n    If the function is called again with the same positional arguments,\n    return the cached result instead of recomputing.\n\n    Assume all arguments are hashable (can be used as dict keys via tuple).\n    Only positional arguments need to be supported (no kwargs).\n\n    The decorated function should also have a .cache attribute that is\n    the dictionary used for caching (mapping argument tuples to results).\n\n    Examples:\n        @memoize\n        def add(a, b):\n            return a + b\n\n        add(1, 2)  # computes and caches\n        add(1, 2)  # returns cached result\n        add.cache  # {(1, 2): 3}\n    \"\"\"",
    "reference_solution": "def memoize(func):\n    \"\"\"\n    Implement a memoize decorator that caches the results of function calls.\n    If the function is called again with the same positional arguments,\n    return the cached result instead of recomputing.\n\n    Assume all arguments are hashable (can be used as dict keys via tuple).\n    Only positional arguments need to be supported (no kwargs).\n\n    The decorated function should also have a .cache attribute that is\n    the dictionary used for caching (mapping argument tuples to results).\n\n    Examples:\n        @memoize\n        def add(a, b):\n            return a + b\n\n        add(1, 2)  # computes and caches\n        add(1, 2)  # returns cached result\n        add.cache  # {(1, 2): 3}\n    \"\"\"\n    cache = {}\n\n    def wrapper(*args):\n        if args not in cache:\n            cache[args] = func(*args)\n        return cache[args]\n\n    wrapper.cache = cache\n    return wrapper",
    "test_code": "import unittest\n\nclass TestMemoize(unittest.TestCase):\n    def test_basic_caching(self):\n        call_count = 0\n        @memoize\n        def add(a, b):\n            nonlocal call_count\n            call_count += 1\n            return a + b\n        self.assertEqual(add(1, 2), 3)\n        self.assertEqual(add(1, 2), 3)\n        self.assertEqual(call_count, 1)\n\n    def test_different_args(self):\n        @memoize\n        def multiply(a, b):\n            return a * b\n        self.assertEqual(multiply(2, 3), 6)\n        self.assertEqual(multiply(4, 5), 20)\n        self.assertEqual(multiply(2, 3), 6)\n\n    def test_cache_attribute(self):\n        @memoize\n        def square(x):\n            return x * x\n        square(3)\n        square(4)\n        self.assertIn((3,), square.cache)\n        self.assertIn((4,), square.cache)\n        self.assertEqual(square.cache[(3,)], 9)\n        self.assertEqual(square.cache[(4,)], 16)\n\n    def test_no_args(self):\n        call_count = 0\n        @memoize\n        def get_value():\n            nonlocal call_count\n            call_count += 1\n            return 42\n        self.assertEqual(get_value(), 42)\n        self.assertEqual(get_value(), 42)\n        self.assertEqual(call_count, 1)\n\n    def test_string_args(self):\n        @memoize\n        def greet(name):\n            return f\"Hello, {name}!\"\n        self.assertEqual(greet(\"Alice\"), \"Hello, Alice!\")\n        self.assertEqual(greet(\"Bob\"), \"Hello, Bob!\")\n        self.assertEqual(greet(\"Alice\"), \"Hello, Alice!\")\n\n    def test_none_result_cached(self):\n        call_count = 0\n        @memoize\n        def returns_none(x):\n            nonlocal call_count\n            call_count += 1\n            return None\n        self.assertIsNone(returns_none(1))\n        self.assertIsNone(returns_none(1))\n        self.assertEqual(call_count, 1)\n\n    def test_recursive_fibonacci(self):\n        @memoize\n        def fib(n):\n            if n <= 1:\n                return n\n            return fib(n - 1) + fib(n - 2)\n        self.assertEqual(fib(10), 55)\n        self.assertEqual(fib(20), 6765)\n\n    def test_cache_grows(self):\n        @memoize\n        def identity(x):\n            return x\n        for i in range(10):\n            identity(i)\n        self.assertEqual(len(identity.cache), 10)",
    "tags": ["functional", "decorator", "memoization", "caching", "higher-order-functions"],
    "time_limit_seconds": 5
  },
  {
    "id": "fn_003",
    "category": "functional",
    "difficulty": "medium",
    "title": "Group By",
    "prompt": "def group_by(items: list, key_func) -> dict:\n    \"\"\"\n    Group elements of a list by the result of applying key_func to each element.\n    Return a dictionary where keys are the results of key_func and values are\n    lists of items that produced that key, in their original order.\n\n    Examples:\n        group_by([1, 2, 3, 4, 5, 6], lambda x: x % 2 == 0)\n        # -> {False: [1, 3, 5], True: [2, 4, 6]}\n\n        group_by([\"apple\", \"banana\", \"avocado\", \"blueberry\"], lambda s: s[0])\n        # -> {\"a\": [\"apple\", \"avocado\"], \"b\": [\"banana\", \"blueberry\"]}\n\n        group_by([], lambda x: x)\n        # -> {}\n\n        group_by([1, 2, 3, 4, 5], lambda x: \"even\" if x % 2 == 0 else \"odd\")\n        # -> {\"odd\": [1, 3, 5], \"even\": [2, 4]}\n    \"\"\"",
    "reference_solution": "def group_by(items: list, key_func) -> dict:\n    \"\"\"\n    Group elements of a list by the result of applying key_func to each element.\n    Return a dictionary where keys are the results of key_func and values are\n    lists of items that produced that key, in their original order.\n\n    Examples:\n        group_by([1, 2, 3, 4, 5, 6], lambda x: x % 2 == 0)\n        # -> {False: [1, 3, 5], True: [2, 4, 6]}\n\n        group_by([\"apple\", \"banana\", \"avocado\", \"blueberry\"], lambda s: s[0])\n        # -> {\"a\": [\"apple\", \"avocado\"], \"b\": [\"banana\", \"blueberry\"]}\n\n        group_by([], lambda x: x)\n        # -> {}\n\n        group_by([1, 2, 3, 4, 5], lambda x: \"even\" if x % 2 == 0 else \"odd\")\n        # -> {\"odd\": [1, 3, 5], \"even\": [2, 4]}\n    \"\"\"\n    result = {}\n    for item in items:\n        key = key_func(item)\n        if key not in result:\n            result[key] = []\n        result[key].append(item)\n    return result",
    "test_code": "import unittest\n\nclass TestGroupBy(unittest.TestCase):\n    def test_even_odd(self):\n        result = group_by([1, 2, 3, 4, 5, 6], lambda x: x % 2 == 0)\n        self.assertEqual(result[True], [2, 4, 6])\n        self.assertEqual(result[False], [1, 3, 5])\n\n    def test_first_letter(self):\n        result = group_by([\"apple\", \"banana\", \"avocado\", \"blueberry\"], lambda s: s[0])\n        self.assertEqual(result[\"a\"], [\"apple\", \"avocado\"])\n        self.assertEqual(result[\"b\"], [\"banana\", \"blueberry\"])\n\n    def test_empty_list(self):\n        self.assertEqual(group_by([], lambda x: x), {})\n\n    def test_string_keys(self):\n        result = group_by([1, 2, 3, 4, 5], lambda x: \"even\" if x % 2 == 0 else \"odd\")\n        self.assertEqual(result[\"odd\"], [1, 3, 5])\n        self.assertEqual(result[\"even\"], [2, 4])\n\n    def test_identity_key(self):\n        result = group_by([1, 2, 1, 3, 2, 1], lambda x: x)\n        self.assertEqual(result[1], [1, 1, 1])\n        self.assertEqual(result[2], [2, 2])\n        self.assertEqual(result[3], [3])\n\n    def test_length_key(self):\n        result = group_by([\"a\", \"bb\", \"c\", \"dd\", \"eee\"], len)\n        self.assertEqual(result[1], [\"a\", \"c\"])\n        self.assertEqual(result[2], [\"bb\", \"dd\"])\n        self.assertEqual(result[3], [\"eee\"])\n\n    def test_preserves_order(self):\n        result = group_by([5, 3, 1, 4, 2, 6], lambda x: x % 2)\n        self.assertEqual(result[1], [5, 3, 1])\n        self.assertEqual(result[0], [4, 2, 6])\n\n    def test_single_group(self):\n        result = group_by([2, 4, 6, 8], lambda x: \"even\")\n        self.assertEqual(result, {\"even\": [2, 4, 6, 8]})\n\n    def test_all_unique_keys(self):\n        result = group_by([10, 20, 30], lambda x: x)\n        self.assertEqual(len(result), 3)\n        self.assertEqual(result[10], [10])\n        self.assertEqual(result[20], [20])\n        self.assertEqual(result[30], [30])\n\n    def test_boolean_values(self):\n        result = group_by([0, 1, 2, 3], lambda x: x > 1)\n        self.assertEqual(result[False], [0, 1])\n        self.assertEqual(result[True], [2, 3])",
    "tags": ["functional", "dictionary", "grouping", "higher-order-functions"],
    "time_limit_seconds": 5
  },
  {
    "id": "fn_004",
    "category": "functional",
    "difficulty": "hard",
    "title": "Lazy Evaluation",
    "prompt": "class Lazy:\n    \"\"\"\n    A lazy evaluation class that wraps an iterable and supports chaining\n    map and filter operations. Operations are NOT executed until\n    .evaluate() is called.\n\n    Methods:\n        __init__(self, iterable): Store the iterable and initialize an empty\n            list of pending operations.\n        map(self, func): Register a map operation. Returns self for chaining.\n        filter(self, predicate): Register a filter operation. Returns self for chaining.\n        evaluate(self): Execute all registered operations in order on the\n            iterable and return the result as a list.\n\n    The Lazy object should be reusable - after calling evaluate(), the\n    pending operations are cleared but the original iterable is preserved,\n    so new chains can be built.\n\n    Examples:\n        Lazy([1, 2, 3, 4, 5]).filter(lambda x: x % 2 == 0).map(lambda x: x * 10).evaluate()\n        # -> [20, 40]\n\n        lazy = Lazy(range(10))\n        lazy.map(lambda x: x ** 2).filter(lambda x: x > 10).evaluate()\n        # -> [16, 25, 36, 49, 64, 81]\n\n        Lazy([]).evaluate()  # -> []\n    \"\"\"",
    "reference_solution": "class Lazy:\n    \"\"\"\n    A lazy evaluation class that wraps an iterable and supports chaining\n    map and filter operations. Operations are NOT executed until\n    .evaluate() is called.\n\n    Methods:\n        __init__(self, iterable): Store the iterable and initialize an empty\n            list of pending operations.\n        map(self, func): Register a map operation. Returns self for chaining.\n        filter(self, predicate): Register a filter operation. Returns self for chaining.\n        evaluate(self): Execute all registered operations in order on the\n            iterable and return the result as a list.\n\n    The Lazy object should be reusable - after calling evaluate(), the\n    pending operations are cleared but the original iterable is preserved,\n    so new chains can be built.\n\n    Examples:\n        Lazy([1, 2, 3, 4, 5]).filter(lambda x: x % 2 == 0).map(lambda x: x * 10).evaluate()\n        # -> [20, 40]\n\n        lazy = Lazy(range(10))\n        lazy.map(lambda x: x ** 2).filter(lambda x: x > 10).evaluate()\n        # -> [16, 25, 36, 49, 64, 81]\n\n        Lazy([]).evaluate()  # -> []\n    \"\"\"\n    def __init__(self, iterable):\n        self._iterable = iterable\n        self._operations = []\n\n    def map(self, func):\n        self._operations.append(('map', func))\n        return self\n\n    def filter(self, predicate):\n        self._operations.append(('filter', predicate))\n        return self\n\n    def evaluate(self):\n        result = list(self._iterable)\n        for op_type, func in self._operations:\n            if op_type == 'map':\n                result = [func(x) for x in result]\n            elif op_type == 'filter':\n                result = [x for x in result if func(x)]\n        self._operations = []\n        return result",
    "test_code": "import unittest\n\nclass TestLazy(unittest.TestCase):\n    def test_map_only(self):\n        result = Lazy([1, 2, 3]).map(lambda x: x * 2).evaluate()\n        self.assertEqual(result, [2, 4, 6])\n\n    def test_filter_only(self):\n        result = Lazy([1, 2, 3, 4, 5]).filter(lambda x: x > 3).evaluate()\n        self.assertEqual(result, [4, 5])\n\n    def test_filter_then_map(self):\n        result = Lazy([1, 2, 3, 4, 5]).filter(lambda x: x % 2 == 0).map(lambda x: x * 10).evaluate()\n        self.assertEqual(result, [20, 40])\n\n    def test_map_then_filter(self):\n        result = Lazy(range(10)).map(lambda x: x ** 2).filter(lambda x: x > 10).evaluate()\n        self.assertEqual(result, [16, 25, 36, 49, 64, 81])\n\n    def test_empty_iterable(self):\n        result = Lazy([]).evaluate()\n        self.assertEqual(result, [])\n\n    def test_no_operations(self):\n        result = Lazy([1, 2, 3]).evaluate()\n        self.assertEqual(result, [1, 2, 3])\n\n    def test_chaining_multiple_maps(self):\n        result = Lazy([1, 2, 3]).map(lambda x: x + 1).map(lambda x: x * 2).map(lambda x: x - 1).evaluate()\n        self.assertEqual(result, [3, 5, 7])\n\n    def test_chaining_multiple_filters(self):\n        result = Lazy(range(20)).filter(lambda x: x % 2 == 0).filter(lambda x: x % 3 == 0).evaluate()\n        self.assertEqual(result, [0, 6, 12, 18])\n\n    def test_reusability(self):\n        lazy = Lazy([1, 2, 3, 4, 5])\n        r1 = lazy.map(lambda x: x * 2).evaluate()\n        self.assertEqual(r1, [2, 4, 6, 8, 10])\n        r2 = lazy.filter(lambda x: x > 2).evaluate()\n        self.assertEqual(r2, [3, 4, 5])\n\n    def test_with_range(self):\n        result = Lazy(range(5)).map(lambda x: x + 1).evaluate()\n        self.assertEqual(result, [1, 2, 3, 4, 5])\n\n    def test_returns_list(self):\n        result = Lazy([1, 2, 3]).evaluate()\n        self.assertIsInstance(result, list)\n\n    def test_complex_chain(self):\n        result = (Lazy(range(1, 11))\n                  .filter(lambda x: x % 2 == 1)\n                  .map(lambda x: x ** 2)\n                  .filter(lambda x: x < 50)\n                  .map(str)\n                  .evaluate())\n        self.assertEqual(result, [\"1\", \"9\", \"25\", \"49\"])\n\n    def test_operations_cleared_after_evaluate(self):\n        lazy = Lazy([1, 2, 3])\n        lazy.map(lambda x: x * 100).evaluate()\n        result = lazy.evaluate()\n        self.assertEqual(result, [1, 2, 3])\n\n    def test_string_iterable(self):\n        result = Lazy(\"hello\").map(str.upper).filter(lambda c: c != \"L\").evaluate()\n        self.assertEqual(result, [\"H\", \"E\", \"O\"])",
    "tags": ["functional", "lazy-evaluation", "chaining", "class", "iterables"],
    "time_limit_seconds": 5
  }
]

[
  {
    "id": "exc_003",
    "category": "exceptions",
    "difficulty": "hard",
    "title": "Custom Exception Hierarchy and Schema Validation",
    "passed": true,
    "error": null,
    "generated_code": "import re\n\n\nclass ValidationError(Exception):\n    \"\"\"Base exception for validation errors.\"\"\"\n\n    def __init__(self, field, message):\n        self.field = field\n        self.message = message\n        super().__init__(f\"{field}: {message}\")\n\n\nclass TypeValidationError(ValidationError):\n    \"\"\"Raised when a field has the wrong type.\"\"\"\n\n    def __init__(self, field, expected_type, actual_type):\n        self.expected_type = expected_type\n        self.actual_type = actual_type\n        super().__init__(\n            field,\n            f\"expected {expected_type.__name__}, got {actual_type.__name__}\"\n        )\n\n\nclass RangeValidationError(ValidationError):\n    \"\"\"Raised when a numeric field is out of range.\"\"\"\n\n    def __init__(self, field, value, min_value=None, max_value=None):\n        self.value = value\n        self.min_value = min_value\n        self.max_value = max_value\n        parts = []\n        if min_value is not None:\n            parts.append(f\">= {min_value}\")\n        if max_value is not None:\n            parts.append(f\"<= {max_value}\")\n        constraint = \" and \".join(parts)\n        super().__init__(\n            field,\n            f\"value {value} is out of range ({constraint})\"\n        )\n\n\nclass PatternValidationError(ValidationError):\n    \"\"\"Raised when a string field does not match a regex pattern.\"\"\"\n\n    def __init__(self, field, pattern, value):\n        self.pattern = pattern\n        self.value = value\n        super().__init__(\n            field,\n            f\"value '{value}' does not match pattern '{pattern}'\"\n        )\n\n\ndef validate_data(schema, data):\n    \"\"\"Validate data against a schema, raising appropriate exceptions.\"\"\"\n    for field_name, rules in schema.items():\n        required = rules.get('required', True)\n\n        if field_name not in data:\n            if required:\n                raise ValidationError(field_name, \"required field is missing\")\n            continue\n\n        value = data[field_name]\n\n        # Type check\n        if 'type' in rules:\n            expected = rules['type']\n            if not isinstance(value, expected):\n                raise TypeValidationError(field_name, expected, type(value))\n\n        # Range check (for numeric types)\n        min_val = rules.get('min')\n        max_val = rules.get('max')\n        if min_val is not None and value < min_val:\n            raise RangeValidationError(field_name, value, min_value=min_val, max_value=max_val)\n        if max_val is not None and value > max_val:\n            raise RangeValidationError(field_name, value, min_value=min_val, max_value=max_val)\n\n        # Pattern check (for string types)\n        if 'pattern' in rules:\n            pattern = rules['pattern']\n            if not re.fullmatch(pattern, value):\n                raise PatternValidationError(field_name, pattern, value)\n\n    return True\n",
    "stdout": "",
    "stderr": "...........................\n----------------------------------------------------------------------\nRan 27 tests in 0.001s\n\nOK\n"
  },
  {
    "id": "oop_003",
    "category": "oop",
    "difficulty": "medium",
    "title": "BankAccount with Transaction History",
    "passed": true,
    "error": null,
    "generated_code": "class BankAccount:\n    \"\"\"A bank account with deposit, withdraw, transfer, and transaction history.\"\"\"\n\n    def __init__(self, owner: str, initial_balance: float = 0.0):\n        if initial_balance < 0:\n            raise ValueError(\"initial_balance cannot be negative\")\n        self.owner = owner\n        self._balance = initial_balance\n        self._history = []\n\n    @property\n    def balance(self) -> float:\n        \"\"\"The current balance (read-only).\"\"\"\n        return self._balance\n\n    def deposit(self, amount: float) -> None:\n        \"\"\"Add amount to balance.\"\"\"\n        if amount <= 0:\n            raise ValueError(\"deposit amount must be positive\")\n        self._balance += amount\n        self._history.append(('deposit', amount))\n\n    def withdraw(self, amount: float) -> None:\n        \"\"\"Subtract amount from balance.\"\"\"\n        if amount <= 0:\n            raise ValueError(\"withdraw amount must be positive\")\n        if amount > self._balance:\n            raise ValueError(\"insufficient funds\")\n        self._balance -= amount\n        self._history.append(('withdraw', amount))\n\n    def transfer_to(self, other_account: 'BankAccount', amount: float) -> None:\n        \"\"\"Transfer amount from this account to other_account.\"\"\"\n        if amount <= 0:\n            raise ValueError(\"transfer amount must be positive\")\n        if amount > self._balance:\n            raise ValueError(\"insufficient funds\")\n        self._balance -= amount\n        other_account._balance += amount\n        self._history.append(('transfer_out', amount))\n        other_account._history.append(('transfer_in', amount))\n\n    def get_history(self) -> list:\n        \"\"\"Return a list of all transaction tuples in chronological order.\"\"\"\n        return list(self._history)\n",
    "stdout": "",
    "stderr": ".................\n----------------------------------------------------------------------\nRan 17 tests in 0.001s\n\nOK\n"
  },
  {
    "id": "oop_005",
    "category": "oop",
    "difficulty": "hard",
    "title": "ValidatedField Descriptor",
    "passed": true,
    "error": null,
    "generated_code": "class ValidatedField:\n    \"\"\"A descriptor that validates field values on assignment.\"\"\"\n\n    def __init__(self, field_type, *, min_value=None, max_value=None, max_length=None):\n        self.field_type = field_type\n        self.min_value = min_value\n        self.max_value = max_value\n        self.max_length = max_length\n\n    def __set_name__(self, owner, name):\n        self.attr_name = '_validated_' + name\n        self.public_name = name\n\n    def __get__(self, obj, objtype=None):\n        if obj is None:\n            return self\n        if not hasattr(obj, self.attr_name):\n            raise AttributeError(f\"'{type(obj).__name__}' object has no attribute '{self.public_name}'\")\n        return getattr(obj, self.attr_name)\n\n    def __set__(self, obj, value):\n        if not isinstance(value, self.field_type):\n            raise TypeError(\n                f\"Expected {self.field_type.__name__} for '{self.public_name}', \"\n                f\"got {type(value).__name__}\"\n            )\n        if self.field_type in (int, float):\n            if self.min_value is not None and value < self.min_value:\n                raise ValueError(\n                    f\"'{self.public_name}' must be >= {self.min_value}, got {value}\"\n                )\n            if self.max_value is not None and value > self.max_value:\n                raise ValueError(\n                    f\"'{self.public_name}' must be <= {self.max_value}, got {value}\"\n                )\n        if self.field_type is str:\n            if self.max_length is not None and len(value) > self.max_length:\n                raise ValueError(\n                    f\"'{self.public_name}' length must be <= {self.max_length}, got {len(value)}\"\n                )\n        setattr(obj, self.attr_name, value)\n\n\nclass Person:\n    \"\"\"A class using ValidatedField descriptors.\"\"\"\n    name = ValidatedField(str, max_length=50)\n    age = ValidatedField(int, min_value=0, max_value=200)\n    email = ValidatedField(str, max_length=100)\n\n    def __init__(self, name: str, age: int, email: str):\n        self.name = name\n        self.age = age\n        self.email = email\n",
    "stdout": "",
    "stderr": "..................\n----------------------------------------------------------------------\nRan 18 tests in 0.001s\n\nOK\n"
  }
]
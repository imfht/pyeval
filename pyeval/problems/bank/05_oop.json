[
  {
    "id": "oop_001",
    "category": "oop",
    "difficulty": "easy",
    "title": "Stack Class",
    "prompt": "class Stack:\n    \"\"\"A stack data structure with standard operations.\n\n    Methods:\n        push(item): Add an item to the top of the stack.\n        pop(): Remove and return the top item. Raise IndexError if empty.\n        peek(): Return the top item without removing it. Raise IndexError if empty.\n        is_empty(): Return True if the stack is empty, False otherwise.\n        size(): Return the number of items in the stack.\n    \"\"\"\n",
    "reference_solution": "class Stack:\n    \"\"\"A stack data structure with standard operations.\"\"\"\n\n    def __init__(self):\n        self._items = []\n\n    def push(self, item):\n        \"\"\"Add an item to the top of the stack.\"\"\"\n        self._items.append(item)\n\n    def pop(self):\n        \"\"\"Remove and return the top item. Raise IndexError if empty.\"\"\"\n        if self.is_empty():\n            raise IndexError(\"pop from empty stack\")\n        return self._items.pop()\n\n    def peek(self):\n        \"\"\"Return the top item without removing it. Raise IndexError if empty.\"\"\"\n        if self.is_empty():\n            raise IndexError(\"peek from empty stack\")\n        return self._items[-1]\n\n    def is_empty(self):\n        \"\"\"Return True if the stack is empty, False otherwise.\"\"\"\n        return len(self._items) == 0\n\n    def size(self):\n        \"\"\"Return the number of items in the stack.\"\"\"\n        return len(self._items)\n",
    "test_code": "import unittest\n\n\nclass TestStack(unittest.TestCase):\n    def setUp(self):\n        self.stack = Stack()\n\n    def test_new_stack_is_empty(self):\n        self.assertTrue(self.stack.is_empty())\n        self.assertEqual(self.stack.size(), 0)\n\n    def test_push_and_size(self):\n        self.stack.push(1)\n        self.assertEqual(self.stack.size(), 1)\n        self.assertFalse(self.stack.is_empty())\n        self.stack.push(2)\n        self.assertEqual(self.stack.size(), 2)\n\n    def test_pop_returns_last_pushed(self):\n        self.stack.push('a')\n        self.stack.push('b')\n        self.assertEqual(self.stack.pop(), 'b')\n        self.assertEqual(self.stack.pop(), 'a')\n\n    def test_pop_empty_raises(self):\n        with self.assertRaises(IndexError):\n            self.stack.pop()\n\n    def test_peek_returns_top_without_removing(self):\n        self.stack.push(42)\n        self.assertEqual(self.stack.peek(), 42)\n        self.assertEqual(self.stack.size(), 1)\n\n    def test_peek_empty_raises(self):\n        with self.assertRaises(IndexError):\n            self.stack.peek()\n\n    def test_push_pop_mixed(self):\n        self.stack.push(1)\n        self.stack.push(2)\n        self.stack.pop()\n        self.stack.push(3)\n        self.assertEqual(self.stack.peek(), 3)\n        self.assertEqual(self.stack.size(), 2)\n\n    def test_various_types(self):\n        self.stack.push(1)\n        self.stack.push('hello')\n        self.stack.push([1, 2, 3])\n        self.assertEqual(self.stack.pop(), [1, 2, 3])\n        self.assertEqual(self.stack.pop(), 'hello')\n        self.assertEqual(self.stack.pop(), 1)\n",
    "tags": ["class", "stack", "data-structure"],
    "time_limit_seconds": 5
  },
  {
    "id": "oop_002",
    "category": "oop",
    "difficulty": "medium",
    "title": "Shape Hierarchy with Abstract Base Class",
    "prompt": "from abc import ABC, abstractmethod\nimport math\n\n\nclass Shape(ABC):\n    \"\"\"Abstract base class for shapes.\n\n    Abstract Methods:\n        area() -> float: Return the area of the shape.\n        perimeter() -> float: Return the perimeter of the shape.\n    \"\"\"\n\n\nclass Circle(Shape):\n    \"\"\"A circle defined by its radius.\n\n    Args:\n        radius (float): The radius of the circle. Must be positive.\n            Raise ValueError if radius <= 0.\n    \"\"\"\n\n\nclass Rectangle(Shape):\n    \"\"\"A rectangle defined by width and height.\n\n    Args:\n        width (float): The width of the rectangle. Must be positive.\n        height (float): The height of the rectangle. Must be positive.\n            Raise ValueError if width or height <= 0.\n    \"\"\"\n\n\ndef calculate_total_area(shapes):\n    \"\"\"Return the sum of areas of all shapes in the list.\n\n    Args:\n        shapes: A list of Shape instances.\n\n    Returns:\n        float: The total area.\n    \"\"\"\n",
    "reference_solution": "from abc import ABC, abstractmethod\nimport math\n\n\nclass Shape(ABC):\n    \"\"\"Abstract base class for shapes.\"\"\"\n\n    @abstractmethod\n    def area(self) -> float:\n        \"\"\"Return the area of the shape.\"\"\"\n        pass\n\n    @abstractmethod\n    def perimeter(self) -> float:\n        \"\"\"Return the perimeter of the shape.\"\"\"\n        pass\n\n\nclass Circle(Shape):\n    \"\"\"A circle defined by its radius.\"\"\"\n\n    def __init__(self, radius: float):\n        if radius <= 0:\n            raise ValueError(\"radius must be positive\")\n        self.radius = radius\n\n    def area(self) -> float:\n        return math.pi * self.radius ** 2\n\n    def perimeter(self) -> float:\n        return 2 * math.pi * self.radius\n\n\nclass Rectangle(Shape):\n    \"\"\"A rectangle defined by width and height.\"\"\"\n\n    def __init__(self, width: float, height: float):\n        if width <= 0 or height <= 0:\n            raise ValueError(\"width and height must be positive\")\n        self.width = width\n        self.height = height\n\n    def area(self) -> float:\n        return self.width * self.height\n\n    def perimeter(self) -> float:\n        return 2 * (self.width + self.height)\n\n\ndef calculate_total_area(shapes):\n    \"\"\"Return the sum of areas of all shapes in the list.\"\"\"\n    return sum(s.area() for s in shapes)\n",
    "test_code": "import unittest\nimport math\nfrom abc import ABC\n\n\nclass TestShape(unittest.TestCase):\n    def test_shape_is_abstract(self):\n        self.assertTrue(issubclass(Shape, ABC))\n        with self.assertRaises(TypeError):\n            Shape()\n\n\nclass TestCircle(unittest.TestCase):\n    def test_area(self):\n        c = Circle(5)\n        self.assertAlmostEqual(c.area(), math.pi * 25, places=5)\n\n    def test_perimeter(self):\n        c = Circle(3)\n        self.assertAlmostEqual(c.perimeter(), 2 * math.pi * 3, places=5)\n\n    def test_unit_circle(self):\n        c = Circle(1)\n        self.assertAlmostEqual(c.area(), math.pi, places=5)\n        self.assertAlmostEqual(c.perimeter(), 2 * math.pi, places=5)\n\n    def test_invalid_radius(self):\n        with self.assertRaises(ValueError):\n            Circle(0)\n        with self.assertRaises(ValueError):\n            Circle(-1)\n\n    def test_is_shape(self):\n        self.assertIsInstance(Circle(1), Shape)\n\n\nclass TestRectangle(unittest.TestCase):\n    def test_area(self):\n        r = Rectangle(4, 5)\n        self.assertAlmostEqual(r.area(), 20.0, places=5)\n\n    def test_perimeter(self):\n        r = Rectangle(4, 5)\n        self.assertAlmostEqual(r.perimeter(), 18.0, places=5)\n\n    def test_square(self):\n        r = Rectangle(3, 3)\n        self.assertAlmostEqual(r.area(), 9.0, places=5)\n        self.assertAlmostEqual(r.perimeter(), 12.0, places=5)\n\n    def test_invalid_dimensions(self):\n        with self.assertRaises(ValueError):\n            Rectangle(0, 5)\n        with self.assertRaises(ValueError):\n            Rectangle(5, -1)\n\n    def test_is_shape(self):\n        self.assertIsInstance(Rectangle(1, 1), Shape)\n\n\nclass TestCalculateTotalArea(unittest.TestCase):\n    def test_mixed_shapes(self):\n        shapes = [Circle(1), Rectangle(2, 3)]\n        expected = math.pi + 6.0\n        self.assertAlmostEqual(calculate_total_area(shapes), expected, places=5)\n\n    def test_empty_list(self):\n        self.assertAlmostEqual(calculate_total_area([]), 0.0, places=5)\n\n    def test_single_shape(self):\n        shapes = [Rectangle(10, 5)]\n        self.assertAlmostEqual(calculate_total_area(shapes), 50.0, places=5)\n\n    def test_multiple_circles(self):\n        shapes = [Circle(2), Circle(3)]\n        expected = math.pi * 4 + math.pi * 9\n        self.assertAlmostEqual(calculate_total_area(shapes), expected, places=5)\n",
    "tags": ["abc", "inheritance", "polymorphism", "abstract-class"],
    "time_limit_seconds": 5
  },
  {
    "id": "oop_003",
    "category": "oop",
    "difficulty": "medium",
    "title": "BankAccount with Transaction History",
    "prompt": "class BankAccount:\n    \"\"\"A bank account with deposit, withdraw, transfer, and transaction history.\n\n    Constructor:\n        __init__(self, owner: str, initial_balance: float = 0.0)\n            Store owner as a public attribute (self.owner).\n            Store balance internally; expose via read-only property.\n            Initialize an empty transaction history list.\n            Raise ValueError if initial_balance < 0.\n            Do NOT record the initial balance as a transaction.\n\n    Public Attributes:\n        owner (str): The name of the account owner (directly accessible).\n\n    Properties:\n        balance (float): The current balance (read-only property).\n\n    Methods:\n        deposit(amount) -> None:\n            Add amount to balance. Raise ValueError if amount <= 0.\n            Record transaction as ('deposit', amount) in history.\n\n        withdraw(amount) -> None:\n            Subtract amount from balance.\n            Raise ValueError if amount <= 0.\n            Raise ValueError if insufficient funds.\n            Record transaction as ('withdraw', amount) in history.\n\n        transfer_to(other_account, amount) -> None:\n            Withdraw amount from this account and deposit into other_account.\n            Raise ValueError if amount <= 0.\n            Raise ValueError if insufficient funds.\n            Record transaction as ('transfer_out', amount) in this account's history.\n            Record transaction as ('transfer_in', amount) in other account's history.\n\n        get_history() -> list:\n            Return a copy of all transaction tuples in chronological order.\n    \"\"\"\n",
    "reference_solution": "class BankAccount:\n    \"\"\"A bank account with deposit, withdraw, transfer, and transaction history.\"\"\"\n\n    def __init__(self, owner: str, initial_balance: float = 0.0):\n        if initial_balance < 0:\n            raise ValueError(\"initial_balance cannot be negative\")\n        self.owner = owner\n        self._balance = initial_balance\n        self._history = []\n\n    @property\n    def balance(self) -> float:\n        \"\"\"The current balance (read-only).\"\"\"\n        return self._balance\n\n    def deposit(self, amount: float) -> None:\n        \"\"\"Add amount to balance.\"\"\"\n        if amount <= 0:\n            raise ValueError(\"deposit amount must be positive\")\n        self._balance += amount\n        self._history.append(('deposit', amount))\n\n    def withdraw(self, amount: float) -> None:\n        \"\"\"Subtract amount from balance.\"\"\"\n        if amount <= 0:\n            raise ValueError(\"withdraw amount must be positive\")\n        if amount > self._balance:\n            raise ValueError(\"insufficient funds\")\n        self._balance -= amount\n        self._history.append(('withdraw', amount))\n\n    def transfer_to(self, other_account: 'BankAccount', amount: float) -> None:\n        \"\"\"Transfer amount from this account to other_account.\"\"\"\n        if amount <= 0:\n            raise ValueError(\"transfer amount must be positive\")\n        if amount > self._balance:\n            raise ValueError(\"insufficient funds\")\n        self._balance -= amount\n        other_account._balance += amount\n        self._history.append(('transfer_out', amount))\n        other_account._history.append(('transfer_in', amount))\n\n    def get_history(self) -> list:\n        \"\"\"Return a list of all transaction tuples in chronological order.\"\"\"\n        return list(self._history)\n",
    "test_code": "import unittest\n\n\nclass TestBankAccount(unittest.TestCase):\n    def setUp(self):\n        self.account = BankAccount('Alice', 100.0)\n\n    def test_initial_balance(self):\n        self.assertEqual(self.account.balance, 100.0)\n        self.assertEqual(self.account.owner, 'Alice')\n\n    def test_default_balance(self):\n        acc = BankAccount('Bob')\n        self.assertEqual(acc.balance, 0.0)\n\n    def test_negative_initial_balance(self):\n        with self.assertRaises(ValueError):\n            BankAccount('Eve', -50)\n\n    def test_deposit(self):\n        self.account.deposit(50)\n        self.assertEqual(self.account.balance, 150.0)\n\n    def test_deposit_invalid(self):\n        with self.assertRaises(ValueError):\n            self.account.deposit(0)\n        with self.assertRaises(ValueError):\n            self.account.deposit(-10)\n\n    def test_withdraw(self):\n        self.account.withdraw(30)\n        self.assertEqual(self.account.balance, 70.0)\n\n    def test_withdraw_insufficient_funds(self):\n        with self.assertRaises(ValueError):\n            self.account.withdraw(200)\n\n    def test_withdraw_invalid_amount(self):\n        with self.assertRaises(ValueError):\n            self.account.withdraw(0)\n        with self.assertRaises(ValueError):\n            self.account.withdraw(-5)\n\n    def test_transfer_to(self):\n        other = BankAccount('Bob', 50)\n        self.account.transfer_to(other, 40)\n        self.assertEqual(self.account.balance, 60.0)\n        self.assertEqual(other.balance, 90.0)\n\n    def test_transfer_insufficient_funds(self):\n        other = BankAccount('Bob')\n        with self.assertRaises(ValueError):\n            self.account.transfer_to(other, 200)\n\n    def test_transfer_invalid_amount(self):\n        other = BankAccount('Bob')\n        with self.assertRaises(ValueError):\n            self.account.transfer_to(other, 0)\n\n    def test_balance_is_readonly(self):\n        with self.assertRaises(AttributeError):\n            self.account.balance = 999\n\n    def test_history_deposit(self):\n        self.account.deposit(25)\n        history = self.account.get_history()\n        self.assertEqual(history, [('deposit', 25)])\n\n    def test_history_withdraw(self):\n        self.account.withdraw(10)\n        history = self.account.get_history()\n        self.assertEqual(history, [('withdraw', 10)])\n\n    def test_history_transfer(self):\n        other = BankAccount('Bob', 0)\n        self.account.transfer_to(other, 20)\n        self.assertEqual(self.account.get_history(), [('transfer_out', 20)])\n        self.assertEqual(other.get_history(), [('transfer_in', 20)])\n\n    def test_history_multiple_operations(self):\n        self.account.deposit(50)\n        self.account.withdraw(20)\n        self.account.deposit(10)\n        expected = [('deposit', 50), ('withdraw', 20), ('deposit', 10)]\n        self.assertEqual(self.account.get_history(), expected)\n\n    def test_history_returns_copy(self):\n        self.account.deposit(10)\n        history = self.account.get_history()\n        history.clear()\n        self.assertEqual(len(self.account.get_history()), 1)\n",
    "tags": ["class", "property", "encapsulation", "transactions"],
    "time_limit_seconds": 5
  },
  {
    "id": "oop_004",
    "category": "oop",
    "difficulty": "hard",
    "title": "EventEmitter - Observer Pattern",
    "prompt": "class EventEmitter:\n    \"\"\"An event emitter implementing the observer pattern.\n\n    Methods:\n        on(event: str, callback: callable) -> None:\n            Register a callback for the given event.\n            The same callback can be registered multiple times for the same event;\n            each registration counts separately.\n\n        off(event: str, callback: callable) -> None:\n            Remove one registration of callback for the given event.\n            If the callback is registered multiple times, only remove the first one.\n            If callback is not registered for this event, do nothing (no error).\n\n        emit(event: str, *args, **kwargs) -> None:\n            Call all registered callbacks for the event with the given arguments.\n            Callbacks are called in the order they were registered.\n            If no callbacks are registered for the event, do nothing.\n\n        once(event: str, callback: callable) -> None:\n            Register a callback that is automatically removed after it fires once.\n\n        listener_count(event: str) -> int:\n            Return the number of listeners registered for the given event.\n    \"\"\"\n",
    "reference_solution": "class EventEmitter:\n    \"\"\"An event emitter implementing the observer pattern.\"\"\"\n\n    def __init__(self):\n        self._listeners = {}\n\n    def on(self, event: str, callback: callable) -> None:\n        \"\"\"Register a callback for the given event.\"\"\"\n        if event not in self._listeners:\n            self._listeners[event] = []\n        self._listeners[event].append(callback)\n\n    def off(self, event: str, callback: callable) -> None:\n        \"\"\"Remove one registration of callback for the given event.\"\"\"\n        if event in self._listeners:\n            try:\n                self._listeners[event].remove(callback)\n            except ValueError:\n                pass\n\n    def emit(self, event: str, *args, **kwargs) -> None:\n        \"\"\"Call all registered callbacks for the event.\"\"\"\n        if event in self._listeners:\n            for cb in list(self._listeners[event]):\n                cb(*args, **kwargs)\n\n    def once(self, event: str, callback: callable) -> None:\n        \"\"\"Register a callback that fires only once.\"\"\"\n        def wrapper(*args, **kwargs):\n            self.off(event, wrapper)\n            callback(*args, **kwargs)\n        self.on(event, wrapper)\n\n    def listener_count(self, event: str) -> int:\n        \"\"\"Return the number of listeners for the given event.\"\"\"\n        return len(self._listeners.get(event, []))\n",
    "test_code": "import unittest\n\n\nclass TestEventEmitter(unittest.TestCase):\n    def setUp(self):\n        self.emitter = EventEmitter()\n        self.log = []\n\n    def test_on_and_emit(self):\n        self.emitter.on('click', lambda: self.log.append('clicked'))\n        self.emitter.emit('click')\n        self.assertEqual(self.log, ['clicked'])\n\n    def test_emit_with_args(self):\n        self.emitter.on('data', lambda x, y: self.log.append((x, y)))\n        self.emitter.emit('data', 1, 2)\n        self.assertEqual(self.log, [(1, 2)])\n\n    def test_emit_with_kwargs(self):\n        self.emitter.on('msg', lambda text='': self.log.append(text))\n        self.emitter.emit('msg', text='hello')\n        self.assertEqual(self.log, ['hello'])\n\n    def test_multiple_listeners(self):\n        self.emitter.on('evt', lambda: self.log.append('a'))\n        self.emitter.on('evt', lambda: self.log.append('b'))\n        self.emitter.emit('evt')\n        self.assertEqual(self.log, ['a', 'b'])\n\n    def test_listener_order_preserved(self):\n        for i in range(5):\n            val = i\n            self.emitter.on('order', lambda v=val: self.log.append(v))\n        self.emitter.emit('order')\n        self.assertEqual(self.log, [0, 1, 2, 3, 4])\n\n    def test_off_removes_listener(self):\n        cb = lambda: self.log.append('x')\n        self.emitter.on('evt', cb)\n        self.emitter.off('evt', cb)\n        self.emitter.emit('evt')\n        self.assertEqual(self.log, [])\n\n    def test_off_nonexistent_does_nothing(self):\n        cb = lambda: None\n        self.emitter.off('evt', cb)\n\n    def test_off_removes_only_first_registration(self):\n        cb = lambda: self.log.append('x')\n        self.emitter.on('evt', cb)\n        self.emitter.on('evt', cb)\n        self.emitter.off('evt', cb)\n        self.emitter.emit('evt')\n        self.assertEqual(self.log, ['x'])\n\n    def test_emit_no_listeners(self):\n        self.emitter.emit('nonexistent')\n\n    def test_once(self):\n        self.emitter.once('ping', lambda: self.log.append('pong'))\n        self.emitter.emit('ping')\n        self.emitter.emit('ping')\n        self.assertEqual(self.log, ['pong'])\n\n    def test_once_with_args(self):\n        self.emitter.once('data', lambda v: self.log.append(v))\n        self.emitter.emit('data', 42)\n        self.emitter.emit('data', 99)\n        self.assertEqual(self.log, [42])\n\n    def test_listener_count(self):\n        self.assertEqual(self.emitter.listener_count('evt'), 0)\n        cb1 = lambda: None\n        cb2 = lambda: None\n        self.emitter.on('evt', cb1)\n        self.assertEqual(self.emitter.listener_count('evt'), 1)\n        self.emitter.on('evt', cb2)\n        self.assertEqual(self.emitter.listener_count('evt'), 2)\n        self.emitter.off('evt', cb1)\n        self.assertEqual(self.emitter.listener_count('evt'), 1)\n\n    def test_different_events_independent(self):\n        self.emitter.on('a', lambda: self.log.append('a'))\n        self.emitter.on('b', lambda: self.log.append('b'))\n        self.emitter.emit('a')\n        self.assertEqual(self.log, ['a'])\n\n    def test_once_listener_count_decreases(self):\n        self.emitter.once('evt', lambda: None)\n        self.assertEqual(self.emitter.listener_count('evt'), 1)\n        self.emitter.emit('evt')\n        self.assertEqual(self.emitter.listener_count('evt'), 0)\n\n    def test_emit_during_emit_safe(self):\n        \"\"\"Listeners added during emit should not fire in current emit.\"\"\"\n        def add_listener():\n            self.emitter.on('evt', lambda: self.log.append('late'))\n            self.log.append('first')\n        self.emitter.on('evt', add_listener)\n        self.emitter.emit('evt')\n        self.assertEqual(self.log, ['first'])\n        self.log.clear()\n        self.emitter.emit('evt')\n        self.assertIn('late', self.log)\n",
    "tags": ["observer-pattern", "callbacks", "events", "design-pattern"],
    "time_limit_seconds": 5
  },
  {
    "id": "oop_005",
    "category": "oop",
    "difficulty": "hard",
    "title": "ValidatedField Descriptor",
    "prompt": "class ValidatedField:\n    \"\"\"A descriptor that validates field values on assignment.\n\n    Constructor:\n        __init__(self, field_type, *, min_value=None, max_value=None, max_length=None)\n\n    Descriptor Protocol:\n        __set_name__(self, owner, name):\n            Store the field name. Use a private storage attribute like\n            '_validated_' + name on the instance to avoid conflicts.\n\n        __get__(self, obj, objtype=None):\n            If obj is None (class-level access), return the descriptor itself.\n            Otherwise return the stored value.\n            Raise AttributeError if the value has not been set yet.\n\n        __set__(self, obj, value):\n            Validate the value before storing:\n            1. Check isinstance(value, field_type). Raise TypeError if not.\n            2. If field_type is int or float and min_value is set, raise ValueError\n               if value < min_value.\n            3. If field_type is int or float and max_value is set, raise ValueError\n               if value > max_value.\n            4. If field_type is str and max_length is set, raise ValueError\n               if len(value) > max_length.\n    \"\"\"\n\n\nclass Person:\n    \"\"\"A class using ValidatedField descriptors.\n\n    Class-level descriptor fields:\n        name = ValidatedField(str, max_length=50)\n        age = ValidatedField(int, min_value=0, max_value=200)\n        email = ValidatedField(str, max_length=100)\n\n    Constructor:\n        __init__(self, name: str, age: int, email: str)\n            Assign all three arguments to self (triggering descriptor validation).\n    \"\"\"\n",
    "reference_solution": "class ValidatedField:\n    \"\"\"A descriptor that validates field values on assignment.\"\"\"\n\n    def __init__(self, field_type, *, min_value=None, max_value=None, max_length=None):\n        self.field_type = field_type\n        self.min_value = min_value\n        self.max_value = max_value\n        self.max_length = max_length\n\n    def __set_name__(self, owner, name):\n        self.attr_name = '_validated_' + name\n        self.public_name = name\n\n    def __get__(self, obj, objtype=None):\n        if obj is None:\n            return self\n        if not hasattr(obj, self.attr_name):\n            raise AttributeError(f\"'{type(obj).__name__}' object has no attribute '{self.public_name}'\")\n        return getattr(obj, self.attr_name)\n\n    def __set__(self, obj, value):\n        if not isinstance(value, self.field_type):\n            raise TypeError(\n                f\"Expected {self.field_type.__name__} for '{self.public_name}', \"\n                f\"got {type(value).__name__}\"\n            )\n        if self.field_type in (int, float):\n            if self.min_value is not None and value < self.min_value:\n                raise ValueError(\n                    f\"'{self.public_name}' must be >= {self.min_value}, got {value}\"\n                )\n            if self.max_value is not None and value > self.max_value:\n                raise ValueError(\n                    f\"'{self.public_name}' must be <= {self.max_value}, got {value}\"\n                )\n        if self.field_type is str:\n            if self.max_length is not None and len(value) > self.max_length:\n                raise ValueError(\n                    f\"'{self.public_name}' length must be <= {self.max_length}, got {len(value)}\"\n                )\n        setattr(obj, self.attr_name, value)\n\n\nclass Person:\n    \"\"\"A class using ValidatedField descriptors.\"\"\"\n    name = ValidatedField(str, max_length=50)\n    age = ValidatedField(int, min_value=0, max_value=200)\n    email = ValidatedField(str, max_length=100)\n\n    def __init__(self, name: str, age: int, email: str):\n        self.name = name\n        self.age = age\n        self.email = email\n",
    "test_code": "import unittest\n\n\nclass TestValidatedField(unittest.TestCase):\n    def test_type_check_int(self):\n        class Foo:\n            x = ValidatedField(int)\n        f = Foo()\n        f.x = 10\n        self.assertEqual(f.x, 10)\n        with self.assertRaises(TypeError):\n            f.x = 'hello'\n\n    def test_type_check_str(self):\n        class Foo:\n            s = ValidatedField(str)\n        f = Foo()\n        f.s = 'hello'\n        self.assertEqual(f.s, 'hello')\n        with self.assertRaises(TypeError):\n            f.s = 42\n\n    def test_min_value(self):\n        class Foo:\n            x = ValidatedField(int, min_value=0)\n        f = Foo()\n        f.x = 0\n        self.assertEqual(f.x, 0)\n        with self.assertRaises(ValueError):\n            f.x = -1\n\n    def test_max_value(self):\n        class Foo:\n            x = ValidatedField(int, max_value=100)\n        f = Foo()\n        f.x = 100\n        self.assertEqual(f.x, 100)\n        with self.assertRaises(ValueError):\n            f.x = 101\n\n    def test_min_and_max(self):\n        class Foo:\n            x = ValidatedField(float, min_value=0.0, max_value=1.0)\n        f = Foo()\n        f.x = 0.5\n        self.assertEqual(f.x, 0.5)\n        with self.assertRaises(ValueError):\n            f.x = -0.1\n        with self.assertRaises(ValueError):\n            f.x = 1.1\n\n    def test_max_length(self):\n        class Foo:\n            s = ValidatedField(str, max_length=5)\n        f = Foo()\n        f.s = 'abcde'\n        self.assertEqual(f.s, 'abcde')\n        with self.assertRaises(ValueError):\n            f.s = 'abcdef'\n\n    def test_get_unset_raises(self):\n        class Foo:\n            x = ValidatedField(int)\n        f = Foo()\n        with self.assertRaises(AttributeError):\n            _ = f.x\n\n    def test_class_access_returns_descriptor(self):\n        class Foo:\n            x = ValidatedField(int)\n        self.assertIsInstance(Foo.x, ValidatedField)\n\n    def test_independent_instances(self):\n        class Foo:\n            x = ValidatedField(int)\n        a = Foo()\n        b = Foo()\n        a.x = 1\n        b.x = 2\n        self.assertEqual(a.x, 1)\n        self.assertEqual(b.x, 2)\n\n\nclass TestPerson(unittest.TestCase):\n    def test_valid_person(self):\n        p = Person('Alice', 30, 'alice@example.com')\n        self.assertEqual(p.name, 'Alice')\n        self.assertEqual(p.age, 30)\n        self.assertEqual(p.email, 'alice@example.com')\n\n    def test_invalid_name_type(self):\n        with self.assertRaises(TypeError):\n            Person(123, 30, 'a@b.com')\n\n    def test_invalid_age_type(self):\n        with self.assertRaises(TypeError):\n            Person('Alice', '30', 'a@b.com')\n\n    def test_age_too_low(self):\n        with self.assertRaises(ValueError):\n            Person('Alice', -1, 'a@b.com')\n\n    def test_age_too_high(self):\n        with self.assertRaises(ValueError):\n            Person('Alice', 201, 'a@b.com')\n\n    def test_name_too_long(self):\n        with self.assertRaises(ValueError):\n            Person('A' * 51, 30, 'a@b.com')\n\n    def test_email_too_long(self):\n        with self.assertRaises(ValueError):\n            Person('Alice', 30, 'a' * 101)\n\n    def test_update_field(self):\n        p = Person('Alice', 30, 'a@b.com')\n        p.age = 31\n        self.assertEqual(p.age, 31)\n        with self.assertRaises(ValueError):\n            p.age = -5\n\n    def test_boundary_age(self):\n        p = Person('Alice', 0, 'a@b.com')\n        self.assertEqual(p.age, 0)\n        p2 = Person('Bob', 200, 'b@b.com')\n        self.assertEqual(p2.age, 200)\n",
    "tags": ["descriptor", "validation", "metaclass", "advanced-oop"],
    "time_limit_seconds": 5
  }
]

[
  {
    "id": "algo_001",
    "category": "algorithms",
    "difficulty": "easy",
    "title": "Binary Search",
    "passed": true,
    "error": null,
    "generated_code": "def binary_search(arr: list[int], target: int) -> int:\n    \"\"\"Search for target in a sorted list of integers using binary search.\n\n    Args:\n        arr: A sorted list of integers in ascending order.\n        target: The integer to search for.\n\n    Returns:\n        The index of target in arr if found, otherwise -1.\n    \"\"\"\n    left, right = 0, len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1",
    "stdout": "",
    "stderr": "...........\n----------------------------------------------------------------------\nRan 11 tests in 0.001s\n\nOK\n"
  },
  {
    "id": "algo_002",
    "category": "algorithms",
    "difficulty": "easy",
    "title": "Bubble Sort",
    "passed": true,
    "error": null,
    "generated_code": "def bubble_sort(arr: list[int]) -> list[int]:\n    \"\"\"Sort a list of integers in ascending order using bubble sort.\n\n    Args:\n        arr: A list of integers to sort.\n\n    Returns:\n        A new list containing the same elements sorted in ascending order.\n        The original list must not be modified.\n    \"\"\"\n    # Create a copy to avoid modifying the original list\n    result = arr.copy()\n    n = len(result)\n    \n    for i in range(n):\n        # Flag to optimize: if no swaps occur, the list is already sorted\n        swapped = False\n        \n        # Last i elements are already in place after i passes\n        for j in range(0, n - 1 - i):\n            if result[j] > result[j + 1]:\n                # Swap elements\n                result[j], result[j + 1] = result[j + 1], result[j]\n                swapped = True\n        \n        # If no two elements were swapped in the inner loop, break early\n        if not swapped:\n            break\n    \n    return result",
    "stdout": "",
    "stderr": ".........\n----------------------------------------------------------------------\nRan 9 tests in 0.000s\n\nOK\n"
  },
  {
    "id": "algo_003",
    "category": "algorithms",
    "difficulty": "medium",
    "title": "Merge Sort",
    "passed": true,
    "error": null,
    "generated_code": "def merge_sort(arr: list[int]) -> list[int]:\n    \"\"\"Sort a list of integers in ascending order using merge sort.\n\n    Args:\n        arr: A list of integers to sort.\n\n    Returns:\n        A new sorted list. The original list must not be modified.\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n\n    merged = []\n    i, j = 0, 0\n\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            merged.append(left[i])\n            i += 1\n        else:\n            merged.append(right[j])\n            j += 1\n\n    merged.extend(left[i:])\n    merged.extend(right[j:])\n\n    return merged",
    "stdout": "",
    "stderr": "...........\n----------------------------------------------------------------------\nRan 11 tests in 0.002s\n\nOK\n"
  },
  {
    "id": "algo_004",
    "category": "algorithms",
    "difficulty": "medium",
    "title": "Longest Common Subsequence",
    "passed": true,
    "error": null,
    "generated_code": "def longest_common_subsequence(s1: str, s2: str) -> int:\n    \"\"\"Find the length of the longest common subsequence of two strings.\n\n    A subsequence is a sequence that can be derived from another sequence\n    by deleting some or no elements without changing the order of the\n    remaining elements.\n\n    Args:\n        s1: The first string.\n        s2: The second string.\n\n    Returns:\n        The length of the longest common subsequence.\n    \"\"\"\n    m, n = len(s1), len(s2)\n    \n    # Create a 2D DP table with (m+1) rows and (n+1) columns\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    \n    return dp[m][n]",
    "stdout": "",
    "stderr": "...........\n----------------------------------------------------------------------\nRan 11 tests in 0.000s\n\nOK\n"
  },
  {
    "id": "algo_005",
    "category": "algorithms",
    "difficulty": "medium",
    "title": "Valid Parentheses",
    "passed": true,
    "error": null,
    "generated_code": "def valid_parentheses(s: str) -> bool:\n    \"\"\"Check if a string of brackets is valid.\n\n    A string is valid if:\n    - Open brackets are closed by the same type of brackets.\n    - Open brackets are closed in the correct order.\n    - Every close bracket has a corresponding open bracket of the same type.\n\n    Supported bracket types: (), [], {}\n\n    Args:\n        s: A string containing only the characters '(', ')', '[', ']', '{', '}'.\n\n    Returns:\n        True if the string is valid, False otherwise.\n    \"\"\"\n    stack = []\n    mapping = {')': '(', ']': '[', '}': '{'}\n\n    for char in s:\n        if char in mapping.values():\n            stack.append(char)\n        elif char in mapping.keys():\n            if not stack or stack.pop() != mapping[char]:\n                return False\n        else:\n            # According to the docstring, input contains only bracket characters,\n            # but this handles unexpected characters gracefully by returning False.\n            return False\n\n    return len(stack) == 0",
    "stdout": "",
    "stderr": ".............\n----------------------------------------------------------------------\nRan 13 tests in 0.001s\n\nOK\n"
  },
  {
    "id": "algo_006",
    "category": "algorithms",
    "difficulty": "hard",
    "title": "0/1 Knapsack",
    "passed": true,
    "error": null,
    "generated_code": "def knapsack_01(weights: list[int], values: list[int], capacity: int) -> int:\n    \"\"\"Solve the 0/1 knapsack problem.\n\n    Given a set of items, each with a weight and a value, determine the\n    maximum total value that can be achieved by selecting items such that\n    the total weight does not exceed the given capacity. Each item can\n    either be included or excluded (no fractions).\n\n    Args:\n        weights: A list of positive integer weights for each item.\n        values: A list of positive integer values for each item.\n        capacity: The maximum total weight the knapsack can hold (non-negative integer).\n\n    Returns:\n        The maximum total value achievable within the weight capacity.\n    \"\"\"\n    n = len(weights)\n    if n == 0 or capacity <= 0:\n        return 0\n\n    # dp[w] will store the maximum value achievable with capacity w\n    dp = [0] * (capacity + 1)\n\n    for i in range(n):\n        weight = weights[i]\n        value = values[i]\n        # Traverse backwards to ensure each item is only considered once\n        for w in range(capacity, weight - 1, -1):\n            dp[w] = max(dp[w], dp[w - weight] + value)\n\n    return dp[capacity]",
    "stdout": "",
    "stderr": "...........\n----------------------------------------------------------------------\nRan 11 tests in 0.000s\n\nOK\n"
  },
  {
    "id": "algo_007",
    "category": "algorithms",
    "difficulty": "hard",
    "title": "Topological Sort",
    "passed": true,
    "error": null,
    "generated_code": "def topological_sort(graph: dict[str, list[str]]) -> list[str]:\n    \"\"\"Return a topological ordering of a directed acyclic graph (DAG).\n\n    Args:\n        graph: An adjacency list representation of a directed graph.\n               Keys are node names (strings), values are lists of nodes\n               that the key node has edges TO. For example,\n               {'a': ['b', 'c']} means edges a->b and a->c.\n               All nodes in the graph appear as keys (even if they\n               have no outgoing edges).\n\n    Returns:\n        A list of node names in a valid topological order. If the graph\n        contains a cycle, return an empty list.\n    \"\"\"\n    # Compute in-degrees for all nodes\n    in_degree = {node: 0 for node in graph}\n    for node in graph:\n        for neighbor in graph[node]:\n            in_degree[neighbor] += 1\n\n    # Initialize queue with nodes having in-degree 0\n    queue = [node for node in graph if in_degree[node] == 0]\n    result = []\n\n    while queue:\n        current = queue.pop(0)\n        result.append(current)\n\n        for neighbor in graph[current]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n\n    # If result contains all nodes, it's a valid topological sort; otherwise, there's a cycle\n    if len(result) == len(graph):\n        return result\n    else:\n        return []",
    "stdout": "",
    "stderr": "...........\n----------------------------------------------------------------------\nRan 11 tests in 0.000s\n\nOK\n"
  },
  {
    "id": "bs_001",
    "category": "basic_syntax",
    "difficulty": "easy",
    "title": "FizzBuzz",
    "passed": true,
    "error": null,
    "generated_code": "def fizzbuzz(n: int) -> list:\n    \"\"\"\n    Given a positive integer n, return a list of strings from 1 to n where:\n    - Multiples of 3 are replaced with \"Fizz\"\n    - Multiples of 5 are replaced with \"Buzz\"\n    - Multiples of both 3 and 5 are replaced with \"FizzBuzz\"\n    - All other numbers are converted to their string representation\n\n    Example:\n        fizzbuzz(5) -> [\"1\", \"2\", \"Fizz\", \"4\", \"Buzz\"]\n        fizzbuzz(15) -> [\"1\", \"2\", \"Fizz\", \"4\", \"Buzz\", \"Fizz\", \"7\", \"8\", \"Fizz\", \"Buzz\", \"11\", \"Fizz\", \"13\", \"14\", \"FizzBuzz\"]\n    \"\"\"\n    result = []\n    for i in range(1, n + 1):\n        if i % 15 == 0:\n            result.append(\"FizzBuzz\")\n        elif i % 3 == 0:\n            result.append(\"Fizz\")\n        elif i % 5 == 0:\n            result.append(\"Buzz\")\n        else:\n            result.append(str(i))\n    return result",
    "stdout": "",
    "stderr": "........\n----------------------------------------------------------------------\nRan 8 tests in 0.000s\n\nOK\n"
  },
  {
    "id": "bs_002",
    "category": "basic_syntax",
    "difficulty": "easy",
    "title": "Swap Variables",
    "passed": true,
    "error": null,
    "generated_code": "def swap_variables(d: dict) -> dict:\n    \"\"\"\n    Given a dictionary with keys 'a' and 'b', return a new dictionary\n    where the values of 'a' and 'b' are swapped.\n\n    The original dictionary must not be modified.\n\n    Example:\n        swap_variables({'a': 1, 'b': 2}) -> {'a': 2, 'b': 1}\n        swap_variables({'a': 'hello', 'b': 'world'}) -> {'a': 'world', 'b': 'hello'}\n    \"\"\"\n    return {'a': d['b'], 'b': d['a']}",
    "stdout": "",
    "stderr": ".......\n----------------------------------------------------------------------\nRan 7 tests in 0.000s\n\nOK\n"
  },
  {
    "id": "bs_003",
    "category": "basic_syntax",
    "difficulty": "easy",
    "title": "Number to Words",
    "passed": true,
    "error": null,
    "generated_code": "def number_to_words(n: int) -> str:\n    \"\"\"\n    Convert an integer from 0 to 999 (inclusive) to its English words representation.\n\n    Rules:\n    - 0 -> \"Zero\"\n    - Use standard English number names\n    - Hyphenate compound numbers 21-99 (e.g., \"Twenty-One\")\n    - Use title case (e.g., \"One Hundred Forty-Five\")\n    - No \"and\" between hundred and tens/ones (e.g., \"One Hundred Twelve\", not \"One Hundred and Twelve\")\n\n    Examples:\n        number_to_words(0) -> \"Zero\"\n        number_to_words(5) -> \"Five\"\n        number_to_words(42) -> \"Forty-Two\"\n        number_to_words(100) -> \"One Hundred\"\n        number_to_words(999) -> \"Nine Hundred Ninety-Nine\"\n        number_to_words(115) -> \"One Hundred Fifteen\"\n    \"\"\"\n    if not 0 <= n <= 999:\n        raise ValueError(\"Input must be between 0 and 999 inclusive.\")\n\n    ones = [\n        \"Zero\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\",\n        \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\",\n        \"Seventeen\", \"Eighteen\", \"Nineteen\"\n    ]\n\n    tens = [\n        \"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"\n    ]\n\n    if n < 20:\n        return ones[n]\n\n    if n < 100:\n        ten_digit = n // 10\n        one_digit = n % 10\n        if one_digit == 0:\n            return tens[ten_digit]\n        else:\n            return f\"{tens[ten_digit]}-{ones[one_digit]}\"\n\n    # n >= 100\n    hundred_digit = n // 100\n    remainder = n % 100\n\n    if remainder == 0:\n        return f\"{ones[hundred_digit]} Hundred\"\n    else:\n        return f\"{ones[hundred_digit]} Hundred {number_to_words(remainder)}\"",
    "stdout": "",
    "stderr": "..........\n----------------------------------------------------------------------\nRan 10 tests in 0.000s\n\nOK\n"
  },
  {
    "id": "bs_004",
    "category": "basic_syntax",
    "difficulty": "medium",
    "title": "Flatten Nested List",
    "passed": true,
    "error": null,
    "generated_code": "def flatten_nested(lst: list) -> list:\n    \"\"\"\n    Flatten an arbitrarily nested list into a single flat list.\n    The order of elements should be preserved (depth-first, left-to-right).\n    Non-list elements should be kept as-is.\n\n    Examples:\n        flatten_nested([1, [2, 3], [4, [5, 6]]]) -> [1, 2, 3, 4, 5, 6]\n        flatten_nested([1, [2, [3, [4, [5]]]]]) -> [1, 2, 3, 4, 5]\n        flatten_nested([]) -> []\n        flatten_nested([1, 'hello', [2, [True, None]]]) -> [1, 'hello', 2, True, None]\n    \"\"\"\n    result = []\n\n    def _flatten(item):\n        if isinstance(item, list):\n            for sub_item in item:\n                _flatten(sub_item)\n        else:\n            result.append(item)\n\n    _flatten(lst)\n    return result",
    "stdout": "",
    "stderr": "..........\n----------------------------------------------------------------------\nRan 10 tests in 0.000s\n\nOK\n"
  },
  {
    "id": "bs_005",
    "category": "basic_syntax",
    "difficulty": "hard",
    "title": "Matrix Spiral Order",
    "passed": true,
    "error": null,
    "generated_code": "def matrix_spiral(matrix: list) -> list:\n    \"\"\"\n    Given an MxN matrix (list of lists of integers), return all elements\n    in spiral order (clockwise, starting from top-left).\n\n    The spiral traversal goes: right across the top row, down the right column,\n    left across the bottom row, up the left column, then inward.\n\n    Examples:\n        matrix_spiral([[1, 2, 3],\n                       [4, 5, 6],\n                       [7, 8, 9]]) -> [1, 2, 3, 6, 9, 8, 7, 4, 5]\n\n        matrix_spiral([[1, 2, 3, 4],\n                       [5, 6, 7, 8],\n                       [9, 10, 11, 12]]) -> [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]\n\n        matrix_spiral([]) -> []\n        matrix_spiral([[1]]) -> [1]\n    \"\"\"\n    if not matrix or not matrix[0]:\n        return []\n\n    result = []\n    top, bottom = 0, len(matrix) - 1\n    left, right = 0, len(matrix[0]) - 1\n\n    while top <= bottom and left <= right:\n        # Traverse right along the top row\n        for col in range(left, right + 1):\n            result.append(matrix[top][col])\n        top += 1\n\n        # Traverse down along the right column\n        for row in range(top, bottom + 1):\n            result.append(matrix[row][right])\n        right -= 1\n\n        # Traverse left along the bottom row (if still valid)\n        if top <= bottom:\n            for col in range(right, left - 1, -1):\n                result.append(matrix[bottom][col])\n            bottom -= 1\n\n        # Traverse up along the left column (if still valid)\n        if left <= right:\n            for row in range(bottom, top - 1, -1):\n                result.append(matrix[row][left])\n            left += 1\n\n    return result",
    "stdout": "",
    "stderr": "..........\n----------------------------------------------------------------------\nRan 10 tests in 0.000s\n\nOK\n"
  },
  {
    "id": "con_001",
    "category": "concurrency",
    "difficulty": "easy",
    "title": "Thread-Safe Counter",
    "passed": true,
    "error": null,
    "generated_code": "import threading\n\nclass ThreadSafeCounter:\n    \"\"\"\n    A thread-safe counter that can be safely incremented and decremented\n    from multiple threads simultaneously.\n\n    Methods:\n        __init__(self, initial=0): Initialize the counter with an optional\n            starting value (default 0).\n        increment(self): Atomically increase the counter by 1.\n        decrement(self): Atomically decrease the counter by 1.\n        get_value(self): Return the current counter value.\n\n    The counter must use threading.Lock to ensure thread safety.\n\n    Examples:\n        counter = ThreadSafeCounter()\n        counter.increment()\n        counter.increment()\n        counter.get_value()  # -> 2\n        counter.decrement()\n        counter.get_value()  # -> 1\n\n        counter = ThreadSafeCounter(10)\n        counter.get_value()  # -> 10\n    \"\"\"\n\n    def __init__(self, initial=0):\n        self._value = initial\n        self._lock = threading.Lock()\n\n    def increment(self):\n        with self._lock:\n            self._value += 1\n\n    def decrement(self):\n        with self._lock:\n            self._value -= 1\n\n    def get_value(self):\n        with self._lock:\n            return self._value",
    "stdout": "",
    "stderr": "..........\n----------------------------------------------------------------------\nRan 10 tests in 0.300s\n\nOK\n"
  },
  {
    "id": "con_002",
    "category": "concurrency",
    "difficulty": "medium",
    "title": "Parallel Map",
    "passed": true,
    "error": null,
    "generated_code": "from concurrent.futures import ThreadPoolExecutor\n\ndef parallel_map(func, items: list, max_workers: int = 4) -> list:\n    \"\"\"\n    Apply a function to each item in a list using parallel execution with\n    a thread pool. Return the results in the same order as the input items.\n\n    Args:\n        func: A callable to apply to each item.\n        items: A list of items to process.\n        max_workers: Maximum number of threads to use (default 4).\n\n    Returns:\n        A list of results in the same order as the input.\n\n    Examples:\n        parallel_map(lambda x: x ** 2, [1, 2, 3, 4])  # -> [1, 4, 9, 16]\n        parallel_map(str.upper, [\"hello\", \"world\"])  # -> [\"HELLO\", \"WORLD\"]\n        parallel_map(lambda x: x + 1, [], max_workers=2)  # -> []\n    \"\"\"\n    if not items:\n        return []\n\n    with ThreadPoolExecutor(max_workers=max_workers) as executor:\n        # Submit all tasks and keep track of their order\n        futures = [executor.submit(func, item) for item in items]\n        # Collect results in the original order\n        results = [future.result() for future in futures]\n\n    return results",
    "stdout": "",
    "stderr": "..........\n----------------------------------------------------------------------\nRan 10 tests in 0.114s\n\nOK\n"
  },
  {
    "id": "con_003",
    "category": "concurrency",
    "difficulty": "medium",
    "title": "Producer Consumer",
    "passed": true,
    "error": null,
    "generated_code": "import threading\nimport queue\n\ndef producer_consumer(producers: list, consumers: list, queue_size: int = 10) -> list:\n    \"\"\"\n    Implement the producer-consumer pattern using threading and queue.Queue.\n\n    Args:\n        producers: A list of callables. Each producer callable, when called,\n            returns a list of items to be placed on the queue.\n        consumers: A list of callables. Each consumer callable takes a single\n            item from the queue and returns a processed result.\n        queue_size: Maximum size of the shared queue (default 10).\n\n    Behavior:\n        - Create a bounded Queue with the given queue_size.\n        - Start one thread per consumer FIRST. Each consumer thread loops:\n          gets an item from the queue, and if it's None (sentinel), stops.\n          Otherwise, calls its consumer callable on the item and collects\n          the result.\n        - Start one thread per producer. Each producer thread calls its callable\n          to get items, then puts each item on the queue.\n        - Wait for all producer threads to finish.\n        - Put one sentinel None per consumer on the queue.\n        - Wait for all consumer threads to finish.\n        - Return ALL consumed (processed) results as a single flat list.\n          The order of results does not need to match input order.\n\n    Examples:\n        results = producer_consumer(\n            producers=[lambda: [1, 2, 3], lambda: [4, 5]],\n            consumers=[lambda x: x * 2],\n            queue_size=5\n        )\n        sorted(results)  # -> [2, 4, 6, 8, 10]\n    \"\"\"\n    q = queue.Queue(maxsize=queue_size)\n    results = []\n    results_lock = threading.Lock()\n\n    def consumer_worker(consumer_func):\n        while True:\n            item = q.get()\n            if item is None:\n                q.task_done()\n                break\n            try:\n                result = consumer_func(item)\n                with results_lock:\n                    results.append(result)\n            finally:\n                q.task_done()\n\n    def producer_worker(producer_func):\n        items = producer_func()\n        for item in items:\n            q.put(item)\n\n    consumer_threads = []\n    for _ in range(len(consumers)):\n        t = threading.Thread(target=consumer_worker, args=(consumers[_ % len(consumers)],))\n        t.start()\n        consumer_threads.append(t)\n\n    producer_threads = []\n    for prod_func in producers:\n        t = threading.Thread(target=producer_worker, args=(prod_func,))\n        t.start()\n        producer_threads.append(t)\n\n    for t in producer_threads:\n        t.join()\n\n    for _ in consumers:\n        q.put(None)\n\n    for t in consumer_threads:\n        t.join()\n\n    return results",
    "stdout": "",
    "stderr": ".........\n----------------------------------------------------------------------\nRan 9 tests in 0.009s\n\nOK\n"
  },
  {
    "id": "con_004",
    "category": "concurrency",
    "difficulty": "hard",
    "title": "Async Gather with Timeout",
    "passed": true,
    "error": null,
    "generated_code": "import asyncio\n\nasync def async_gather_results(async_callables: list, timeout: float = None) -> list:\n    \"\"\"\n    Run a list of async callables (coroutine functions) concurrently and\n    return their results.\n\n    Args:\n        async_callables: A list of async callables (coroutine functions that\n            take no arguments). Each one, when called, returns a coroutine.\n        timeout: Optional timeout in seconds. If provided and the total\n            execution exceeds this duration, raise asyncio.TimeoutError.\n            If None, no timeout is applied.\n\n    Returns:\n        A list of results in the same order as the input callables.\n\n    Behavior:\n        - Call each async callable to create a coroutine.\n        - Run all coroutines concurrently using asyncio.gather.\n        - If timeout is specified, use asyncio.wait_for to enforce the timeout\n          around the gather call.\n        - Return the list of results.\n\n    Examples:\n        async def make_value(v):\n            await asyncio.sleep(0.01)\n            return v\n\n        results = await async_gather_results([\n            lambda: make_value(1),\n            lambda: make_value(2),\n            lambda: make_value(3)\n        ])\n        # results -> [1, 2, 3]\n\n        # With timeout (this would raise asyncio.TimeoutError if too slow):\n        results = await async_gather_results(\n            [lambda: make_value(42)],\n            timeout=5.0\n        )\n        # results -> [42]\n    \"\"\"\n    coroutines = [callable_() for callable_ in async_callables]\n    \n    if timeout is not None:\n        return await asyncio.wait_for(asyncio.gather(*coroutines), timeout=timeout)\n    else:\n        return await asyncio.gather(*coroutines)",
    "stdout": "",
    "stderr": "/tmp/tmpr5mox0px.py:60: DeprecationWarning: There is no current event loop\n  self.loop = asyncio.get_event_loop()\n...........\n----------------------------------------------------------------------\nRan 11 tests in 0.264s\n\nOK\n"
  },
  {
    "id": "ds_001",
    "category": "data_structures",
    "difficulty": "easy",
    "title": "Two Sum",
    "passed": true,
    "error": null,
    "generated_code": "def two_sum(nums: list, target: int) -> list:\n    \"\"\"\n    Given a list of integers and a target integer, return the indices of the\n    two numbers that add up to the target.\n\n    Assumptions:\n    - Each input has exactly one solution.\n    - You may not use the same element twice.\n    - Return the indices in ascending order.\n\n    Examples:\n        two_sum([2, 7, 11, 15], 9) -> [0, 1]\n        two_sum([3, 2, 4], 6) -> [1, 2]\n        two_sum([3, 3], 6) -> [0, 1]\n    \"\"\"\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return sorted([seen[complement], i])\n        seen[num] = i\n    # According to the problem assumptions, this line should never be reached\n    raise ValueError(\"No solution found\")",
    "stdout": "",
    "stderr": "........\n----------------------------------------------------------------------\nRan 8 tests in 0.000s\n\nOK\n"
  },
  {
    "id": "ds_002",
    "category": "data_structures",
    "difficulty": "easy",
    "title": "Reverse Linked List",
    "passed": true,
    "error": null,
    "generated_code": "def reverse_linked_list(values: list) -> list:\n    \"\"\"\n    Given a list of values representing a singly linked list (head to tail),\n    return a new list with the values in reversed order.\n\n    This simulates reversing a linked list using list representation.\n    You should implement the reversal logic iteratively, simulating\n    pointer manipulation (not just using built-in reverse).\n\n    Examples:\n        reverse_linked_list([1, 2, 3, 4, 5]) -> [5, 4, 3, 2, 1]\n        reverse_linked_list([1]) -> [1]\n        reverse_linked_list([]) -> []\n    \"\"\"\n    # Simulate iterative linked list reversal using three pointers:\n    # prev, current, and next_node. We'll build the reversed list by\n    # prepending each node's value as we traverse.\n\n    prev = None\n    current = 0\n    n = len(values)\n    reversed_values = []\n\n    # First pass: simulate traversal and collect values in reverse order\n    # by iterating from head to tail and prepending each value.\n    while current < n:\n        # Save next index\n        next_index = current + 1\n\n        # Prepend current value to the front of reversed_values\n        # This simulates changing the next pointer to point to previous node\n        reversed_values.insert(0, values[current])\n\n        # Move to next node\n        current = next_index\n\n    return reversed_values",
    "stdout": "",
    "stderr": "........\n----------------------------------------------------------------------\nRan 8 tests in 0.000s\n\nOK\n"
  },
  {
    "id": "ds_003",
    "category": "data_structures",
    "difficulty": "medium",
    "title": "LRU Cache",
    "passed": true,
    "error": null,
    "generated_code": "from collections import OrderedDict\n\nclass LRUCache:\n    \"\"\"\n    Implement a Least Recently Used (LRU) Cache.\n\n    The cache has a fixed capacity. When the cache is full and a new key\n    is inserted, the least recently used key is evicted.\n\n    Both get and put operations count as \"using\" a key.\n\n    Methods:\n        __init__(capacity: int) - Initialize the cache with positive capacity.\n        get(key: int) -> int - Return the value if key exists, otherwise -1.\n        put(key: int, value: int) -> None - Insert or update the key-value pair.\n\n    Example:\n        cache = LRUCache(2)\n        cache.put(1, 1)\n        cache.put(2, 2)\n        cache.get(1)       # returns 1\n        cache.put(3, 3)    # evicts key 2\n        cache.get(2)       # returns -1 (not found)\n        cache.get(3)       # returns 3\n    \"\"\"\n\n    def __init__(self, capacity: int):\n        if capacity <= 0:\n            raise ValueError(\"Capacity must be a positive integer.\")\n        self.capacity = capacity\n        self.cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        # Move the accessed key to the end to mark it as recently used\n        self.cache.move_to_end(key)\n        return self.cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            # Update existing key and move it to the end\n            self.cache.move_to_end(key)\n        self.cache[key] = value\n        if len(self.cache) > self.capacity:\n            # Pop the first item (least recently used)\n            self.cache.popitem(last=False)",
    "stdout": "",
    "stderr": ".......\n----------------------------------------------------------------------\nRan 7 tests in 0.000s\n\nOK\n"
  },
  {
    "id": "ds_004",
    "category": "data_structures",
    "difficulty": "medium",
    "title": "Group Anagrams",
    "passed": true,
    "error": null,
    "generated_code": "def group_anagrams(strs: list) -> list:\n    \"\"\"\n    Given a list of strings, group the anagrams together.\n    Return a list of groups, where each group is a sorted list of anagram strings.\n    The groups themselves should be sorted by their first element.\n\n    Two strings are anagrams if they contain the same characters with the\n    same frequencies, regardless of order.\n\n    Examples:\n        group_anagrams([\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"])\n        -> [[\"ate\", \"eat\", \"tea\"], [\"bat\"], [\"nat\", \"tan\"]]\n\n        group_anagrams([\"\"]) -> [[\"\"]]\n        group_anagrams([\"a\"]) -> [[\"a\"]]\n    \"\"\"\n    from collections import defaultdict\n\n    anagram_groups = defaultdict(list)\n\n    for s in strs:\n        key = ''.join(sorted(s))\n        anagram_groups[key].append(s)\n\n    result = []\n    for group in anagram_groups.values():\n        sorted_group = sorted(group)\n        result.append(sorted_group)\n\n    result.sort(key=lambda x: x[0])\n\n    return result",
    "stdout": "",
    "stderr": ".........\n----------------------------------------------------------------------\nRan 9 tests in 0.000s\n\nOK\n"
  },
  {
    "id": "ds_005",
    "category": "data_structures",
    "difficulty": "hard",
    "title": "Merge K Sorted Lists",
    "passed": true,
    "error": null,
    "generated_code": "import heapq\n\ndef merge_k_sorted(lists: list) -> list:\n    \"\"\"\n    Merge k sorted lists into one sorted list.\n\n    Use a min-heap for efficient merging. Each input list is sorted\n    in ascending order. Return a single sorted list containing all elements.\n\n    Examples:\n        merge_k_sorted([[1, 4, 5], [1, 3, 4], [2, 6]])\n        -> [1, 1, 2, 3, 4, 4, 5, 6]\n\n        merge_k_sorted([]) -> []\n        merge_k_sorted([[], []]) -> []\n        merge_k_sorted([[1]]) -> [1]\n    \"\"\"\n    if not lists:\n        return []\n\n    min_heap = []\n    result = []\n\n    # Initialize the heap with the first element of each non-empty list\n    for i, lst in enumerate(lists):\n        if lst:\n            heapq.heappush(min_heap, (lst[0], i, 0))\n\n    while min_heap:\n        val, list_idx, elem_idx = heapq.heappop(min_heap)\n        result.append(val)\n\n        # If there's a next element in the same list, push it to the heap\n        next_elem_idx = elem_idx + 1\n        if next_elem_idx < len(lists[list_idx]):\n            next_val = lists[list_idx][next_elem_idx]\n            heapq.heappush(min_heap, (next_val, list_idx, next_elem_idx))\n\n    return result",
    "stdout": "",
    "stderr": "...........\n----------------------------------------------------------------------\nRan 11 tests in 0.001s\n\nOK\n"
  },
  {
    "id": "exc_001",
    "category": "exceptions",
    "difficulty": "easy",
    "title": "Safe Divide",
    "passed": true,
    "error": null,
    "generated_code": "def safe_divide(a, b):\n    \"\"\"Divide a by b safely.\n\n    Args:\n        a: The numerator.\n        b: The denominator.\n\n    Returns:\n        The result of a / b, or None if b is zero.\n\n    Raises:\n        TypeError: If either a or b is not a number (int or float).\n    \"\"\"\n    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):\n        raise TypeError(\"Both arguments must be numbers (int or float).\")\n    \n    if b == 0:\n        return None\n    \n    return a / b",
    "stdout": "",
    "stderr": ".............\n----------------------------------------------------------------------\nRan 13 tests in 0.000s\n\nOK\n"
  },
  {
    "id": "exc_002",
    "category": "exceptions",
    "difficulty": "medium",
    "title": "Retry Decorator",
    "passed": true,
    "error": null,
    "generated_code": "import time\nimport functools\n\n\ndef retry(max_attempts=3, exceptions=(Exception,), delay=0):\n    \"\"\"A decorator that retries a function on failure.\n\n    Args:\n        max_attempts (int): Maximum number of attempts (including the first call).\n            Must be >= 1.\n        exceptions (tuple): A tuple of exception types to catch and retry on.\n            Any other exception types should propagate immediately.\n        delay (float): Seconds to wait between retries. Defaults to 0.\n\n    Returns:\n        A decorator that wraps the target function with retry logic.\n\n    Behavior:\n        - Call the decorated function. If it succeeds, return its result.\n        - If it raises one of the specified exception types and attempts remain,\n          wait `delay` seconds, then retry.\n        - If all attempts are exhausted, raise the last exception.\n        - The decorator should preserve the original function's name and docstring\n          (use functools.wraps).\n    \"\"\"\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            last_exception = None\n            for attempt in range(max_attempts):\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    last_exception = e\n                    if attempt < max_attempts - 1:\n                        if delay > 0:\n                            time.sleep(delay)\n                    else:\n                        raise last_exception\n            # This line should theoretically never be reached due to the raise above,\n            # but included for completeness in case max_attempts < 1 (though spec says >= 1)\n            if last_exception is not None:\n                raise last_exception\n        return wrapper\n    return decorator",
    "stdout": "",
    "stderr": "..........\n----------------------------------------------------------------------\nRan 10 tests in 0.101s\n\nOK\n"
  },
  {
    "id": "exc_003",
    "category": "exceptions",
    "difficulty": "hard",
    "title": "Custom Exception Hierarchy and Schema Validation",
    "passed": false,
    "error": null,
    "generated_code": "import re\n\n\nclass ValidationError(Exception):\n    \"\"\"Base exception for validation errors.\n\n    Attributes:\n        field (str): The name of the field that failed validation.\n        message (str): A human-readable error message.\n    \"\"\"\n\n\nclass TypeValidationError(ValidationError):\n    \"\"\"Raised when a field has the wrong type.\n\n    Attributes:\n        field (str): The field name.\n        expected_type (type): The expected type.\n        actual_type (type): The actual type received.\n    \"\"\"\n\n\nclass RangeValidationError(ValidationError):\n    \"\"\"Raised when a numeric field is out of range.\n\n    Attributes:\n        field (str): The field name.\n        value: The actual value.\n        min_value: The minimum allowed value (or None).\n        max_value: The maximum allowed value (or None).\n    \"\"\"\n\n\nclass PatternValidationError(ValidationError):\n    \"\"\"Raised when a string field does not match a regex pattern.\n\n    Attributes:\n        field (str): The field name.\n        pattern (str): The regex pattern that was expected.\n        value (str): The actual string value.\n    \"\"\"\n\n\ndef validate_data(schema, data):\n    \"\"\"Validate data against a schema, raising appropriate exceptions.\n\n    Args:\n        schema (dict): A dict mapping field names to rule dicts. Each rule dict\n            can have:\n            - 'type' (type): required type (e.g., int, str, float)\n            - 'min' (number): minimum value (only for numeric types)\n            - 'max' (number): maximum value (only for numeric types)\n            - 'pattern' (str): regex pattern the string must match fully\n            - 'required' (bool): if True, field must exist in data (default True)\n\n        data (dict): The data to validate.\n\n    Raises:\n        TypeValidationError: if a field has the wrong type.\n        RangeValidationError: if a numeric field is out of range.\n        PatternValidationError: if a string field doesn't match the pattern.\n        ValidationError: if a required field is missing.\n\n    Returns:\n        True if all validations pass.\n\n    Note:\n        Validate fields in the order they appear in the schema.\n        Raise on the first validation failure (do not collect all errors).\n    \"\"\"\n    for field, rules in schema.items():\n        required = rules.get('required', True)\n        \n        # Check if field exists\n        if field not in data:\n            if required:\n                raise ValidationError(field=field, message=f\"Missing required field: {field}\")\n            else:\n                continue\n        \n        value = data[field]\n        \n        # Type check\n        if 'type' in rules:\n            expected_type = rules['type']\n            if not isinstance(value, expected_type):\n                raise TypeValidationError(\n                    field=field,\n                    expected_type=expected_type,\n                    actual_type=type(value)\n                )\n        \n        # Range check (only for numeric types)\n        if 'min' in rules or 'max' in rules:\n            min_val = rules.get('min')\n            max_val = rules.get('max')\n            \n            if min_val is not None and value < min_val:\n                raise RangeValidationError(\n                    field=field,\n                    value=value,\n                    min_value=min_val,\n                    max_value=max_val\n                )\n            \n            if max_val is not None and value > max_val:\n                raise RangeValidationError(\n                    field=field,\n                    value=value,\n                    min_value=min_val,\n                    max_value=max_val\n                )\n        \n        # Pattern check (only for strings)\n        if 'pattern' in rules:\n            pattern = rules['pattern']\n            if not re.fullmatch(pattern, value):\n                raise PatternValidationError(\n                    field=field,\n                    pattern=pattern,\n                    value=value\n                )\n    \n    return True",
    "stdout": "",
    "stderr": "EE.E.E.E.EE...E.E.EE.EEE.EE\n======================================================================\nERROR: test_catch_by_base_class (__main__.TestExceptionHierarchy.test_catch_by_base_class)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/tmp/tmpk5vw9nws.py\", line 171, in test_catch_by_base_class\n    raise RangeValidationError('x', -1, min_value=0)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nTypeError: RangeValidationError() takes no keyword arguments\n\n======================================================================\nERROR: test_pattern_validation_error_attributes (__main__.TestExceptionHierarchy.test_pattern_validation_error_attributes)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/tmp/tmpk5vw9nws.py\", line 163, in test_pattern_validation_error_attributes\n    self.assertEqual(e.field, 'email')\n                     ^^^^^^^\nAttributeError: 'PatternValidationError' object has no attribute 'field'\n\n======================================================================\nERROR: test_range_validation_error_attributes (__main__.TestExceptionHierarchy.test_range_validation_error_attributes)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/tmp/tmpk5vw9nws.py\", line 155, in test_range_validation_error_attributes\n    e = RangeValidationError('age', -5, min_value=0, max_value=200)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nTypeError: RangeValidationError() takes no keyword arguments\n\n======================================================================\nERROR: test_type_validation_error_attributes (__main__.TestExceptionHierarchy.test_type_validation_error_attributes)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/tmp/tmpk5vw9nws.py\", line 150, in test_type_validation_error_attributes\n    self.assertEqual(e.field, 'age')\n                     ^^^^^^^\nAttributeError: 'TypeValidationError' object has no attribute 'field'\n\n======================================================================\nERROR: test_validation_error_attributes (__main__.TestExceptionHierarchy.test_validation_error_attributes)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/tmp/tmpk5vw9nws.py\", line 145, in test_validation_error_attributes\n    self.assertEqual(e.field, 'name')\n                     ^^^^^^^\nAttributeError: 'ValidationError' object has no attribute 'field'\n\n======================================================================\nERROR: test_above_max_raises_range_error (__main__.TestValidateData.test_above_max_raises_range_error)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/tmp/tmpk5vw9nws.py\", line 218, in test_above_max_raises_range_error\n    validate_data(schema, {'score': 101})\n  File \"/tmp/tmpk5vw9nws.py\", line 107, in validate_data\n    raise RangeValidationError(\n          ^^^^^^^^^^^^^^^^^^^^^\nTypeError: RangeValidationError() takes no keyword arguments\n\n======================================================================\nERROR: test_below_min_raises_range_error (__main__.TestValidateData.test_below_min_raises_range_error)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/tmp/tmpk5vw9nws.py\", line 211, in test_below_min_raises_range_error\n    validate_data(schema, {'score': -1})\n  File \"/tmp/tmpk5vw9nws.py\", line 99, in validate_data\n    raise RangeValidationError(\n          ^^^^^^^^^^^^^^^^^^^^^\nTypeError: RangeValidationError() takes no keyword arguments\n\n======================================================================\nERROR: test_default_required_is_true (__main__.TestValidateData.test_default_required_is_true)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/tmp/tmpk5vw9nws.py\", line 198, in test_default_required_is_true\n    validate_data(schema, {})\n  File \"/tmp/tmpk5vw9nws.py\", line 77, in validate_data\n    raise ValidationError(field=field, message=f\"Missing required field: {field}\")\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nTypeError: ValidationError() takes no keyword arguments\n\n======================================================================\nERROR: test_float_range (__main__.TestValidateData.test_float_range)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/tmp/tmpk5vw9nws.py\", line 273, in test_float_range\n    validate_data(schema, {'rating': 5.1})\n  File \"/tmp/tmpk5vw9nws.py\", line 107, in validate_data\n    raise RangeValidationError(\n          ^^^^^^^^^^^^^^^^^^^^^\nTypeError: RangeValidationError() takes no keyword arguments\n\n======================================================================\nERROR: test_missing_required_field (__main__.TestValidateData.test_missing_required_field)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/tmp/tmpk5vw9nws.py\", line 188, in test_missing_required_field\n    validate_data(schema, {})\n  File \"/tmp/tmpk5vw9nws.py\", line 77, in validate_data\n    raise ValidationError(field=field, message=f\"Missing required field: {field}\")\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nTypeError: ValidationError() takes no keyword arguments\n\n======================================================================\nERROR: test_pattern_fullmatch (__main__.TestValidateData.test_pattern_fullmatch)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/tmp/tmpk5vw9nws.py\", line 279, in test_pattern_fullmatch\n    validate_data(schema, {'code': '1234'})\n  File \"/tmp/tmpk5vw9nws.py\", line 118, in validate_data\n    raise PatternValidationError(\n          ^^^^^^^^^^^^^^^^^^^^^^^\nTypeError: PatternValidationError() takes no keyword arguments\n\n======================================================================\nERROR: test_pattern_no_match_raises (__main__.TestValidateData.test_pattern_no_match_raises)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/tmp/tmpk5vw9nws.py\", line 229, in test_pattern_no_match_raises\n    validate_data(schema, {'email': 'bad-email'})\n  File \"/tmp/tmpk5vw9nws.py\", line 118, in validate_data\n    raise PatternValidationError(\n          ^^^^^^^^^^^^^^^^^^^^^^^\nTypeError: PatternValidationError() takes no keyword arguments\n\n======================================================================\nERROR: test_type_checked_before_pattern (__main__.TestValidateData.test_type_checked_before_pattern)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/tmp/tmpk5vw9nws.py\", line 249, in test_type_checked_before_pattern\n    validate_data(schema, {'code': 123})\n  File \"/tmp/tmpk5vw9nws.py\", line 87, in validate_data\n    raise TypeValidationError(\n          ^^^^^^^^^^^^^^^^^^^^\nTypeError: TypeValidationError() takes no keyword arguments\n\n======================================================================\nERROR: test_type_checked_before_range (__main__.TestValidateData.test_type_checked_before_range)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/tmp/tmpk5vw9nws.py\", line 244, in test_type_checked_before_range\n    validate_data(schema, {'age': 'twenty'})\n  File \"/tmp/tmpk5vw9nws.py\", line 87, in validate_data\n    raise TypeValidationError(\n          ^^^^^^^^^^^^^^^^^^^^\nTypeError: TypeValidationError() takes no keyword arguments\n\n======================================================================\nERROR: test_validates_in_schema_order (__main__.TestValidateData.test_validates_in_schema_order)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/tmp/tmpk5vw9nws.py\", line 257, in test_validates_in_schema_order\n    validate_data(schema, {'second': 'wrong'})\n  File \"/tmp/tmpk5vw9nws.py\", line 77, in validate_data\n    raise ValidationError(field=field, message=f\"Missing required field: {field}\")\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nTypeError: ValidationError() takes no keyword arguments\n\n======================================================================\nERROR: test_wrong_type_raises_type_error (__main__.TestValidateData.test_wrong_type_raises_type_error)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/tmp/tmpk5vw9nws.py\", line 203, in test_wrong_type_raises_type_error\n    validate_data(schema, {'age': '30'})\n  File \"/tmp/tmpk5vw9nws.py\", line 87, in validate_data\n    raise TypeValidationError(\n          ^^^^^^^^^^^^^^^^^^^^\nTypeError: TypeValidationError() takes no keyword arguments\n\n----------------------------------------------------------------------\nRan 27 tests in 0.005s\n\nFAILED (errors=16)\n"
  },
  {
    "id": "fio_001",
    "category": "file_io",
    "difficulty": "easy",
    "title": "Read CSV Data",
    "passed": true,
    "error": null,
    "generated_code": "import csv\nimport io\n\ndef read_csv_data(csv_string: str) -> list:\n    \"\"\"\n    Parse a CSV-formatted string into a list of dictionaries.\n\n    The first row of the CSV string contains the headers, which become\n    the dictionary keys. Each subsequent row becomes a dictionary with\n    values mapped to the corresponding headers.\n\n    Use the csv module for parsing. Handle quoted fields correctly.\n\n    Args:\n        csv_string: A string containing CSV-formatted data\n\n    Returns:\n        A list of dictionaries, one per data row\n\n    Examples:\n        read_csv_data('name,age\\nAlice,30\\nBob,25')\n        -> [{'name': 'Alice', 'age': '30'}, {'name': 'Bob', 'age': '25'}]\n\n        read_csv_data('a,b\\n1,2')\n        -> [{'a': '1', 'b': '2'}]\n    \"\"\"\n    f = io.StringIO(csv_string)\n    reader = csv.DictReader(f)\n    return list(reader)",
    "stdout": "",
    "stderr": "........\n----------------------------------------------------------------------\nRan 8 tests in 0.001s\n\nOK\n"
  },
  {
    "id": "fio_002",
    "category": "file_io",
    "difficulty": "medium",
    "title": "Merge JSON Files",
    "passed": true,
    "error": null,
    "generated_code": "import json\n\ndef merge_json_files(json_strings: list) -> dict:\n    \"\"\"\n    Merge a list of JSON strings into a single dictionary.\n\n    Each JSON string represents a dictionary. Merge them left to right so\n    that later values override earlier ones for the same keys. For nested\n    dictionaries, perform a deep merge: if both the existing and new values\n    for a key are dicts, merge them recursively instead of replacing.\n\n    Non-dict values always override (even if the existing value is a dict).\n\n    Args:\n        json_strings: A list of strings, each a valid JSON object\n\n    Returns:\n        A single merged dictionary\n\n    Examples:\n        merge_json_files(['{\"a\": 1}', '{\"b\": 2}'])\n        -> {'a': 1, 'b': 2}\n\n        merge_json_files(['{\"a\": 1}', '{\"a\": 2}'])\n        -> {'a': 2}\n\n        merge_json_files(['{\"x\": {\"a\": 1, \"b\": 2}}', '{\"x\": {\"b\": 3, \"c\": 4}}'])\n        -> {'x': {'a': 1, 'b': 3, 'c': 4}}\n    \"\"\"\n    def deep_merge(base: dict, override: dict) -> dict:\n        result = base.copy()\n        for key, value in override.items():\n            if (\n                key in result\n                and isinstance(result[key], dict)\n                and isinstance(value, dict)\n            ):\n                result[key] = deep_merge(result[key], value)\n            else:\n                result[key] = value\n        return result\n\n    merged = {}\n    for json_str in json_strings:\n        data = json.loads(json_str)\n        if not isinstance(data, dict):\n            raise ValueError(\"Each JSON string must represent a dictionary.\")\n        merged = deep_merge(merged, data)\n\n    return merged",
    "stdout": "",
    "stderr": "...........\n----------------------------------------------------------------------\nRan 11 tests in 0.001s\n\nOK\n"
  },
  {
    "id": "fio_003",
    "category": "file_io",
    "difficulty": "hard",
    "title": "Log Parser",
    "passed": true,
    "error": null,
    "generated_code": "import re\n\ndef log_parser(log_lines: list) -> dict:\n    \"\"\"\n    Parse a list of log line strings and extract structured information.\n\n    Each log line is in the format:\n        [TIMESTAMP] LEVEL: message\n    where TIMESTAMP is in 'YYYY-MM-DD HH:MM:SS' format and LEVEL is one\n    of DEBUG, INFO, WARNING, ERROR, CRITICAL.\n\n    Returns a dictionary with:\n        - 'counts': dict mapping each log level to its count\n        - 'errors': list of message strings from ERROR and CRITICAL lines\n          (in order of appearance)\n        - 'timestamp_range': tuple of (earliest, latest) timestamp strings,\n          or None if no log lines are provided\n\n    Args:\n        log_lines: List of log line strings\n\n    Returns:\n        Dict with 'counts', 'errors', and 'timestamp_range' keys\n\n    Examples:\n        log_parser(['[2024-01-15 10:30:45] ERROR: Connection failed',\n                     '[2024-01-15 10:31:00] INFO: Retrying'])\n        -> {\n            'counts': {'ERROR': 1, 'INFO': 1},\n            'errors': ['Connection failed'],\n            'timestamp_range': ('2024-01-15 10:30:45', '2024-01-15 10:31:00')\n        }\n    \"\"\"\n    pattern = re.compile(\n        r'^\\[(\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2})\\] (DEBUG|INFO|WARNING|ERROR|CRITICAL): (.*)$'\n    )\n    \n    counts = {}\n    errors = []\n    timestamps = []\n    \n    for line in log_lines:\n        match = pattern.match(line)\n        if match:\n            timestamp, level, message = match.groups()\n            \n            # Update counts\n            counts[level] = counts.get(level, 0) + 1\n            \n            # Collect error messages\n            if level in ('ERROR', 'CRITICAL'):\n                errors.append(message)\n            \n            # Collect timestamps\n            timestamps.append(timestamp)\n    \n    # Determine timestamp range\n    timestamp_range = None\n    if timestamps:\n        timestamps_sorted = sorted(timestamps)\n        timestamp_range = (timestamps_sorted[0], timestamps_sorted[-1])\n    \n    return {\n        'counts': counts,\n        'errors': errors,\n        'timestamp_range': timestamp_range\n    }",
    "stdout": "",
    "stderr": "..........\n----------------------------------------------------------------------\nRan 10 tests in 0.001s\n\nOK\n"
  },
  {
    "id": "fn_001",
    "category": "functional",
    "difficulty": "easy",
    "title": "Apply Pipeline",
    "passed": true,
    "error": null,
    "generated_code": "def apply_pipeline(value, functions: list):\n    \"\"\"\n    Given an initial value and a list of single-argument functions,\n    apply each function in sequence (left to right) to the value,\n    passing the result of each function as input to the next.\n    Return the final result.\n\n    If the functions list is empty, return the original value.\n\n    Examples:\n        apply_pipeline(5, [lambda x: x + 1, lambda x: x * 2]) -> 12\n        apply_pipeline(\"hello\", [str.upper, lambda s: s + \"!\"]) -> \"HELLO!\"\n        apply_pipeline(10, []) -> 10\n        apply_pipeline(-3, [abs, lambda x: x ** 2]) -> 9\n    \"\"\"\n    result = value\n    for func in functions:\n        result = func(result)\n    return result",
    "stdout": "",
    "stderr": "..........\n----------------------------------------------------------------------\nRan 10 tests in 0.000s\n\nOK\n"
  },
  {
    "id": "fn_002",
    "category": "functional",
    "difficulty": "medium",
    "title": "Memoize Decorator",
    "passed": true,
    "error": null,
    "generated_code": "def memoize(func):\n    \"\"\"\n    Implement a memoize decorator that caches the results of function calls.\n    If the function is called again with the same positional arguments,\n    return the cached result instead of recomputing.\n\n    Assume all arguments are hashable (can be used as dict keys via tuple).\n    Only positional arguments need to be supported (no kwargs).\n\n    The decorated function should also have a .cache attribute that is\n    the dictionary used for caching (mapping argument tuples to results).\n\n    Examples:\n        @memoize\n        def add(a, b):\n            return a + b\n\n        add(1, 2)  # computes and caches\n        add(1, 2)  # returns cached result\n        add.cache  # {(1, 2): 3}\n    \"\"\"\n    cache = {}\n\n    def wrapper(*args):\n        if args not in cache:\n            cache[args] = func(*args)\n        return cache[args]\n\n    wrapper.cache = cache\n    return wrapper",
    "stdout": "",
    "stderr": "........\n----------------------------------------------------------------------\nRan 8 tests in 0.000s\n\nOK\n"
  },
  {
    "id": "fn_003",
    "category": "functional",
    "difficulty": "medium",
    "title": "Group By",
    "passed": true,
    "error": null,
    "generated_code": "def group_by(items: list, key_func) -> dict:\n    \"\"\"\n    Group elements of a list by the result of applying key_func to each element.\n    Return a dictionary where keys are the results of key_func and values are\n    lists of items that produced that key, in their original order.\n\n    Examples:\n        group_by([1, 2, 3, 4, 5, 6], lambda x: x % 2 == 0)\n        # -> {False: [1, 3, 5], True: [2, 4, 6]}\n\n        group_by([\"apple\", \"banana\", \"avocado\", \"blueberry\"], lambda s: s[0])\n        # -> {\"a\": [\"apple\", \"avocado\"], \"b\": [\"banana\", \"blueberry\"]}\n\n        group_by([], lambda x: x)\n        # -> {}\n\n        group_by([1, 2, 3, 4, 5], lambda x: \"even\" if x % 2 == 0 else \"odd\")\n        # -> {\"odd\": [1, 3, 5], \"even\": [2, 4]}\n    \"\"\"\n    result = {}\n    for item in items:\n        key = key_func(item)\n        if key not in result:\n            result[key] = []\n        result[key].append(item)\n    return result",
    "stdout": "",
    "stderr": "..........\n----------------------------------------------------------------------\nRan 10 tests in 0.000s\n\nOK\n"
  },
  {
    "id": "fn_004",
    "category": "functional",
    "difficulty": "hard",
    "title": "Lazy Evaluation",
    "passed": true,
    "error": null,
    "generated_code": "class Lazy:\n    \"\"\"\n    A lazy evaluation class that wraps an iterable and supports chaining\n    map and filter operations. Operations are NOT executed until\n    .evaluate() is called.\n\n    Methods:\n        __init__(self, iterable): Store the iterable and initialize an empty\n            list of pending operations.\n        map(self, func): Register a map operation. Returns self for chaining.\n        filter(self, predicate): Register a filter operation. Returns self for chaining.\n        evaluate(self): Execute all registered operations in order on the\n            iterable and return the result as a list.\n\n    The Lazy object should be reusable - after calling evaluate(), the\n    pending operations are cleared but the original iterable is preserved,\n    so new chains can be built.\n\n    Examples:\n        Lazy([1, 2, 3, 4, 5]).filter(lambda x: x % 2 == 0).map(lambda x: x * 10).evaluate()\n        # -> [20, 40]\n\n        lazy = Lazy(range(10))\n        lazy.map(lambda x: x ** 2).filter(lambda x: x > 10).evaluate()\n        # -> [16, 25, 36, 49, 64, 81]\n\n        Lazy([]).evaluate()  # -> []\n    \"\"\"\n\n    def __init__(self, iterable):\n        self._iterable = iterable\n        self._operations = []\n\n    def map(self, func):\n        self._operations.append(('map', func))\n        return self\n\n    def filter(self, predicate):\n        self._operations.append(('filter', predicate))\n        return self\n\n    def evaluate(self):\n        result = list(self._iterable)\n        for op_type, func in self._operations:\n            if op_type == 'map':\n                result = [func(item) for item in result]\n            elif op_type == 'filter':\n                result = [item for item in result if func(item)]\n        self._operations = []\n        return result",
    "stdout": "",
    "stderr": "..............\n----------------------------------------------------------------------\nRan 14 tests in 0.001s\n\nOK\n"
  },
  {
    "id": "oop_001",
    "category": "oop",
    "difficulty": "easy",
    "title": "Stack Class",
    "passed": true,
    "error": null,
    "generated_code": "class Stack:\n    \"\"\"A stack data structure with standard operations.\n\n    Methods:\n        push(item): Add an item to the top of the stack.\n        pop(): Remove and return the top item. Raise IndexError if empty.\n        peek(): Return the top item without removing it. Raise IndexError if empty.\n        is_empty(): Return True if the stack is empty, False otherwise.\n        size(): Return the number of items in the stack.\n    \"\"\"\n\n    def __init__(self):\n        self._items = []\n\n    def push(self, item):\n        \"\"\"Add an item to the top of the stack.\"\"\"\n        self._items.append(item)\n\n    def pop(self):\n        \"\"\"Remove and return the top item. Raise IndexError if empty.\"\"\"\n        if self.is_empty():\n            raise IndexError(\"pop from empty stack\")\n        return self._items.pop()\n\n    def peek(self):\n        \"\"\"Return the top item without removing it. Raise IndexError if empty.\"\"\"\n        if self.is_empty():\n            raise IndexError(\"peek from empty stack\")\n        return self._items[-1]\n\n    def is_empty(self):\n        \"\"\"Return True if the stack is empty, False otherwise.\"\"\"\n        return len(self._items) == 0\n\n    def size(self):\n        \"\"\"Return the number of items in the stack.\"\"\"\n        return len(self._items)",
    "stdout": "",
    "stderr": "........\n----------------------------------------------------------------------\nRan 8 tests in 0.000s\n\nOK\n"
  },
  {
    "id": "oop_002",
    "category": "oop",
    "difficulty": "medium",
    "title": "Shape Hierarchy with Abstract Base Class",
    "passed": true,
    "error": null,
    "generated_code": "from abc import ABC, abstractmethod\nimport math\n\n\nclass Shape(ABC):\n    \"\"\"Abstract base class for shapes.\n\n    Abstract Methods:\n        area() -> float: Return the area of the shape.\n        perimeter() -> float: Return the perimeter of the shape.\n    \"\"\"\n\n    @abstractmethod\n    def area(self) -> float:\n        pass\n\n    @abstractmethod\n    def perimeter(self) -> float:\n        pass\n\n\nclass Circle(Shape):\n    \"\"\"A circle defined by its radius.\n\n    Args:\n        radius (float): The radius of the circle. Must be positive.\n            Raise ValueError if radius <= 0.\n    \"\"\"\n\n    def __init__(self, radius: float):\n        if radius <= 0:\n            raise ValueError(\"Radius must be positive.\")\n        self.radius = radius\n\n    def area(self) -> float:\n        return math.pi * self.radius ** 2\n\n    def perimeter(self) -> float:\n        return 2 * math.pi * self.radius\n\n\nclass Rectangle(Shape):\n    \"\"\"A rectangle defined by width and height.\n\n    Args:\n        width (float): The width of the rectangle. Must be positive.\n        height (float): The height of the rectangle. Must be positive.\n            Raise ValueError if width or height <= 0.\n    \"\"\"\n\n    def __init__(self, width: float, height: float):\n        if width <= 0 or height <= 0:\n            raise ValueError(\"Width and height must be positive.\")\n        self.width = width\n        self.height = height\n\n    def area(self) -> float:\n        return self.width * self.height\n\n    def perimeter(self) -> float:\n        return 2 * (self.width + self.height)\n\n\ndef calculate_total_area(shapes):\n    \"\"\"Return the sum of areas of all shapes in the list.\n\n    Args:\n        shapes: A list of Shape instances.\n\n    Returns:\n        float: The total area.\n    \"\"\"\n    return sum(shape.area() for shape in shapes)",
    "stdout": "",
    "stderr": "...............\n----------------------------------------------------------------------\nRan 15 tests in 0.001s\n\nOK\n"
  },
  {
    "id": "oop_003",
    "category": "oop",
    "difficulty": "medium",
    "title": "BankAccount with Transaction History",
    "passed": false,
    "error": null,
    "generated_code": "class BankAccount:\n    \"\"\"A bank account with deposit, withdraw, transfer, and transaction history.\n\n    Args:\n        owner (str): The name of the account owner.\n        initial_balance (float): Starting balance. Defaults to 0.0.\n            Raise ValueError if initial_balance < 0.\n\n    Properties:\n        balance (float): The current balance (read-only property).\n\n    Methods:\n        deposit(amount) -> None:\n            Add amount to balance. Raise ValueError if amount <= 0.\n            Record transaction as ('deposit', amount) in history.\n\n        withdraw(amount) -> None:\n            Subtract amount from balance.\n            Raise ValueError if amount <= 0.\n            Raise ValueError if insufficient funds.\n            Record transaction as ('withdraw', amount) in history.\n\n        transfer_to(other_account, amount) -> None:\n            Withdraw amount from this account and deposit into other_account.\n            Raise ValueError if amount <= 0.\n            Raise ValueError if insufficient funds.\n            Record transaction as ('transfer_out', amount) in this account's history.\n            Record transaction as ('transfer_in', amount) in other account's history.\n\n        get_history() -> list:\n            Return a list of all transaction tuples in chronological order.\n    \"\"\"\n\n    def __init__(self, owner: str, initial_balance: float = 0.0):\n        if initial_balance < 0:\n            raise ValueError(\"Initial balance cannot be negative.\")\n        self._owner = owner\n        self._balance = initial_balance\n        self._history = []\n\n    @property\n    def balance(self) -> float:\n        return self._balance\n\n    def deposit(self, amount: float) -> None:\n        if amount <= 0:\n            raise ValueError(\"Deposit amount must be positive.\")\n        self._balance += amount\n        self._history.append(('deposit', amount))\n\n    def withdraw(self, amount: float) -> None:\n        if amount <= 0:\n            raise ValueError(\"Withdrawal amount must be positive.\")\n        if amount > self._balance:\n            raise ValueError(\"Insufficient funds.\")\n        self._balance -= amount\n        self._history.append(('withdraw', amount))\n\n    def transfer_to(self, other_account: 'BankAccount', amount: float) -> None:\n        if amount <= 0:\n            raise ValueError(\"Transfer amount must be positive.\")\n        if amount > self._balance:\n            raise ValueError(\"Insufficient funds.\")\n        self._balance -= amount\n        other_account._balance += amount\n        self._history.append(('transfer_out', amount))\n        other_account._history.append(('transfer_in', amount))\n\n    def get_history(self) -> list:\n        return list(self._history)",
    "stdout": "",
    "stderr": ".........E.......\n======================================================================\nERROR: test_initial_balance (__main__.TestBankAccount.test_initial_balance)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/tmp/tmptu_ib47z.py\", line 81, in test_initial_balance\n    self.assertEqual(self.account.owner, 'Alice')\n                     ^^^^^^^^^^^^^^^^^^\nAttributeError: 'BankAccount' object has no attribute 'owner'. Did you mean: '_owner'?\n\n----------------------------------------------------------------------\nRan 17 tests in 0.001s\n\nFAILED (errors=1)\n"
  },
  {
    "id": "oop_004",
    "category": "oop",
    "difficulty": "hard",
    "title": "EventEmitter - Observer Pattern",
    "passed": true,
    "error": null,
    "generated_code": "class EventEmitter:\n    \"\"\"An event emitter implementing the observer pattern.\n\n    Methods:\n        on(event: str, callback: callable) -> None:\n            Register a callback for the given event.\n            The same callback can be registered multiple times for the same event;\n            each registration counts separately.\n\n        off(event: str, callback: callable) -> None:\n            Remove one registration of callback for the given event.\n            If the callback is registered multiple times, only remove the first one.\n            If callback is not registered for this event, do nothing (no error).\n\n        emit(event: str, *args, **kwargs) -> None:\n            Call all registered callbacks for the event with the given arguments.\n            Callbacks are called in the order they were registered.\n            If no callbacks are registered for the event, do nothing.\n\n        once(event: str, callback: callable) -> None:\n            Register a callback that is automatically removed after it fires once.\n\n        listener_count(event: str) -> int:\n            Return the number of listeners registered for the given event.\n    \"\"\"\n\n    def __init__(self):\n        self._events = {}\n\n    def on(self, event: str, callback: callable) -> None:\n        if event not in self._events:\n            self._events[event] = []\n        self._events[event].append(callback)\n\n    def off(self, event: str, callback: callable) -> None:\n        if event not in self._events:\n            return\n        try:\n            self._events[event].remove(callback)\n        except ValueError:\n            pass\n\n    def emit(self, event: str, *args, **kwargs) -> None:\n        if event not in self._events:\n            return\n        # Copy the list to avoid issues if callbacks modify the listener list during emission\n        callbacks = self._events[event][:]\n        for callback in callbacks:\n            callback(*args, **kwargs)\n\n    def once(self, event: str, callback: callable) -> None:\n        def wrapper(*args, **kwargs):\n            self.off(event, wrapper)\n            callback(*args, **kwargs)\n\n        self.on(event, wrapper)\n\n    def listener_count(self, event: str) -> int:\n        return len(self._events.get(event, []))",
    "stdout": "",
    "stderr": "...............\n----------------------------------------------------------------------\nRan 15 tests in 0.001s\n\nOK\n"
  },
  {
    "id": "oop_005",
    "category": "oop",
    "difficulty": "hard",
    "title": "ValidatedField Descriptor",
    "passed": false,
    "error": null,
    "generated_code": "class ValidatedField:\n    \"\"\"A descriptor that validates field values on assignment.\n\n    Args:\n        field_type (type): The required type (e.g., int, float, str).\n        min_value (optional): Minimum value for numeric types. Ignored for non-numeric.\n        max_value (optional): Maximum value for numeric types. Ignored for non-numeric.\n        max_length (optional): Maximum length for str type. Ignored for non-str.\n\n    Behavior:\n        - On __set__, validate the value:\n            1. Check that isinstance(value, field_type). Raise TypeError if not.\n            2. If field_type is int or float and min_value is set, raise ValueError\n               if value < min_value.\n            3. If field_type is int or float and max_value is set, raise ValueError\n               if value > max_value.\n            4. If field_type is str and max_length is set, raise ValueError\n               if len(value) > max_length.\n        - On __get__, return the stored value (or raise AttributeError if not set).\n        - Use __set_name__ to capture the field name for storage.\n    \"\"\"\n\n    def __init__(self, field_type, min_value=None, max_value=None, max_length=None):\n        self.field_type = field_type\n        self.min_value = min_value\n        self.max_value = max_value\n        self.max_length = max_length\n        self.field_name = None\n\n    def __set_name__(self, owner, name):\n        self.field_name = name\n\n    def __get__(self, instance, owner):\n        if instance is None:\n            return self\n        if not hasattr(instance, f\"_validated_{self.field_name}\"):\n            raise AttributeError(f\"'{owner.__name__}' object has no attribute '{self.field_name}'\")\n        return getattr(instance, f\"_validated_{self.field_name}\")\n\n    def __set__(self, instance, value):\n        # Type check\n        if not isinstance(value, self.field_type):\n            raise TypeError(f\"Expected {self.field_type.__name__}, got {type(value).__name__}\")\n\n        # Numeric range checks\n        if self.field_type in (int, float):\n            if self.min_value is not None and value < self.min_value:\n                raise ValueError(f\"Value {value} is less than minimum {self.min_value}\")\n            if self.max_value is not None and value > self.max_value:\n                raise ValueError(f\"Value {value} is greater than maximum {self.max_value}\")\n\n        # String length check\n        if self.field_type is str and self.max_length is not None:\n            if len(value) > self.max_length:\n                raise ValueError(f\"String length {len(value)} exceeds maximum {self.max_length}\")\n\n        setattr(instance, f\"_validated_{self.field_name}\", value)\n\n\nclass Person:\n    \"\"\"A class using ValidatedField descriptors.\n\n    Fields:\n        name: ValidatedField(str, max_length=50)\n        age: ValidatedField(int, min_value=0, max_value=200)\n        email: ValidatedField(str, max_length=100)\n    \"\"\"\n\n    name = ValidatedField(str, max_length=50)\n    age = ValidatedField(int, min_value=0, max_value=200)\n    email = ValidatedField(str, max_length=100)",
    "stdout": "",
    "stderr": "EEEE..EEE.........\n======================================================================\nERROR: test_age_too_high (__main__.TestPerson.test_age_too_high)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/tmp/tmpbk_vmf2c.py\", line 177, in test_age_too_high\n    Person('Alice', 201, 'a@b.com')\nTypeError: Person() takes no arguments\n\n======================================================================\nERROR: test_age_too_low (__main__.TestPerson.test_age_too_low)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/tmp/tmpbk_vmf2c.py\", line 173, in test_age_too_low\n    Person('Alice', -1, 'a@b.com')\nTypeError: Person() takes no arguments\n\n======================================================================\nERROR: test_boundary_age (__main__.TestPerson.test_boundary_age)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/tmp/tmpbk_vmf2c.py\", line 195, in test_boundary_age\n    p = Person('Alice', 0, 'a@b.com')\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nTypeError: Person() takes no arguments\n\n======================================================================\nERROR: test_email_too_long (__main__.TestPerson.test_email_too_long)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/tmp/tmpbk_vmf2c.py\", line 185, in test_email_too_long\n    Person('Alice', 30, 'a' * 101)\nTypeError: Person() takes no arguments\n\n======================================================================\nERROR: test_name_too_long (__main__.TestPerson.test_name_too_long)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/tmp/tmpbk_vmf2c.py\", line 181, in test_name_too_long\n    Person('A' * 51, 30, 'a@b.com')\nTypeError: Person() takes no arguments\n\n======================================================================\nERROR: test_update_field (__main__.TestPerson.test_update_field)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/tmp/tmpbk_vmf2c.py\", line 188, in test_update_field\n    p = Person('Alice', 30, 'a@b.com')\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nTypeError: Person() takes no arguments\n\n======================================================================\nERROR: test_valid_person (__main__.TestPerson.test_valid_person)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/tmp/tmpbk_vmf2c.py\", line 158, in test_valid_person\n    p = Person('Alice', 30, 'alice@example.com')\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nTypeError: Person() takes no arguments\n\n----------------------------------------------------------------------\nRan 18 tests in 0.002s\n\nFAILED (errors=7)\n"
  },
  {
    "id": "std_001",
    "category": "stdlib",
    "difficulty": "easy",
    "title": "Count Words",
    "passed": true,
    "error": null,
    "generated_code": "from collections import Counter\n\ndef count_words(text: str) -> dict[str, int]:\n    \"\"\"Count the frequency of each word in a string.\n\n    Words are separated by whitespace. Counting is case-sensitive\n    (i.e., 'Hello' and 'hello' are different words).\n\n    Args:\n        text: A string of words separated by whitespace.\n\n    Returns:\n        A dictionary mapping each word to the number of times it appears.\n    \"\"\"\n    if not text:\n        return {}\n    \n    words = text.split()\n    return dict(Counter(words))",
    "stdout": "",
    "stderr": ".........\n----------------------------------------------------------------------\nRan 9 tests in 0.000s\n\nOK\n"
  },
  {
    "id": "std_002",
    "category": "stdlib",
    "difficulty": "easy",
    "title": "Parse Date",
    "passed": true,
    "error": null,
    "generated_code": "from datetime import datetime\n\ndef parse_date(date_str: str) -> str:\n    \"\"\"Parse a date string in 'YYYY-MM-DD' format and return the day of the week.\n\n    Args:\n        date_str: A date string in the format 'YYYY-MM-DD'.\n\n    Returns:\n        The day of the week as a full string, e.g. 'Monday', 'Tuesday', etc.\n    \"\"\"\n    date_obj = datetime.strptime(date_str, \"%Y-%m-%d\")\n    return date_obj.strftime(\"%A\")",
    "stdout": "",
    "stderr": "...........\n----------------------------------------------------------------------\nRan 11 tests in 0.003s\n\nOK\n"
  },
  {
    "id": "std_003",
    "category": "stdlib",
    "difficulty": "medium",
    "title": "Validate Email",
    "passed": false,
    "error": null,
    "generated_code": "import re\n\ndef validate_email(email: str) -> bool:\n    \"\"\"Validate an email address using regular expressions.\n\n    A valid email must satisfy:\n    - Local part (before @): one or more alphanumeric characters, dots,\n      underscores, or hyphens. Must not start or end with a dot/hyphen.\n    - Exactly one '@' symbol.\n    - Domain part (after @): one or more labels separated by dots.\n      Each label must be one or more alphanumeric characters or hyphens,\n      but must not start or end with a hyphen.\n    - The last domain label (TLD) must be at least 2 characters long\n      and consist of only alphabetic characters.\n\n    Args:\n        email: The email address string to validate.\n\n    Returns:\n        True if the email is valid, False otherwise.\n    \"\"\"\n    if not isinstance(email, str):\n        return False\n\n    # Pattern explanation:\n    # ^(?![.\\-])                 : Local part must not start with dot or hyphen\n    # (?:[a-zA-Z0-9._-]+)        : Local part characters\n    # (?<![.\\-])                 : Local part must not end with dot or hyphen\n    # @                          : Exactly one @\n    # (?:                        : Start of domain part\n    #   (?:[a-zA-Z0-9](?:[a-zA-Z0-9\\-]*[a-zA-Z0-9])?) : Domain label (no leading/trailing hyphen)\n    #   \\.                       : Dot separator\n    # )*                         : Zero or more intermediate labels\n    # (?:[a-zA-Z0-9](?:[a-zA-Z0-9\\-]*[a-zA-Z0-9])?)? : Optional second-to-last label (to allow single-label TLD handling below)\n    # ([a-zA-Z]{2,})             : TLD: at least 2 alphabetic chars\n    # $                          : End of string\n    \n    # More precise construction:\n    # Local part: cannot start/end with . or -, allowed chars: alnum, ., _, -\n    local_part = r\"(?![.\\-])(?:[a-zA-Z0-9._-]+)(?<![.\\-])\"\n    \n    # Domain label: alnum or hyphen, but not starting/ending with hyphen\n    domain_label = r\"[a-zA-Z0-9](?:[a-zA-Z0-9\\-]*[a-zA-Z0-9])?\"\n    # For single-char labels, the above fails, so we adjust:\n    domain_label = r\"(?:[a-zA-Z0-9](?:[a-zA-Z0-9\\-]*[a-zA-Z0-9])?|[a-zA-Z0-9])\"\n    # Actually simpler: [a-zA-Z0-9] optionally followed by ([a-zA-Z0-9-]*[a-zA-Z0-9])\n    domain_label = r\"[a-zA-Z0-9](?:[a-zA-Z0-9\\-]*[a-zA-Z0-9])?\"\n    # But single char is valid: so use (?:[a-zA-Z0-9]|(?:[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9]))\n    # Let's simplify: each label must be alnum, may contain hyphens inside, not at edges.\n    # So: [a-zA-Z0-9] + optional ([a-zA-Z0-9\\-]*[a-zA-Z0-9]) -> covers single char too if we make the second part optional correctly.\n    # Correct pattern for a label: [a-zA-Z0-9](?:[a-zA-Z0-9\\-]*[a-zA-Z0-9])? \n    # This works for single char: first char matches, rest is optional and empty.\n    \n    # However, to avoid matching a trailing hyphen, we ensure the last char is alnum.\n    # So domain_label = r\"[a-zA-Z0-9](?:[a-zA-Z0-9\\-]*[a-zA-Z0-9])?\" is okay because:\n    #   - If length=1: matches [a-zA-Z0-9], rest skipped.\n    #   - If length>1: must end with [a-zA-Z0-9].\n    \n    # Now, domain: one or more labels separated by dots, last label is TLD (alpha only, >=2)\n    # We separate TLD: must be [a-zA-Z]{2,}\n    # Other labels: domain_label as above\n    \n    # Full domain: (domain_label\\.)* TLD\n    # But note: there must be at least one label before TLD? No: example.com -> two labels.\n    # Actually: domain must have at least two parts? Not necessarily per spec, but TLD is last label.\n    # Spec says: \"one or more labels separated by dots\", and last is TLD.\n    # So minimum: one label? But then it would be the TLD. However, common practice requires at least two.\n    # Re-read spec: \"Domain part: one or more labels separated by dots. Each label... The last domain label (TLD)...\"\n    # This implies at least one label, but then the TLD is that one label. However, TLD must be alpha-only and >=2.\n    # But typical emails require at least one subdomain + TLD. Let's follow spec literally: \n    #   It says \"labels separated by dots\", plural implies multiple? But \"one or more\" is explicit.\n    #   However, if there's only one label, then it's the TLD. Is \"user@com\" valid? Per spec: \n    #      - label: \"com\" -> valid (alnum, no hyphen issues), TLD: \"com\" -> alpha, len>=2 -> valid.\n    #   But in reality, we usually require at least two labels. However, the problem statement does not specify that.\n    #   Let me check: \"one or more labels separated by dots\"  if there's only one label, there are no dots, so it's just one label.\n    #   So \"user@localhost\" would be invalid because TLD \"localhost\" is alpha and >=2, but is \"localhost\" a valid TLD? \n    #   The spec doesn't restrict TLD to known ones, just format. However, the problem says \"The last domain label (TLD)\", implying there might be others, but doesn't forbid single-label domains.\n    #   BUT: standard email validation usually requires at least two labels. Let me re-read carefully:\n    #      \"Domain part (after @): one or more labels separated by dots.\"\n    #      This phrasing is ambiguous. In English, \"separated by dots\" for one label doesn't make sense (no separators). \n    #      Typically, this means: the domain consists of labels, and if there are multiple, they are separated by dots. One label is allowed without dots.\n    #   However, the TLD requirement: \"last domain label\"  if only one, it's the last. \n    #   But practical email standards (RFC) require at least two labels? Actually, RFC allows single-label domains in private contexts, but for public internet, usually two+.\n    #   Since the problem doesn't specify, and to be safe, let's assume the domain must have at least two labels? \n    #   Wait, the problem says: \"one or more labels\", so one is allowed. But then the TLD is that one label. \n    #   However, the example constraints: TLD must be alpha-only and >=2. So \"a@b\" is invalid (TLD \"b\" len=1), \"a@co\" is valid? \n    #   But \"co\" is a valid TLD (Colombia). So per spec, \"user@co\" should be valid? \n    #   However, in reality, most validators require at least two labels. Given the ambiguity, I'll follow the literal spec: \n    #      Domain = (label\\.)*label, where the last label is TLD (alpha, >=2), and other labels follow the hyphen rules.\n    #   But note: if there's only one label, then the entire domain is the TLD. So pattern: \n    #      domain = (?:label\\.)*TLD\n    #   And label = [a-zA-Z0-9](?:[a-zA-Z0-9\\-]*[a-zA-Z0-9])? \n    #   TLD = [a-zA-Z]{2,}\n    #\n    # However, there's a catch: the non-TLD labels can have hyphens (but not at edges), TLD cannot have hyphens (only alpha).\n    #\n    # Let's construct:\n    #   local_part: as above\n    #   domain_label_non_tld: [a-zA-Z0-9](?:[a-zA-Z0-9\\-]*[a-zA-Z0-9])?   (allows hyphens inside)\n    #   tld: [a-zA-Z]{2,}\n    #   domain: (?:domain_label_non_tld\\.)*tld\n    #\n    # But what if there's only the TLD? Then (?:...)* matches zero times, and we have just tld. That's acceptable per \"one or more labels\" (the TLD is one label).\n    #\n    # However, the problem says: \"each label must be ...\", and the TLD is a label, so it must also satisfy the non-hyphen-start/end? \n    #   But the TLD rule overrides: \"must consist of only alphabetic characters\", so no hyphens allowed anyway. \n    #   And since it's all alpha, it won't start/end with hyphen. So TLD automatically satisfies the general label rule except the hyphen part is irrelevant.\n    #\n    # Therefore, we can define:\n    #   label_with_hyphens = r'[a-zA-Z0-9](?:[a-zA-Z0-9\\-]*[a-zA-Z0-9])?'\n    #   But note: this pattern for a single char: [a-zA-Z0-9] matches, and the rest is optional -> good.\n    #   However, for two chars: [a-zA-Z0-9] then [a-zA-Z0-9] (since [a-zA-Z0-9\\-]* can be empty) -> good.\n    #   For \"a-b\": [a] then [\\-b] -> but wait: [a-zA-Z0-9\\-]* matches '-', then [a-zA-Z0-9] matches 'b'. -> good.\n    #   For \"a-\": fails because after [a], we have '-' in the middle part, but then we need to end with [a-zA-Z0-9] -> so \"a-\" is rejected. Good.\n    #\n    # Now, the domain: \n    #   We need zero or more non-TLD labels (which can have hyphens) followed by a dot, then the TLD.\n    #   But the TLD is also a label, but with stricter rules (no digits, no hyphens). \n    #   So: domain = (?:label_with_hyphens\\.)*[a-zA-Z]{2,}\n    #\n    # However, what if there are multiple labels and the last one before TLD has a hyphen? That's allowed for non-TLD labels.\n    #\n    # Example: user@sub-domain.example.com -> \n    #   labels: \"sub-domain\", \"example\", \"com\"\n    #   Here, \"com\" is TLD -> must be alpha, which it is.\n    #   \"example\" and \"sub-domain\" are non-TLD -> can have hyphens (but not at edges).\n    #\n    # But in our pattern, the last label is forced to be TLD (alpha only). The preceding labels use label_with_hyphens.\n    #\n    # So full regex:\n    pattern = rf'^{local_part}@(?:(?:[a-zA-Z0-9](?:[a-zA-Z0-9\\-]*[a-zA-Z0-9])?\\.)*)[a-zA-Z]{{2,}}$'\n    \n    # However, the above pattern for the domain part: \n    #   (?: ... )* allows zero or more occurrences of (label + dot). Then TLD.\n    #   This means the domain can be just TLD (e.g., user@com) which per spec is allowed (one label).\n    #\n    # But wait: the label pattern [a-zA-Z0-9](?:[a-zA-Z0-9\\-]*[a-zA-Z0-9])? might not match a single character correctly in all cases? \n    #   Let's test mentally: \n    #      \"a\" -> [a-zA-Z0-9] matches 'a', the rest is optional -> matches.\n    #      \"ab\" -> [a] then [b] (since [a-zA-Z0-9\\-]* matches empty, then [a-zA-Z0-9] matches 'b') -> matches.\n    #      \"a-b\" -> [a] then [\\-b]: [a-zA-Z0-9\\-]* matches '-', then [a-zA-Z0-9] matches 'b' -> matches.\n    #      \"a-\" -> [a] then we try to match the optional part: [a-zA-Z0-9\\-]* matches '-', but then we need [a-zA-Z0-9] at the end -> fails. Good.\n    #      \"-a\" -> first char must be [a-zA-Z0-9] -> fails. Good.\n    #\n    # However, there's a potential issue: the pattern [a-zA-Z0-9](?:[a-zA-Z0-9\\-]*[a-zA-Z0-9])? \n    #   For a two-character string like \"a-\", it would try: \n    #       first char 'a' matches [a-zA-Z0-9]\n    #       then the optional group: [a-zA-Z0-9\\-]* matches '-', but then [a-zA-Z0-9] fails at the end -> so the whole optional group fails, and we accept just \"a\". \n    #   But that would match \"a\" in \"a-\", leaving \"-\" unmatched. However, in our domain pattern, each label is followed by a dot or is the last (but the last is handled by TLD). \n    #   In the non-TLD part, we have (label\\.), so the label must be followed by a dot. Therefore, if we have \"a-.\", the label part would try to match \"a-\" and fail, so it wouldn't match. \n    #   Actually, the regex engine will backtrack. But our pattern for the label is greedy? \n    #\n    # To avoid complexity, let's refine the label pattern to explicitly disallow trailing hyphen by structure:\n    #   We can use: [a-zA-Z0-9](?:[a-zA-Z0-9\\-]*[a-zA-Z0-9])? \n    #   This already ensures that if there is more than one character, the last is alnum. And single char is alnum. So no trailing hyphen.\n    #\n    # But note: what about consecutive hyphens? \"a--b\" -> \n    #   [a] then [\\-\\-b]: [a-zA-Z0-9\\-]* matches '--', then [a-zA-Z0-9] matches 'b' -> valid. And that's acceptable (hyphens inside are allowed).\n    #\n    # Now, the TLD: [a-zA-Z]{2,} -> ensures only letters, at least 2.\n    #\n    # One more edge: the entire email must not have extra characters. The ^ and $ ensure that.\n    #\n    # Let's write the regex:\n    #   local_part: (?![.\\-])(?:[a-zA-Z0-9._-]+)(?<![.\\-])\n    #   But note: the local part must not have consecutive dots? The spec doesn't say that. It only says must not start/end with dot/hyphen.\n    #   So \"a..b\" is allowed per spec? The problem statement doesn't forbid it. So we allow.\n    #\n    # However, the pattern [a-zA-Z0-9._-]+ allows consecutive dots. That's acceptable per given rules.\n    #\n    # Final pattern assembly:\n    regex_pattern = r'^(?![.\\-])(?:[a-zA-Z0-9._-]+)(?<![.\\-])@(?:[a-zA-Z0-9](?:[a-zA-Z0-9\\-]*[a-zA-Z0-9])?\\.)+[a-zA-Z]{2,}$'\n    # Wait, I changed the domain part: now I require at least one non-TLD label? Because (?: ... \\.)+ means one or more labels followed by dot, then TLD.\n    # But the spec says \"one or more labels\" for the entire domain. If we do (label\\.)*TLD, that allows zero non-TLD labels (so domain = TLD). \n    # But if we do (label\\.)+TLD, that requires at least one non-TLD label (so domain has at least two labels: one non-TLD and TLD).\n    #\n    # Re-read spec: \"Domain part (after @): one or more labels separated by dots.\" \n    #   This is ambiguous. In common interpretation, \"labels separated by dots\" implies that if there are n labels, there are n-1 dots. \n    #   So one label: no dots -> valid. Two labels: one dot -> valid.\n    #   Therefore, we should allow one label (the TLD) as the entire domain.\n    #\n    # However, in practice, almost all email validators require at least two labels (e.g., example.com). \n    # But the problem statement does not specify a minimum of two labels. It says \"one or more\".\n    #\n    # Let me check the TLD rule: \"The last domain label (TLD) must be at least 2 characters long and consist of only alphabetic characters.\"\n    #   If there's only one label, it is the last (and only) label, so it must be TLD -> alpha, >=2.\n    #   So \"user@co\" would be valid per spec.\n    #\n    # However",
    "stdout": "",
    "stderr": "...........FFFFFFFF\n======================================================================\nFAIL: test_valid_long_tld (__main__.TestValidateEmail.test_valid_long_tld)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/tmp/tmpg4sidet2.py\", line 246, in test_valid_long_tld\n    self.assertTrue(validate_email(\"user@example.museum\"))\nAssertionError: None is not true\n\n======================================================================\nFAIL: test_valid_numeric_local (__main__.TestValidateEmail.test_valid_numeric_local)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/tmp/tmpg4sidet2.py\", line 237, in test_valid_numeric_local\n    self.assertTrue(validate_email(\"123@example.com\"))\nAssertionError: None is not true\n\n======================================================================\nFAIL: test_valid_simple (__main__.TestValidateEmail.test_valid_simple)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/tmp/tmpg4sidet2.py\", line 195, in test_valid_simple\n    self.assertTrue(validate_email(\"user@example.com\"))\nAssertionError: None is not true\n\n======================================================================\nFAIL: test_valid_single_char_local (__main__.TestValidateEmail.test_valid_single_char_local)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/tmp/tmpg4sidet2.py\", line 240, in test_valid_single_char_local\n    self.assertTrue(validate_email(\"a@example.com\"))\nAssertionError: None is not true\n\n======================================================================\nFAIL: test_valid_subdomain (__main__.TestValidateEmail.test_valid_subdomain)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/tmp/tmpg4sidet2.py\", line 207, in test_valid_subdomain\n    self.assertTrue(validate_email(\"user@mail.example.com\"))\nAssertionError: None is not true\n\n======================================================================\nFAIL: test_valid_with_dots (__main__.TestValidateEmail.test_valid_with_dots)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/tmp/tmpg4sidet2.py\", line 198, in test_valid_with_dots\n    self.assertTrue(validate_email(\"first.last@example.com\"))\nAssertionError: None is not true\n\n======================================================================\nFAIL: test_valid_with_hyphen (__main__.TestValidateEmail.test_valid_with_hyphen)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/tmp/tmpg4sidet2.py\", line 204, in test_valid_with_hyphen\n    self.assertTrue(validate_email(\"user-name@example.com\"))\nAssertionError: None is not true\n\n======================================================================\nFAIL: test_valid_with_underscore (__main__.TestValidateEmail.test_valid_with_underscore)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/tmp/tmpg4sidet2.py\", line 201, in test_valid_with_underscore\n    self.assertTrue(validate_email(\"user_name@example.com\"))\nAssertionError: None is not true\n\n----------------------------------------------------------------------\nRan 19 tests in 0.002s\n\nFAILED (failures=8)\n"
  },
  {
    "id": "std_004",
    "category": "stdlib",
    "difficulty": "medium",
    "title": "Cartesian Product Filter",
    "passed": true,
    "error": null,
    "generated_code": "from itertools import product\n\ndef cartesian_filter(lists: list[list[int]], threshold: int) -> list[tuple[int, ...]]:\n    \"\"\"Generate the cartesian product of multiple lists of integers and\n    filter to keep only tuples whose element sum exceeds a threshold.\n\n    Args:\n        lists: A list of lists of integers. The cartesian product is\n               computed across all provided lists.\n        threshold: An integer threshold. Only tuples whose sum is\n                   strictly greater than this value are included.\n\n    Returns:\n        A list of tuples (in the order produced by itertools.product)\n        where the sum of elements is strictly greater than the threshold.\n        Returns an empty list if lists is empty.\n    \"\"\"\n    if not lists:\n        return []\n    \n    return [t for t in product(*lists) if sum(t) > threshold]",
    "stdout": "",
    "stderr": "............\n----------------------------------------------------------------------\nRan 12 tests in 0.000s\n\nOK\n"
  },
  {
    "id": "std_005",
    "category": "stdlib",
    "difficulty": "hard",
    "title": "Parallel Map",
    "passed": true,
    "error": null,
    "generated_code": "from concurrent.futures import ThreadPoolExecutor\nfrom typing import Callable, TypeVar\n\nT = TypeVar('T')\nR = TypeVar('R')\n\ndef parallel_map(func: Callable[[T], R], items: list[T], max_workers: int = 4) -> list[R]:\n    \"\"\"Apply a function to each item in a list using parallel threads.\n\n    Uses concurrent.futures.ThreadPoolExecutor to apply func to each\n    element of items in parallel, then returns the results in the same\n    order as the input items.\n\n    Args:\n        func: A callable that takes a single argument and returns a result.\n        items: A list of items to process.\n        max_workers: Maximum number of threads to use (default 4).\n\n    Returns:\n        A list of results in the same order as the input items.\n        Returns an empty list if items is empty.\n    \"\"\"\n    if not items:\n        return []\n\n    with ThreadPoolExecutor(max_workers=max_workers) as executor:\n        results = list(executor.map(func, items))\n\n    return results",
    "stdout": "",
    "stderr": "............\n----------------------------------------------------------------------\nRan 12 tests in 0.119s\n\nOK\n"
  },
  {
    "id": "str_001",
    "category": "string_processing",
    "difficulty": "easy",
    "title": "Is Palindrome",
    "passed": true,
    "error": null,
    "generated_code": "import re\n\ndef is_palindrome(s: str) -> bool:\n    \"\"\"\n    Check if a string is a palindrome, ignoring case, spaces, and punctuation.\n\n    Only consider alphanumeric characters when determining if the string\n    is a palindrome.\n\n    Args:\n        s: The input string\n\n    Returns:\n        True if the string is a palindrome, False otherwise\n\n    Examples:\n        is_palindrome('racecar') -> True\n        is_palindrome('A man, a plan, a canal: Panama') -> True\n        is_palindrome('hello') -> False\n        is_palindrome('') -> True\n    \"\"\"\n    # Extract alphanumeric characters and convert to lowercase\n    cleaned = re.sub(r'[^a-zA-Z0-9]', '', s).lower()\n    \n    # Check if the cleaned string equals its reverse\n    return cleaned == cleaned[::-1]",
    "stdout": "",
    "stderr": ".............\n----------------------------------------------------------------------\nRan 13 tests in 0.001s\n\nOK\n"
  },
  {
    "id": "str_002",
    "category": "string_processing",
    "difficulty": "easy",
    "title": "Caesar Cipher",
    "passed": true,
    "error": null,
    "generated_code": "def caesar_cipher(text: str, shift: int, mode: str = 'encrypt') -> str:\n    \"\"\"\n    Encrypt or decrypt text using a Caesar cipher.\n\n    Shift each letter by the given amount. Preserve case. Non-alphabetic\n    characters (spaces, punctuation, digits) are left unchanged.\n\n    For encryption, shift letters forward in the alphabet.\n    For decryption, shift letters backward.\n\n    The shift value can be any integer and will be normalized mod 26.\n\n    Args:\n        text: The input string\n        shift: Integer shift value\n        mode: 'encrypt' or 'decrypt'\n\n    Returns:\n        The encrypted or decrypted string\n\n    Examples:\n        caesar_cipher('Hello, World!', 3, 'encrypt') -> 'Khoor, Zruog!'\n        caesar_cipher('Khoor, Zruog!', 3, 'decrypt') -> 'Hello, World!'\n        caesar_cipher('abc', 1, 'encrypt') -> 'bcd'\n        caesar_cipher('xyz', 3, 'encrypt') -> 'abc'\n    \"\"\"\n    if mode == 'decrypt':\n        shift = -shift\n\n    shift = shift % 26\n    result = []\n\n    for char in text:\n        if 'a' <= char <= 'z':\n            base = ord('a')\n            shifted = (ord(char) - base + shift) % 26 + base\n            result.append(chr(shifted))\n        elif 'A' <= char <= 'Z':\n            base = ord('A')\n            shifted = (ord(char) - base + shift) % 26 + base\n            result.append(chr(shifted))\n        else:\n            result.append(char)\n\n    return ''.join(result)",
    "stdout": "",
    "stderr": ".............\n----------------------------------------------------------------------\nRan 13 tests in 0.001s\n\nOK\n"
  },
  {
    "id": "str_003",
    "category": "string_processing",
    "difficulty": "medium",
    "title": "Extract URLs",
    "passed": true,
    "error": null,
    "generated_code": "import re\n\ndef extract_urls(text: str) -> list:\n    \"\"\"\n    Extract all URLs from a text string.\n\n    Find all URLs that start with http:// or https:// followed by\n    one or more non-whitespace characters. URLs should not end with\n    trailing punctuation marks (period, comma, semicolon, exclamation\n    mark, question mark, closing parenthesis) that are likely part of\n    the surrounding text rather than the URL itself.\n\n    Args:\n        text: The input string that may contain URLs\n\n    Returns:\n        A list of URL strings found in the text, in order of appearance\n\n    Examples:\n        extract_urls('Visit https://example.com for more info')\n        -> ['https://example.com']\n\n        extract_urls('No URLs here')\n        -> []\n\n        extract_urls('Go to http://a.com and https://b.com/path')\n        -> ['http://a.com', 'https://b.com/path']\n    \"\"\"\n    # Pattern explanation:\n    # (https?://\\S+) - Capture group for http/https followed by non-whitespace chars\n    # We then strip trailing punctuation in post-processing\n    pattern = r'https?://\\S+'\n    \n    matches = re.findall(pattern, text)\n    \n    cleaned_urls = []\n    trailing_punct = {'.', ',', ';', '!', '?', ')'}\n    \n    for url in matches:\n        # Strip trailing punctuation that's likely not part of the URL\n        while url and url[-1] in trailing_punct:\n            url = url[:-1]\n        \n        # Only add if there's still content after stripping\n        if url and len(url) > len('http://'):  # Ensure minimum valid URL length\n            cleaned_urls.append(url)\n    \n    return cleaned_urls",
    "stdout": "",
    "stderr": ".............\n----------------------------------------------------------------------\nRan 13 tests in 0.001s\n\nOK\n"
  },
  {
    "id": "str_004",
    "category": "string_processing",
    "difficulty": "hard",
    "title": "Template Engine",
    "passed": true,
    "error": null,
    "generated_code": "import re\n\ndef template_engine(template: str, context: dict) -> str:\n    \"\"\"\n    Implement a simple template engine that replaces placeholders with values.\n\n    Placeholders are enclosed in double curly braces: {{key}}\n\n    Features:\n    - Simple replacement: {{name}} is replaced with context['name']\n    - Nested access: {{user.name}} accesses context['user']['name']\n    - Default values: {{key|default}} uses 'default' if key is missing\n    - If a key is not found and no default is given, leave the placeholder as-is\n    - Strip whitespace inside braces: {{ name }} is the same as {{name}}\n    - Values are converted to strings using str()\n\n    Args:\n        template: A string with {{placeholder}} markers\n        context: A dictionary of values for substitution\n\n    Returns:\n        The template string with placeholders replaced\n\n    Examples:\n        template_engine('Hello {{name}}!', {'name': 'World'})\n        -> 'Hello World!'\n\n        template_engine('{{user.name}} is {{user.age}}',\n                        {'user': {'name': 'Alice', 'age': 30}})\n        -> 'Alice is 30'\n\n        template_engine('{{missing|default_val}}', {})\n        -> 'default_val'\n\n        template_engine('{{missing}}', {})\n        -> '{{missing}}'\n    \"\"\"\n    pattern = re.compile(r'\\{\\{\\s*([^}]+?)\\s*\\}\\}')\n\n    def replace_match(match):\n        expression = match.group(1).strip()\n        \n        # Check for default value\n        if '|' in expression:\n            parts = expression.split('|', 1)\n            key_path = parts[0].strip()\n            default_value = parts[1].strip()\n        else:\n            key_path = expression\n            default_value = None\n        \n        # Navigate nested keys\n        keys = key_path.split('.')\n        value = context\n        \n        try:\n            for key in keys:\n                key = key.strip()\n                if isinstance(value, dict) and key in value:\n                    value = value[key]\n                else:\n                    raise KeyError(key)\n            \n            return str(value)\n        except (KeyError, TypeError):\n            if default_value is not None:\n                return default_value\n            else:\n                return match.group(0)  # Return original placeholder\n    \n    return pattern.sub(replace_match, template)",
    "stdout": "",
    "stderr": ".................\n----------------------------------------------------------------------\nRan 17 tests in 0.001s\n\nOK\n"
  }
]
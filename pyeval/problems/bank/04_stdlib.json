[
  {
    "id": "std_001",
    "category": "stdlib",
    "difficulty": "easy",
    "title": "Count Words",
    "prompt": "from collections import Counter\n\ndef count_words(text: str) -> dict[str, int]:\n    \"\"\"Count the frequency of each word in a string.\n\n    Words are separated by whitespace. Counting is case-sensitive\n    (i.e., 'Hello' and 'hello' are different words).\n\n    Args:\n        text: A string of words separated by whitespace.\n\n    Returns:\n        A dictionary mapping each word to the number of times it appears.\n    \"\"\"",
    "reference_solution": "from collections import Counter\n\ndef count_words(text: str) -> dict[str, int]:\n    \"\"\"Count the frequency of each word in a string.\n\n    Words are separated by whitespace. Counting is case-sensitive\n    (i.e., 'Hello' and 'hello' are different words).\n\n    Args:\n        text: A string of words separated by whitespace.\n\n    Returns:\n        A dictionary mapping each word to the number of times it appears.\n    \"\"\"\n    if not text.strip():\n        return {}\n    return dict(Counter(text.split()))",
    "test_code": "import unittest\n\nclass TestCountWords(unittest.TestCase):\n    def test_basic(self):\n        result = count_words(\"hello world hello\")\n        self.assertEqual(result, {\"hello\": 2, \"world\": 1})\n\n    def test_single_word(self):\n        self.assertEqual(count_words(\"hello\"), {\"hello\": 1})\n\n    def test_empty_string(self):\n        self.assertEqual(count_words(\"\"), {})\n\n    def test_whitespace_only(self):\n        self.assertEqual(count_words(\"   \"), {})\n\n    def test_case_sensitive(self):\n        result = count_words(\"Hello hello HELLO\")\n        self.assertEqual(result, {\"Hello\": 1, \"hello\": 1, \"HELLO\": 1})\n\n    def test_multiple_spaces(self):\n        result = count_words(\"a  b   a\")\n        self.assertEqual(result, {\"a\": 2, \"b\": 1})\n\n    def test_all_same(self):\n        result = count_words(\"yes yes yes yes\")\n        self.assertEqual(result, {\"yes\": 4})\n\n    def test_returns_dict_type(self):\n        result = count_words(\"a b c\")\n        self.assertIsInstance(result, dict)\n\n    def test_many_unique(self):\n        result = count_words(\"a b c d e\")\n        self.assertEqual(result, {\"a\": 1, \"b\": 1, \"c\": 1, \"d\": 1, \"e\": 1})",
    "tags": ["collections", "counter", "strings", "frequency"],
    "time_limit_seconds": 5
  },
  {
    "id": "std_002",
    "category": "stdlib",
    "difficulty": "easy",
    "title": "Parse Date",
    "prompt": "from datetime import datetime\n\ndef parse_date(date_str: str) -> str:\n    \"\"\"Parse a date string in 'YYYY-MM-DD' format and return the day of the week.\n\n    Args:\n        date_str: A date string in the format 'YYYY-MM-DD'.\n\n    Returns:\n        The day of the week as a full string, e.g. 'Monday', 'Tuesday', etc.\n    \"\"\"",
    "reference_solution": "from datetime import datetime\n\ndef parse_date(date_str: str) -> str:\n    \"\"\"Parse a date string in 'YYYY-MM-DD' format and return the day of the week.\n\n    Args:\n        date_str: A date string in the format 'YYYY-MM-DD'.\n\n    Returns:\n        The day of the week as a full string, e.g. 'Monday', 'Tuesday', etc.\n    \"\"\"\n    dt = datetime.strptime(date_str, \"%Y-%m-%d\")\n    return dt.strftime(\"%A\")",
    "test_code": "import unittest\n\nclass TestParseDate(unittest.TestCase):\n    def test_monday(self):\n        self.assertEqual(parse_date(\"2024-01-01\"), \"Monday\")\n\n    def test_wednesday(self):\n        self.assertEqual(parse_date(\"2024-01-03\"), \"Wednesday\")\n\n    def test_friday(self):\n        self.assertEqual(parse_date(\"2024-01-05\"), \"Friday\")\n\n    def test_sunday(self):\n        self.assertEqual(parse_date(\"2024-01-07\"), \"Sunday\")\n\n    def test_leap_day(self):\n        self.assertEqual(parse_date(\"2024-02-29\"), \"Thursday\")\n\n    def test_new_year_2000(self):\n        self.assertEqual(parse_date(\"2000-01-01\"), \"Saturday\")\n\n    def test_christmas_2023(self):\n        self.assertEqual(parse_date(\"2023-12-25\"), \"Monday\")\n\n    def test_returns_string(self):\n        result = parse_date(\"2024-06-15\")\n        self.assertIsInstance(result, str)\n\n    def test_saturday(self):\n        self.assertEqual(parse_date(\"2024-01-06\"), \"Saturday\")\n\n    def test_tuesday(self):\n        self.assertEqual(parse_date(\"2024-01-02\"), \"Tuesday\")\n\n    def test_thursday(self):\n        self.assertEqual(parse_date(\"2024-01-04\"), \"Thursday\")",
    "tags": ["datetime", "parsing", "date"],
    "time_limit_seconds": 5
  },
  {
    "id": "std_003",
    "category": "stdlib",
    "difficulty": "medium",
    "title": "Validate Email",
    "prompt": "import re\n\ndef validate_email(email: str) -> bool:\n    \"\"\"Validate an email address using regular expressions.\n\n    A valid email must satisfy:\n    - Local part (before @): one or more alphanumeric characters, dots,\n      underscores, or hyphens. Must not start or end with a dot/hyphen.\n    - Exactly one '@' symbol.\n    - Domain part (after @): one or more labels separated by dots.\n      Each label must be one or more alphanumeric characters or hyphens,\n      but must not start or end with a hyphen.\n    - The last domain label (TLD) must be at least 2 characters long\n      and consist of only alphabetic characters.\n\n    Args:\n        email: The email address string to validate.\n\n    Returns:\n        True if the email is valid, False otherwise.\n    \"\"\"",
    "reference_solution": "import re\n\ndef validate_email(email: str) -> bool:\n    \"\"\"Validate an email address using regular expressions.\n\n    A valid email must satisfy:\n    - Local part (before @): one or more alphanumeric characters, dots,\n      underscores, or hyphens. Must not start or end with a dot/hyphen.\n    - Exactly one '@' symbol.\n    - Domain part (after @): one or more labels separated by dots.\n      Each label must be one or more alphanumeric characters or hyphens,\n      but must not start or end with a hyphen.\n    - The last domain label (TLD) must be at least 2 characters long\n      and consist of only alphabetic characters.\n\n    Args:\n        email: The email address string to validate.\n\n    Returns:\n        True if the email is valid, False otherwise.\n    \"\"\"\n    pattern = r'^[a-zA-Z0-9]([a-zA-Z0-9._-]*[a-zA-Z0-9])?@([a-zA-Z0-9]([a-zA-Z0-9-]*[a-zA-Z0-9])?\\.)+[a-zA-Z]{2,}$'\n    return bool(re.match(pattern, email))",
    "test_code": "import unittest\n\nclass TestValidateEmail(unittest.TestCase):\n    def test_valid_simple(self):\n        self.assertTrue(validate_email(\"user@example.com\"))\n\n    def test_valid_with_dots(self):\n        self.assertTrue(validate_email(\"first.last@example.com\"))\n\n    def test_valid_with_underscore(self):\n        self.assertTrue(validate_email(\"user_name@example.com\"))\n\n    def test_valid_with_hyphen(self):\n        self.assertTrue(validate_email(\"user-name@example.com\"))\n\n    def test_valid_subdomain(self):\n        self.assertTrue(validate_email(\"user@mail.example.com\"))\n\n    def test_invalid_no_at(self):\n        self.assertFalse(validate_email(\"userexample.com\"))\n\n    def test_invalid_double_at(self):\n        self.assertFalse(validate_email(\"user@@example.com\"))\n\n    def test_invalid_no_domain(self):\n        self.assertFalse(validate_email(\"user@\"))\n\n    def test_invalid_no_local(self):\n        self.assertFalse(validate_email(\"@example.com\"))\n\n    def test_invalid_no_tld(self):\n        self.assertFalse(validate_email(\"user@example\"))\n\n    def test_invalid_short_tld(self):\n        self.assertFalse(validate_email(\"user@example.c\"))\n\n    def test_invalid_starting_dot(self):\n        self.assertFalse(validate_email(\".user@example.com\"))\n\n    def test_invalid_ending_dot_local(self):\n        self.assertFalse(validate_email(\"user.@example.com\"))\n\n    def test_invalid_spaces(self):\n        self.assertFalse(validate_email(\"user @example.com\"))\n\n    def test_valid_numeric_local(self):\n        self.assertTrue(validate_email(\"123@example.com\"))\n\n    def test_valid_single_char_local(self):\n        self.assertTrue(validate_email(\"a@example.com\"))\n\n    def test_invalid_domain_starts_with_hyphen(self):\n        self.assertFalse(validate_email(\"user@-example.com\"))\n\n    def test_valid_long_tld(self):\n        self.assertTrue(validate_email(\"user@example.museum\"))\n\n    def test_empty_string(self):\n        self.assertFalse(validate_email(\"\"))",
    "tags": ["regex", "validation", "email", "re"],
    "time_limit_seconds": 5
  },
  {
    "id": "std_004",
    "category": "stdlib",
    "difficulty": "medium",
    "title": "Cartesian Product Filter",
    "prompt": "from itertools import product\n\ndef cartesian_filter(lists: list[list[int]], threshold: int) -> list[tuple[int, ...]]:\n    \"\"\"Generate the cartesian product of multiple lists of integers and\n    filter to keep only tuples whose element sum exceeds a threshold.\n\n    Args:\n        lists: A list of lists of integers. The cartesian product is\n               computed across all provided lists.\n        threshold: An integer threshold. Only tuples whose sum is\n                   strictly greater than this value are included.\n\n    Returns:\n        A list of tuples (in the order produced by itertools.product)\n        where the sum of elements is strictly greater than the threshold.\n        Returns an empty list if lists is empty.\n    \"\"\"",
    "reference_solution": "from itertools import product\n\ndef cartesian_filter(lists: list[list[int]], threshold: int) -> list[tuple[int, ...]]:\n    \"\"\"Generate the cartesian product of multiple lists of integers and\n    filter to keep only tuples whose element sum exceeds a threshold.\n\n    Args:\n        lists: A list of lists of integers. The cartesian product is\n               computed across all provided lists.\n        threshold: An integer threshold. Only tuples whose sum is\n                   strictly greater than this value are included.\n\n    Returns:\n        A list of tuples (in the order produced by itertools.product)\n        where the sum of elements is strictly greater than the threshold.\n        Returns an empty list if lists is empty.\n    \"\"\"\n    if not lists:\n        return []\n    return [t for t in product(*lists) if sum(t) > threshold]",
    "test_code": "import unittest\n\nclass TestCartesianFilter(unittest.TestCase):\n    def test_basic(self):\n        result = cartesian_filter([[1, 2], [3, 4]], 4)\n        self.assertEqual(result, [(1, 4), (2, 3), (2, 4)])\n\n    def test_all_pass(self):\n        result = cartesian_filter([[10], [10]], 0)\n        self.assertEqual(result, [(10, 10)])\n\n    def test_none_pass(self):\n        result = cartesian_filter([[1, 2], [1, 2]], 100)\n        self.assertEqual(result, [])\n\n    def test_empty_lists(self):\n        result = cartesian_filter([], 0)\n        self.assertEqual(result, [])\n\n    def test_single_list(self):\n        result = cartesian_filter([[1, 2, 3, 4, 5]], 3)\n        self.assertEqual(result, [(4,), (5,)])\n\n    def test_three_lists(self):\n        result = cartesian_filter([[1, 2], [1, 2], [1, 2]], 5)\n        self.assertEqual(result, [(2, 2, 2)])\n\n    def test_negative_threshold(self):\n        result = cartesian_filter([[1], [1]], -1)\n        self.assertEqual(result, [(1, 1)])\n\n    def test_negative_numbers(self):\n        result = cartesian_filter([[-1, 1], [-1, 1]], 0)\n        self.assertEqual(result, [(1, 1)])\n\n    def test_zero_threshold(self):\n        result = cartesian_filter([[0, 1], [0, 1]], 0)\n        self.assertEqual(result, [(0, 1), (1, 0), (1, 1)])\n\n    def test_returns_tuples(self):\n        result = cartesian_filter([[1, 2], [3, 4]], 0)\n        for item in result:\n            self.assertIsInstance(item, tuple)\n\n    def test_contains_empty_sublist(self):\n        result = cartesian_filter([[1, 2], []], 0)\n        self.assertEqual(result, [])\n\n    def test_order_preserved(self):\n        result = cartesian_filter([[1, 2, 3], [10, 20]], 11)\n        self.assertEqual(result, [(1, 20), (2, 10), (2, 20), (3, 10), (3, 20)])",
    "tags": ["itertools", "product", "filter", "combinatorics"],
    "time_limit_seconds": 10
  },
  {
    "id": "std_005",
    "category": "stdlib",
    "difficulty": "hard",
    "title": "Parallel Map",
    "prompt": "from concurrent.futures import ThreadPoolExecutor\nfrom typing import Callable, TypeVar\n\nT = TypeVar('T')\nR = TypeVar('R')\n\ndef parallel_map(func: Callable[[T], R], items: list[T], max_workers: int = 4) -> list[R]:\n    \"\"\"Apply a function to each item in a list using parallel threads.\n\n    Uses concurrent.futures.ThreadPoolExecutor to apply func to each\n    element of items in parallel, then returns the results in the same\n    order as the input items.\n\n    Args:\n        func: A callable that takes a single argument and returns a result.\n        items: A list of items to process.\n        max_workers: Maximum number of threads to use (default 4).\n\n    Returns:\n        A list of results in the same order as the input items.\n        Returns an empty list if items is empty.\n    \"\"\"",
    "reference_solution": "from concurrent.futures import ThreadPoolExecutor\nfrom typing import Callable, TypeVar\n\nT = TypeVar('T')\nR = TypeVar('R')\n\ndef parallel_map(func: Callable[[T], R], items: list[T], max_workers: int = 4) -> list[R]:\n    \"\"\"Apply a function to each item in a list using parallel threads.\n\n    Uses concurrent.futures.ThreadPoolExecutor to apply func to each\n    element of items in parallel, then returns the results in the same\n    order as the input items.\n\n    Args:\n        func: A callable that takes a single argument and returns a result.\n        items: A list of items to process.\n        max_workers: Maximum number of threads to use (default 4).\n\n    Returns:\n        A list of results in the same order as the input items.\n        Returns an empty list if items is empty.\n    \"\"\"\n    if not items:\n        return []\n    with ThreadPoolExecutor(max_workers=max_workers) as executor:\n        results = list(executor.map(func, items))\n    return results",
    "test_code": "import unittest\nimport time\n\nclass TestParallelMap(unittest.TestCase):\n    def test_square(self):\n        result = parallel_map(lambda x: x ** 2, [1, 2, 3, 4, 5])\n        self.assertEqual(result, [1, 4, 9, 16, 25])\n\n    def test_string_upper(self):\n        result = parallel_map(str.upper, [\"hello\", \"world\"])\n        self.assertEqual(result, [\"HELLO\", \"WORLD\"])\n\n    def test_empty_list(self):\n        result = parallel_map(lambda x: x, [])\n        self.assertEqual(result, [])\n\n    def test_single_item(self):\n        result = parallel_map(lambda x: x + 1, [10])\n        self.assertEqual(result, [11])\n\n    def test_preserves_order(self):\n        result = parallel_map(lambda x: x, list(range(100)))\n        self.assertEqual(result, list(range(100)))\n\n    def test_with_max_workers_1(self):\n        result = parallel_map(lambda x: x * 2, [1, 2, 3], max_workers=1)\n        self.assertEqual(result, [2, 4, 6])\n\n    def test_with_max_workers_8(self):\n        result = parallel_map(lambda x: x * 2, [1, 2, 3], max_workers=8)\n        self.assertEqual(result, [2, 4, 6])\n\n    def test_identity(self):\n        items = [\"a\", \"b\", \"c\"]\n        result = parallel_map(lambda x: x, items)\n        self.assertEqual(result, items)\n\n    def test_complex_function(self):\n        def process(n):\n            return sum(range(n))\n        result = parallel_map(process, [1, 5, 10])\n        self.assertEqual(result, [0, 10, 45])\n\n    def test_returns_list(self):\n        result = parallel_map(lambda x: x, [1, 2])\n        self.assertIsInstance(result, list)\n\n    def test_actually_parallel(self):\n        def slow_func(x):\n            time.sleep(0.1)\n            return x\n        start = time.time()\n        result = parallel_map(slow_func, list(range(8)), max_workers=8)\n        elapsed = time.time() - start\n        self.assertEqual(result, list(range(8)))\n        self.assertLess(elapsed, 0.5, \"Should run in parallel, not sequentially\")\n\n    def test_none_values(self):\n        result = parallel_map(lambda x: None, [1, 2, 3])\n        self.assertEqual(result, [None, None, None])",
    "tags": ["concurrent", "threading", "parallel", "futures", "map"],
    "time_limit_seconds": 15
  }
]

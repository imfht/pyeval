[
  {
    "id": "con_001",
    "category": "concurrency",
    "difficulty": "easy",
    "title": "Thread-Safe Counter",
    "prompt": "import threading\n\nclass ThreadSafeCounter:\n    \"\"\"\n    A thread-safe counter that can be safely incremented and decremented\n    from multiple threads simultaneously.\n\n    Methods:\n        __init__(self, initial=0): Initialize the counter with an optional\n            starting value (default 0).\n        increment(self): Atomically increase the counter by 1.\n        decrement(self): Atomically decrease the counter by 1.\n        get_value(self): Return the current counter value.\n\n    The counter must use threading.Lock to ensure thread safety.\n\n    Examples:\n        counter = ThreadSafeCounter()\n        counter.increment()\n        counter.increment()\n        counter.get_value()  # -> 2\n        counter.decrement()\n        counter.get_value()  # -> 1\n\n        counter = ThreadSafeCounter(10)\n        counter.get_value()  # -> 10\n    \"\"\"",
    "reference_solution": "import threading\n\nclass ThreadSafeCounter:\n    \"\"\"\n    A thread-safe counter that can be safely incremented and decremented\n    from multiple threads simultaneously.\n\n    Methods:\n        __init__(self, initial=0): Initialize the counter with an optional\n            starting value (default 0).\n        increment(self): Atomically increase the counter by 1.\n        decrement(self): Atomically decrease the counter by 1.\n        get_value(self): Return the current counter value.\n\n    The counter must use threading.Lock to ensure thread safety.\n\n    Examples:\n        counter = ThreadSafeCounter()\n        counter.increment()\n        counter.increment()\n        counter.get_value()  # -> 2\n        counter.decrement()\n        counter.get_value()  # -> 1\n\n        counter = ThreadSafeCounter(10)\n        counter.get_value()  # -> 10\n    \"\"\"\n    def __init__(self, initial=0):\n        self._value = initial\n        self._lock = threading.Lock()\n\n    def increment(self):\n        with self._lock:\n            self._value += 1\n\n    def decrement(self):\n        with self._lock:\n            self._value -= 1\n\n    def get_value(self):\n        with self._lock:\n            return self._value",
    "test_code": "import unittest\nimport threading\n\nclass TestThreadSafeCounter(unittest.TestCase):\n    def test_initial_default(self):\n        counter = ThreadSafeCounter()\n        self.assertEqual(counter.get_value(), 0)\n\n    def test_initial_value(self):\n        counter = ThreadSafeCounter(10)\n        self.assertEqual(counter.get_value(), 10)\n\n    def test_increment(self):\n        counter = ThreadSafeCounter()\n        counter.increment()\n        counter.increment()\n        self.assertEqual(counter.get_value(), 2)\n\n    def test_decrement(self):\n        counter = ThreadSafeCounter(5)\n        counter.decrement()\n        counter.decrement()\n        self.assertEqual(counter.get_value(), 3)\n\n    def test_negative_value(self):\n        counter = ThreadSafeCounter(0)\n        counter.decrement()\n        self.assertEqual(counter.get_value(), -1)\n\n    def test_mixed_operations(self):\n        counter = ThreadSafeCounter(0)\n        counter.increment()\n        counter.increment()\n        counter.decrement()\n        counter.increment()\n        self.assertEqual(counter.get_value(), 2)\n\n    def test_threaded_increment(self):\n        counter = ThreadSafeCounter(0)\n        threads = []\n        for _ in range(100):\n            t = threading.Thread(target=counter.increment)\n            threads.append(t)\n            t.start()\n        for t in threads:\n            t.join()\n        self.assertEqual(counter.get_value(), 100)\n\n    def test_threaded_decrement(self):\n        counter = ThreadSafeCounter(100)\n        threads = []\n        for _ in range(100):\n            t = threading.Thread(target=counter.decrement)\n            threads.append(t)\n            t.start()\n        for t in threads:\n            t.join()\n        self.assertEqual(counter.get_value(), 0)\n\n    def test_concurrent_inc_and_dec(self):\n        counter = ThreadSafeCounter(0)\n        threads = []\n        for _ in range(500):\n            threads.append(threading.Thread(target=counter.increment))\n            threads.append(threading.Thread(target=counter.decrement))\n        for t in threads:\n            t.start()\n        for t in threads:\n            t.join()\n        self.assertEqual(counter.get_value(), 0)\n\n    def test_uses_lock(self):\n        counter = ThreadSafeCounter()\n        self.assertTrue(hasattr(counter, '_lock') or any(\n            isinstance(getattr(counter, attr), threading.Lock)\n            for attr in dir(counter)\n            if not attr.startswith('__')\n        ))",
    "tags": ["concurrency", "threading", "lock", "thread-safety", "class"],
    "time_limit_seconds": 10
  },
  {
    "id": "con_002",
    "category": "concurrency",
    "difficulty": "medium",
    "title": "Parallel Map",
    "prompt": "from concurrent.futures import ThreadPoolExecutor\n\ndef parallel_map(func, items: list, max_workers: int = 4) -> list:\n    \"\"\"\n    Apply a function to each item in a list using parallel execution with\n    a thread pool. Return the results in the same order as the input items.\n\n    Args:\n        func: A callable to apply to each item.\n        items: A list of items to process.\n        max_workers: Maximum number of threads to use (default 4).\n\n    Returns:\n        A list of results in the same order as the input.\n\n    Examples:\n        parallel_map(lambda x: x ** 2, [1, 2, 3, 4])  # -> [1, 4, 9, 16]\n        parallel_map(str.upper, [\"hello\", \"world\"])  # -> [\"HELLO\", \"WORLD\"]\n        parallel_map(lambda x: x + 1, [], max_workers=2)  # -> []\n    \"\"\"",
    "reference_solution": "from concurrent.futures import ThreadPoolExecutor\n\ndef parallel_map(func, items: list, max_workers: int = 4) -> list:\n    \"\"\"\n    Apply a function to each item in a list using parallel execution with\n    a thread pool. Return the results in the same order as the input items.\n\n    Args:\n        func: A callable to apply to each item.\n        items: A list of items to process.\n        max_workers: Maximum number of threads to use (default 4).\n\n    Returns:\n        A list of results in the same order as the input.\n\n    Examples:\n        parallel_map(lambda x: x ** 2, [1, 2, 3, 4])  # -> [1, 4, 9, 16]\n        parallel_map(str.upper, [\"hello\", \"world\"])  # -> [\"HELLO\", \"WORLD\"]\n        parallel_map(lambda x: x + 1, [], max_workers=2)  # -> []\n    \"\"\"\n    with ThreadPoolExecutor(max_workers=max_workers) as executor:\n        results = list(executor.map(func, items))\n    return results",
    "test_code": "import unittest\nimport time\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass TestParallelMap(unittest.TestCase):\n    def test_square(self):\n        result = parallel_map(lambda x: x ** 2, [1, 2, 3, 4])\n        self.assertEqual(result, [1, 4, 9, 16])\n\n    def test_string_upper(self):\n        result = parallel_map(str.upper, [\"hello\", \"world\"])\n        self.assertEqual(result, [\"HELLO\", \"WORLD\"])\n\n    def test_empty_list(self):\n        result = parallel_map(lambda x: x + 1, [])\n        self.assertEqual(result, [])\n\n    def test_single_item(self):\n        result = parallel_map(lambda x: x * 3, [7])\n        self.assertEqual(result, [21])\n\n    def test_preserves_order(self):\n        result = parallel_map(lambda x: x, list(range(100)))\n        self.assertEqual(result, list(range(100)))\n\n    def test_custom_workers(self):\n        result = parallel_map(lambda x: x + 1, [1, 2, 3], max_workers=2)\n        self.assertEqual(result, [2, 3, 4])\n\n    def test_identity(self):\n        items = [\"a\", \"b\", \"c\", \"d\"]\n        result = parallel_map(lambda x: x, items)\n        self.assertEqual(result, items)\n\n    def test_type_conversion(self):\n        result = parallel_map(str, [1, 2, 3, 4, 5])\n        self.assertEqual(result, [\"1\", \"2\", \"3\", \"4\", \"5\"])\n\n    def test_returns_list(self):\n        result = parallel_map(lambda x: x, [1, 2])\n        self.assertIsInstance(result, list)\n\n    def test_actually_parallel(self):\n        def slow_func(x):\n            time.sleep(0.1)\n            return x * 2\n        start = time.time()\n        result = parallel_map(slow_func, list(range(8)), max_workers=8)\n        elapsed = time.time() - start\n        self.assertEqual(result, [0, 2, 4, 6, 8, 10, 12, 14])\n        self.assertLess(elapsed, 0.5)",
    "tags": ["concurrency", "threading", "threadpool", "parallel", "map"],
    "time_limit_seconds": 10
  },
  {
    "id": "con_003",
    "category": "concurrency",
    "difficulty": "medium",
    "title": "Producer Consumer",
    "prompt": "import threading\nimport queue\n\ndef producer_consumer(producers: list, consumers: list, queue_size: int = 10) -> list:\n    \"\"\"\n    Implement the producer-consumer pattern using threading and queue.Queue.\n\n    Args:\n        producers: A list of callables. Each producer callable, when called,\n            returns a list of items to be placed on the queue.\n        consumers: A list of callables. Each consumer callable takes a single\n            item from the queue and returns a processed result.\n        queue_size: Maximum size of the shared queue (default 10).\n\n    Behavior:\n        - Create a bounded Queue with the given queue_size.\n        - Start one thread per consumer FIRST. Each consumer thread loops:\n          gets an item from the queue, and if it's None (sentinel), stops.\n          Otherwise, calls its consumer callable on the item and collects\n          the result.\n        - Start one thread per producer. Each producer thread calls its callable\n          to get items, then puts each item on the queue.\n        - Wait for all producer threads to finish.\n        - Put one sentinel None per consumer on the queue.\n        - Wait for all consumer threads to finish.\n        - Return ALL consumed (processed) results as a single flat list.\n          The order of results does not need to match input order.\n\n    Examples:\n        results = producer_consumer(\n            producers=[lambda: [1, 2, 3], lambda: [4, 5]],\n            consumers=[lambda x: x * 2],\n            queue_size=5\n        )\n        sorted(results)  # -> [2, 4, 6, 8, 10]\n    \"\"\"",
    "reference_solution": "import threading\nimport queue\n\ndef producer_consumer(producers: list, consumers: list, queue_size: int = 10) -> list:\n    \"\"\"\n    Implement the producer-consumer pattern using threading and queue.Queue.\n\n    Args:\n        producers: A list of callables. Each producer callable, when called,\n            returns a list of items to be placed on the queue.\n        consumers: A list of callables. Each consumer callable takes a single\n            item from the queue and returns a processed result.\n        queue_size: Maximum size of the shared queue (default 10).\n\n    Behavior:\n        - Create a bounded Queue with the given queue_size.\n        - Start one thread per consumer FIRST. Each consumer thread loops:\n          gets an item from the queue, and if it's None (sentinel), stops.\n          Otherwise, calls its consumer callable on the item and collects\n          the result.\n        - Start one thread per producer. Each producer thread calls its callable\n          to get items, then puts each item on the queue.\n        - Wait for all producer threads to finish.\n        - Put one sentinel None per consumer on the queue.\n        - Wait for all consumer threads to finish.\n        - Return ALL consumed (processed) results as a single flat list.\n          The order of results does not need to match input order.\n\n    Examples:\n        results = producer_consumer(\n            producers=[lambda: [1, 2, 3], lambda: [4, 5]],\n            consumers=[lambda x: x * 2],\n            queue_size=5\n        )\n        sorted(results)  # -> [2, 4, 6, 8, 10]\n    \"\"\"\n    q = queue.Queue(maxsize=queue_size)\n    all_results = []\n    results_lock = threading.Lock()\n\n    def producer_worker(producer_func):\n        items = producer_func()\n        for item in items:\n            q.put(item)\n\n    def consumer_worker(consumer_func):\n        while True:\n            item = q.get()\n            if item is None:\n                break\n            result = consumer_func(item)\n            with results_lock:\n                all_results.append(result)\n\n    consumer_threads = []\n    for c in consumers:\n        t = threading.Thread(target=consumer_worker, args=(c,))\n        consumer_threads.append(t)\n        t.start()\n\n    producer_threads = []\n    for p in producers:\n        t = threading.Thread(target=producer_worker, args=(p,))\n        producer_threads.append(t)\n        t.start()\n\n    for t in producer_threads:\n        t.join()\n\n    for _ in consumers:\n        q.put(None)\n\n    for t in consumer_threads:\n        t.join()\n\n    return all_results",
    "test_code": "import unittest\nimport threading\nimport queue\n\nclass TestProducerConsumer(unittest.TestCase):\n    def test_basic(self):\n        results = producer_consumer(\n            producers=[lambda: [1, 2, 3]],\n            consumers=[lambda x: x * 2],\n            queue_size=5\n        )\n        self.assertEqual(sorted(results), [2, 4, 6])\n\n    def test_multiple_producers(self):\n        results = producer_consumer(\n            producers=[lambda: [1, 2, 3], lambda: [4, 5]],\n            consumers=[lambda x: x * 2],\n            queue_size=5\n        )\n        self.assertEqual(sorted(results), [2, 4, 6, 8, 10])\n\n    def test_multiple_consumers(self):\n        results = producer_consumer(\n            producers=[lambda: [10, 20, 30, 40]],\n            consumers=[lambda x: x + 1, lambda x: x + 1],\n            queue_size=5\n        )\n        self.assertEqual(sorted(results), [11, 21, 31, 41])\n\n    def test_empty_producers(self):\n        results = producer_consumer(\n            producers=[lambda: []],\n            consumers=[lambda x: x],\n            queue_size=5\n        )\n        self.assertEqual(results, [])\n\n    def test_string_processing(self):\n        results = producer_consumer(\n            producers=[lambda: [\"hello\", \"world\"]],\n            consumers=[str.upper],\n            queue_size=5\n        )\n        self.assertEqual(sorted(results), [\"HELLO\", \"WORLD\"])\n\n    def test_small_queue(self):\n        results = producer_consumer(\n            producers=[lambda: list(range(20))],\n            consumers=[lambda x: x * 10],\n            queue_size=2\n        )\n        self.assertEqual(sorted(results), [x * 10 for x in range(20)])\n\n    def test_returns_list(self):\n        results = producer_consumer(\n            producers=[lambda: [1]],\n            consumers=[lambda x: x],\n            queue_size=5\n        )\n        self.assertIsInstance(results, list)\n\n    def test_result_count(self):\n        results = producer_consumer(\n            producers=[lambda: [1, 2], lambda: [3, 4, 5]],\n            consumers=[lambda x: x],\n            queue_size=5\n        )\n        self.assertEqual(len(results), 5)\n\n    def test_consumer_transforms(self):\n        results = producer_consumer(\n            producers=[lambda: [2, 3, 4]],\n            consumers=[lambda x: x ** 2],\n            queue_size=10\n        )\n        self.assertEqual(sorted(results), [4, 9, 16])",
    "tags": ["concurrency", "threading", "queue", "producer-consumer", "synchronization"],
    "time_limit_seconds": 10
  },
  {
    "id": "con_004",
    "category": "concurrency",
    "difficulty": "hard",
    "title": "Async Gather with Timeout",
    "prompt": "import asyncio\n\nasync def async_gather_results(async_callables: list, timeout: float = None) -> list:\n    \"\"\"\n    Run a list of async callables (coroutine functions) concurrently and\n    return their results.\n\n    Args:\n        async_callables: A list of async callables (coroutine functions that\n            take no arguments). Each one, when called, returns a coroutine.\n        timeout: Optional timeout in seconds. If provided and the total\n            execution exceeds this duration, raise asyncio.TimeoutError.\n            If None, no timeout is applied.\n\n    Returns:\n        A list of results in the same order as the input callables.\n\n    Behavior:\n        - Call each async callable to create a coroutine.\n        - Run all coroutines concurrently using asyncio.gather.\n        - If timeout is specified, use asyncio.wait_for to enforce the timeout\n          around the gather call.\n        - Return the list of results.\n\n    Examples:\n        async def make_value(v):\n            await asyncio.sleep(0.01)\n            return v\n\n        results = await async_gather_results([\n            lambda: make_value(1),\n            lambda: make_value(2),\n            lambda: make_value(3)\n        ])\n        # results -> [1, 2, 3]\n\n        # With timeout (this would raise asyncio.TimeoutError if too slow):\n        results = await async_gather_results(\n            [lambda: make_value(42)],\n            timeout=5.0\n        )\n        # results -> [42]\n    \"\"\"",
    "reference_solution": "import asyncio\n\nasync def async_gather_results(async_callables: list, timeout: float = None) -> list:\n    \"\"\"\n    Run a list of async callables (coroutine functions) concurrently and\n    return their results.\n\n    Args:\n        async_callables: A list of async callables (coroutine functions that\n            take no arguments). Each one, when called, returns a coroutine.\n        timeout: Optional timeout in seconds. If provided and the total\n            execution exceeds this duration, raise asyncio.TimeoutError.\n            If None, no timeout is applied.\n\n    Returns:\n        A list of results in the same order as the input callables.\n\n    Behavior:\n        - Call each async callable to create a coroutine.\n        - Run all coroutines concurrently using asyncio.gather.\n        - If timeout is specified, use asyncio.wait_for to enforce the timeout\n          around the gather call.\n        - Return the list of results.\n\n    Examples:\n        async def make_value(v):\n            await asyncio.sleep(0.01)\n            return v\n\n        results = await async_gather_results([\n            lambda: make_value(1),\n            lambda: make_value(2),\n            lambda: make_value(3)\n        ])\n        # results -> [1, 2, 3]\n\n        # With timeout (this would raise asyncio.TimeoutError if too slow):\n        results = await async_gather_results(\n            [lambda: make_value(42)],\n            timeout=5.0\n        )\n        # results -> [42]\n    \"\"\"\n    coroutines = [c() for c in async_callables]\n    gathered = asyncio.gather(*coroutines)\n    if timeout is not None:\n        results = await asyncio.wait_for(gathered, timeout=timeout)\n    else:\n        results = await gathered\n    return list(results)",
    "test_code": "import unittest\nimport asyncio\n\nclass TestAsyncGatherResults(unittest.TestCase):\n    def _run(self, coro):\n        return asyncio.get_event_loop().run_until_complete(coro)\n\n    def setUp(self):\n        try:\n            self.loop = asyncio.get_event_loop()\n            if self.loop.is_closed():\n                raise RuntimeError\n        except RuntimeError:\n            self.loop = asyncio.new_event_loop()\n            asyncio.set_event_loop(self.loop)\n\n    def test_basic(self):\n        async def make_value(v):\n            return v\n        result = self._run(async_gather_results([\n            lambda: make_value(1),\n            lambda: make_value(2),\n            lambda: make_value(3)\n        ]))\n        self.assertEqual(result, [1, 2, 3])\n\n    def test_empty(self):\n        result = self._run(async_gather_results([]))\n        self.assertEqual(result, [])\n\n    def test_single(self):\n        async def get_42():\n            return 42\n        result = self._run(async_gather_results([get_42]))\n        self.assertEqual(result, [42])\n\n    def test_preserves_order(self):\n        async def delayed(val, delay):\n            await asyncio.sleep(delay)\n            return val\n        result = self._run(async_gather_results([\n            lambda: delayed(\"slow\", 0.05),\n            lambda: delayed(\"fast\", 0.01),\n            lambda: delayed(\"medium\", 0.03)\n        ]))\n        self.assertEqual(result, [\"slow\", \"fast\", \"medium\"])\n\n    def test_with_timeout_success(self):\n        async def quick():\n            await asyncio.sleep(0.01)\n            return \"done\"\n        result = self._run(async_gather_results([quick], timeout=5.0))\n        self.assertEqual(result, [\"done\"])\n\n    def test_with_timeout_failure(self):\n        async def very_slow():\n            await asyncio.sleep(10)\n            return \"never\"\n        with self.assertRaises(asyncio.TimeoutError):\n            self._run(async_gather_results([very_slow], timeout=0.1))\n\n    def test_no_timeout(self):\n        async def get_val():\n            return 99\n        result = self._run(async_gather_results([get_val], timeout=None))\n        self.assertEqual(result, [99])\n\n    def test_concurrent_execution(self):\n        import time\n        async def sleep_and_return(val):\n            await asyncio.sleep(0.1)\n            return val\n        start = time.time()\n        result = self._run(async_gather_results([\n            lambda: sleep_and_return(1),\n            lambda: sleep_and_return(2),\n            lambda: sleep_and_return(3),\n            lambda: sleep_and_return(4)\n        ]))\n        elapsed = time.time() - start\n        self.assertEqual(result, [1, 2, 3, 4])\n        self.assertLess(elapsed, 0.5)\n\n    def test_returns_list(self):\n        async def noop():\n            return None\n        result = self._run(async_gather_results([noop]))\n        self.assertIsInstance(result, list)\n\n    def test_mixed_return_types(self):\n        async def get_int():\n            return 1\n        async def get_str():\n            return \"hello\"\n        async def get_list():\n            return [1, 2]\n        result = self._run(async_gather_results([get_int, get_str, get_list]))\n        self.assertEqual(result, [1, \"hello\", [1, 2]])\n\n    def test_many_coroutines(self):\n        async def make_val(v):\n            return v\n        callables = [lambda v=i: make_val(v) for i in range(50)]\n        result = self._run(async_gather_results(callables))\n        self.assertEqual(result, list(range(50)))",
    "tags": ["concurrency", "asyncio", "async", "gather", "timeout", "coroutines"],
    "time_limit_seconds": 15
  }
]

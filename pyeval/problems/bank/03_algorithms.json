[
  {
    "id": "algo_001",
    "category": "algorithms",
    "difficulty": "easy",
    "title": "Binary Search",
    "prompt": "def binary_search(arr: list[int], target: int) -> int:\n    \"\"\"Search for target in a sorted list of integers using binary search.\n\n    Args:\n        arr: A sorted list of integers in ascending order.\n        target: The integer to search for.\n\n    Returns:\n        The index of target in arr if found, otherwise -1.\n    \"\"\"",
    "reference_solution": "def binary_search(arr: list[int], target: int) -> int:\n    \"\"\"Search for target in a sorted list of integers using binary search.\n\n    Args:\n        arr: A sorted list of integers in ascending order.\n        target: The integer to search for.\n\n    Returns:\n        The index of target in arr if found, otherwise -1.\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1",
    "test_code": "import unittest\n\nclass TestBinarySearch(unittest.TestCase):\n    def test_found_middle(self):\n        self.assertEqual(binary_search([1, 3, 5, 7, 9], 5), 2)\n\n    def test_found_first(self):\n        self.assertEqual(binary_search([1, 3, 5, 7, 9], 1), 0)\n\n    def test_found_last(self):\n        self.assertEqual(binary_search([1, 3, 5, 7, 9], 9), 4)\n\n    def test_not_found(self):\n        self.assertEqual(binary_search([1, 3, 5, 7, 9], 4), -1)\n\n    def test_empty_list(self):\n        self.assertEqual(binary_search([], 5), -1)\n\n    def test_single_element_found(self):\n        self.assertEqual(binary_search([5], 5), 0)\n\n    def test_single_element_not_found(self):\n        self.assertEqual(binary_search([5], 3), -1)\n\n    def test_two_elements(self):\n        self.assertEqual(binary_search([1, 2], 2), 1)\n\n    def test_negative_numbers(self):\n        self.assertEqual(binary_search([-10, -5, 0, 5, 10], -5), 1)\n\n    def test_target_too_small(self):\n        self.assertEqual(binary_search([2, 4, 6, 8], 1), -1)\n\n    def test_target_too_large(self):\n        self.assertEqual(binary_search([2, 4, 6, 8], 10), -1)",
    "tags": ["binary_search", "search", "divide_and_conquer"],
    "time_limit_seconds": 5
  },
  {
    "id": "algo_002",
    "category": "algorithms",
    "difficulty": "easy",
    "title": "Bubble Sort",
    "prompt": "def bubble_sort(arr: list[int]) -> list[int]:\n    \"\"\"Sort a list of integers in ascending order using bubble sort.\n\n    Args:\n        arr: A list of integers to sort.\n\n    Returns:\n        A new list containing the same elements sorted in ascending order.\n        The original list must not be modified.\n    \"\"\"",
    "reference_solution": "def bubble_sort(arr: list[int]) -> list[int]:\n    \"\"\"Sort a list of integers in ascending order using bubble sort.\n\n    Args:\n        arr: A list of integers to sort.\n\n    Returns:\n        A new list containing the same elements sorted in ascending order.\n        The original list must not be modified.\n    \"\"\"\n    result = arr[:]\n    n = len(result)\n    for i in range(n):\n        swapped = False\n        for j in range(0, n - i - 1):\n            if result[j] > result[j + 1]:\n                result[j], result[j + 1] = result[j + 1], result[j]\n                swapped = True\n        if not swapped:\n            break\n    return result",
    "test_code": "import unittest\n\nclass TestBubbleSort(unittest.TestCase):\n    def test_basic(self):\n        self.assertEqual(bubble_sort([5, 3, 1, 4, 2]), [1, 2, 3, 4, 5])\n\n    def test_already_sorted(self):\n        self.assertEqual(bubble_sort([1, 2, 3, 4, 5]), [1, 2, 3, 4, 5])\n\n    def test_reverse_sorted(self):\n        self.assertEqual(bubble_sort([5, 4, 3, 2, 1]), [1, 2, 3, 4, 5])\n\n    def test_empty(self):\n        self.assertEqual(bubble_sort([]), [])\n\n    def test_single_element(self):\n        self.assertEqual(bubble_sort([42]), [42])\n\n    def test_duplicates(self):\n        self.assertEqual(bubble_sort([3, 1, 2, 3, 1]), [1, 1, 2, 3, 3])\n\n    def test_negative_numbers(self):\n        self.assertEqual(bubble_sort([-3, -1, -2, 0, 2]), [-3, -2, -1, 0, 2])\n\n    def test_does_not_modify_original(self):\n        original = [5, 3, 1, 4, 2]\n        copy = original[:]\n        bubble_sort(original)\n        self.assertEqual(original, copy)\n\n    def test_all_same(self):\n        self.assertEqual(bubble_sort([7, 7, 7, 7]), [7, 7, 7, 7])",
    "tags": ["sorting", "bubble_sort"],
    "time_limit_seconds": 10
  },
  {
    "id": "algo_003",
    "category": "algorithms",
    "difficulty": "medium",
    "title": "Merge Sort",
    "prompt": "def merge_sort(arr: list[int]) -> list[int]:\n    \"\"\"Sort a list of integers in ascending order using merge sort.\n\n    Args:\n        arr: A list of integers to sort.\n\n    Returns:\n        A new sorted list. The original list must not be modified.\n    \"\"\"",
    "reference_solution": "def merge_sort(arr: list[int]) -> list[int]:\n    \"\"\"Sort a list of integers in ascending order using merge sort.\n\n    Args:\n        arr: A list of integers to sort.\n\n    Returns:\n        A new sorted list. The original list must not be modified.\n    \"\"\"\n    if len(arr) <= 1:\n        return arr[:]\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    return _merge(left, right)\n\ndef _merge(left: list[int], right: list[int]) -> list[int]:\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result",
    "test_code": "import unittest\n\nclass TestMergeSort(unittest.TestCase):\n    def test_basic(self):\n        self.assertEqual(merge_sort([5, 3, 1, 4, 2]), [1, 2, 3, 4, 5])\n\n    def test_already_sorted(self):\n        self.assertEqual(merge_sort([1, 2, 3, 4, 5]), [1, 2, 3, 4, 5])\n\n    def test_reverse_sorted(self):\n        self.assertEqual(merge_sort([5, 4, 3, 2, 1]), [1, 2, 3, 4, 5])\n\n    def test_empty(self):\n        self.assertEqual(merge_sort([]), [])\n\n    def test_single_element(self):\n        self.assertEqual(merge_sort([42]), [42])\n\n    def test_duplicates(self):\n        self.assertEqual(merge_sort([3, 1, 2, 3, 1]), [1, 1, 2, 3, 3])\n\n    def test_negative_numbers(self):\n        self.assertEqual(merge_sort([-3, -1, -2, 0, 2]), [-3, -2, -1, 0, 2])\n\n    def test_does_not_modify_original(self):\n        original = [5, 3, 1, 4, 2]\n        copy = original[:]\n        merge_sort(original)\n        self.assertEqual(original, copy)\n\n    def test_large_list(self):\n        import random\n        arr = list(range(100, 0, -1))\n        self.assertEqual(merge_sort(arr), list(range(1, 101)))\n\n    def test_two_elements(self):\n        self.assertEqual(merge_sort([2, 1]), [1, 2])\n\n    def test_stability_order(self):\n        self.assertEqual(merge_sort([3, 3, 1, 1, 2, 2]), [1, 1, 2, 2, 3, 3])",
    "tags": ["sorting", "merge_sort", "divide_and_conquer", "recursion"],
    "time_limit_seconds": 10
  },
  {
    "id": "algo_004",
    "category": "algorithms",
    "difficulty": "medium",
    "title": "Longest Common Subsequence",
    "prompt": "def longest_common_subsequence(s1: str, s2: str) -> int:\n    \"\"\"Find the length of the longest common subsequence of two strings.\n\n    A subsequence is a sequence that can be derived from another sequence\n    by deleting some or no elements without changing the order of the\n    remaining elements.\n\n    Args:\n        s1: The first string.\n        s2: The second string.\n\n    Returns:\n        The length of the longest common subsequence.\n    \"\"\"",
    "reference_solution": "def longest_common_subsequence(s1: str, s2: str) -> int:\n    \"\"\"Find the length of the longest common subsequence of two strings.\n\n    A subsequence is a sequence that can be derived from another sequence\n    by deleting some or no elements without changing the order of the\n    remaining elements.\n\n    Args:\n        s1: The first string.\n        s2: The second string.\n\n    Returns:\n        The length of the longest common subsequence.\n    \"\"\"\n    m, n = len(s1), len(s2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    return dp[m][n]",
    "test_code": "import unittest\n\nclass TestLongestCommonSubsequence(unittest.TestCase):\n    def test_basic(self):\n        self.assertEqual(longest_common_subsequence(\"abcde\", \"ace\"), 3)\n\n    def test_identical(self):\n        self.assertEqual(longest_common_subsequence(\"abc\", \"abc\"), 3)\n\n    def test_no_common(self):\n        self.assertEqual(longest_common_subsequence(\"abc\", \"xyz\"), 0)\n\n    def test_empty_first(self):\n        self.assertEqual(longest_common_subsequence(\"\", \"abc\"), 0)\n\n    def test_empty_second(self):\n        self.assertEqual(longest_common_subsequence(\"abc\", \"\"), 0)\n\n    def test_both_empty(self):\n        self.assertEqual(longest_common_subsequence(\"\", \"\"), 0)\n\n    def test_single_char_match(self):\n        self.assertEqual(longest_common_subsequence(\"a\", \"a\"), 1)\n\n    def test_single_char_no_match(self):\n        self.assertEqual(longest_common_subsequence(\"a\", \"b\"), 0)\n\n    def test_longer_strings(self):\n        self.assertEqual(longest_common_subsequence(\"AGGTAB\", \"GXTXAYB\"), 4)\n\n    def test_subsequence_not_substring(self):\n        self.assertEqual(longest_common_subsequence(\"abcbdab\", \"bdcaba\"), 4)\n\n    def test_one_is_subsequence(self):\n        self.assertEqual(longest_common_subsequence(\"ace\", \"abcde\"), 3)",
    "tags": ["dynamic_programming", "lcs", "strings"],
    "time_limit_seconds": 10
  },
  {
    "id": "algo_005",
    "category": "algorithms",
    "difficulty": "medium",
    "title": "Valid Parentheses",
    "prompt": "def valid_parentheses(s: str) -> bool:\n    \"\"\"Check if a string of brackets is valid.\n\n    A string is valid if:\n    - Open brackets are closed by the same type of brackets.\n    - Open brackets are closed in the correct order.\n    - Every close bracket has a corresponding open bracket of the same type.\n\n    Supported bracket types: (), [], {}\n\n    Args:\n        s: A string containing only the characters '(', ')', '[', ']', '{', '}'.\n\n    Returns:\n        True if the string is valid, False otherwise.\n    \"\"\"",
    "reference_solution": "def valid_parentheses(s: str) -> bool:\n    \"\"\"Check if a string of brackets is valid.\n\n    A string is valid if:\n    - Open brackets are closed by the same type of brackets.\n    - Open brackets are closed in the correct order.\n    - Every close bracket has a corresponding open bracket of the same type.\n\n    Supported bracket types: (), [], {}\n\n    Args:\n        s: A string containing only the characters '(', ')', '[', ']', '{', '}'.\n\n    Returns:\n        True if the string is valid, False otherwise.\n    \"\"\"\n    stack = []\n    matching = {')': '(', ']': '[', '}': '{'}\n    for char in s:\n        if char in '([{':\n            stack.append(char)\n        elif char in ')]}': \n            if not stack or stack[-1] != matching[char]:\n                return False\n            stack.pop()\n    return len(stack) == 0",
    "test_code": "import unittest\n\nclass TestValidParentheses(unittest.TestCase):\n    def test_simple_valid(self):\n        self.assertTrue(valid_parentheses(\"()\"))\n\n    def test_multiple_types(self):\n        self.assertTrue(valid_parentheses(\"()[]{}\" ))\n\n    def test_nested(self):\n        self.assertTrue(valid_parentheses(\"{[()]}\"))\n\n    def test_invalid_mismatch(self):\n        self.assertFalse(valid_parentheses(\"(]\"))\n\n    def test_invalid_unclosed(self):\n        self.assertFalse(valid_parentheses(\"((\"))\n\n    def test_invalid_extra_close(self):\n        self.assertFalse(valid_parentheses(\"())\"))\n\n    def test_empty_string(self):\n        self.assertTrue(valid_parentheses(\"\"))\n\n    def test_single_open(self):\n        self.assertFalse(valid_parentheses(\"(\"))\n\n    def test_single_close(self):\n        self.assertFalse(valid_parentheses(\")\"))\n\n    def test_complex_valid(self):\n        self.assertTrue(valid_parentheses(\"({[]}[()])\" ))\n\n    def test_complex_invalid(self):\n        self.assertFalse(valid_parentheses(\"({[}])\"))\n\n    def test_interleaved_invalid(self):\n        self.assertFalse(valid_parentheses(\"([)]\"))\n\n    def test_long_valid(self):\n        self.assertTrue(valid_parentheses(\"()\" * 100))",
    "tags": ["stack", "parentheses", "validation"],
    "time_limit_seconds": 5
  },
  {
    "id": "algo_006",
    "category": "algorithms",
    "difficulty": "hard",
    "title": "0/1 Knapsack",
    "prompt": "def knapsack_01(weights: list[int], values: list[int], capacity: int) -> int:\n    \"\"\"Solve the 0/1 knapsack problem.\n\n    Given a set of items, each with a weight and a value, determine the\n    maximum total value that can be achieved by selecting items such that\n    the total weight does not exceed the given capacity. Each item can\n    either be included or excluded (no fractions).\n\n    Args:\n        weights: A list of positive integer weights for each item.\n        values: A list of positive integer values for each item.\n        capacity: The maximum total weight the knapsack can hold (non-negative integer).\n\n    Returns:\n        The maximum total value achievable within the weight capacity.\n    \"\"\"",
    "reference_solution": "def knapsack_01(weights: list[int], values: list[int], capacity: int) -> int:\n    \"\"\"Solve the 0/1 knapsack problem.\n\n    Given a set of items, each with a weight and a value, determine the\n    maximum total value that can be achieved by selecting items such that\n    the total weight does not exceed the given capacity. Each item can\n    either be included or excluded (no fractions).\n\n    Args:\n        weights: A list of positive integer weights for each item.\n        values: A list of positive integer values for each item.\n        capacity: The maximum total weight the knapsack can hold (non-negative integer).\n\n    Returns:\n        The maximum total value achievable within the weight capacity.\n    \"\"\"\n    n = len(weights)\n    dp = [[0] * (capacity + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for w in range(capacity + 1):\n            dp[i][w] = dp[i - 1][w]\n            if weights[i - 1] <= w:\n                dp[i][w] = max(dp[i][w], dp[i - 1][w - weights[i - 1]] + values[i - 1])\n    return dp[n][capacity]",
    "test_code": "import unittest\n\nclass TestKnapsack01(unittest.TestCase):\n    def test_basic(self):\n        self.assertEqual(knapsack_01([1, 2, 3], [6, 10, 12], 5), 22)\n\n    def test_all_fit(self):\n        self.assertEqual(knapsack_01([1, 2, 3], [10, 20, 30], 10), 60)\n\n    def test_none_fit(self):\n        self.assertEqual(knapsack_01([5, 6, 7], [10, 20, 30], 4), 0)\n\n    def test_zero_capacity(self):\n        self.assertEqual(knapsack_01([1, 2, 3], [10, 20, 30], 0), 0)\n\n    def test_empty_items(self):\n        self.assertEqual(knapsack_01([], [], 10), 0)\n\n    def test_single_item_fits(self):\n        self.assertEqual(knapsack_01([5], [10], 5), 10)\n\n    def test_single_item_no_fit(self):\n        self.assertEqual(knapsack_01([5], [10], 4), 0)\n\n    def test_classic_example(self):\n        weights = [2, 3, 4, 5]\n        values = [3, 4, 5, 6]\n        self.assertEqual(knapsack_01(weights, values, 5), 7)\n\n    def test_pick_lighter_more_valuable(self):\n        self.assertEqual(knapsack_01([10, 1], [5, 6], 10), 6)\n\n    def test_larger_instance(self):\n        weights = [2, 3, 4, 5, 9]\n        values = [3, 4, 8, 8, 10]\n        self.assertEqual(knapsack_01(weights, values, 20), 29)\n\n    def test_equal_weights_and_values(self):\n        self.assertEqual(knapsack_01([3, 3, 3], [3, 3, 3], 6), 6)",
    "tags": ["dynamic_programming", "knapsack", "optimization"],
    "time_limit_seconds": 10
  },
  {
    "id": "algo_007",
    "category": "algorithms",
    "difficulty": "hard",
    "title": "Topological Sort",
    "prompt": "def topological_sort(graph: dict[str, list[str]]) -> list[str]:\n    \"\"\"Return a topological ordering of a directed acyclic graph (DAG).\n\n    Args:\n        graph: An adjacency list representation of a directed graph.\n               Keys are node names (strings), values are lists of nodes\n               that the key node has edges TO. For example,\n               {'a': ['b', 'c']} means edges a->b and a->c.\n               All nodes in the graph appear as keys (even if they\n               have no outgoing edges).\n\n    Returns:\n        A list of node names in a valid topological order. If the graph\n        contains a cycle, return an empty list.\n    \"\"\"",
    "reference_solution": "def topological_sort(graph: dict[str, list[str]]) -> list[str]:\n    \"\"\"Return a topological ordering of a directed acyclic graph (DAG).\n\n    Args:\n        graph: An adjacency list representation of a directed graph.\n               Keys are node names (strings), values are lists of nodes\n               that the key node has edges TO. For example,\n               {'a': ['b', 'c']} means edges a->b and a->c.\n               All nodes in the graph appear as keys (even if they\n               have no outgoing edges).\n\n    Returns:\n        A list of node names in a valid topological order. If the graph\n        contains a cycle, return an empty list.\n    \"\"\"\n    from collections import deque\n    in_degree = {node: 0 for node in graph}\n    for node in graph:\n        for neighbor in graph[node]:\n            in_degree[neighbor] = in_degree.get(neighbor, 0) + 1\n    queue = deque([node for node in graph if in_degree[node] == 0])\n    result = []\n    while queue:\n        node = queue.popleft()\n        result.append(node)\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    if len(result) != len(graph):\n        return []\n    return result",
    "test_code": "import unittest\n\nclass TestTopologicalSort(unittest.TestCase):\n    def _is_valid_topological_order(self, graph, order):\n        if set(order) != set(graph.keys()):\n            return False\n        position = {node: i for i, node in enumerate(order)}\n        for node in graph:\n            for neighbor in graph[node]:\n                if position[node] >= position[neighbor]:\n                    return False\n        return True\n\n    def test_simple_chain(self):\n        graph = {'a': ['b'], 'b': ['c'], 'c': []}\n        result = topological_sort(graph)\n        self.assertTrue(self._is_valid_topological_order(graph, result))\n\n    def test_diamond(self):\n        graph = {'a': ['b', 'c'], 'b': ['d'], 'c': ['d'], 'd': []}\n        result = topological_sort(graph)\n        self.assertTrue(self._is_valid_topological_order(graph, result))\n\n    def test_disconnected(self):\n        graph = {'a': ['b'], 'b': [], 'c': ['d'], 'd': []}\n        result = topological_sort(graph)\n        self.assertTrue(self._is_valid_topological_order(graph, result))\n\n    def test_single_node(self):\n        graph = {'a': []}\n        result = topological_sort(graph)\n        self.assertEqual(result, ['a'])\n\n    def test_no_edges(self):\n        graph = {'a': [], 'b': [], 'c': []}\n        result = topological_sort(graph)\n        self.assertEqual(len(result), 3)\n        self.assertEqual(set(result), {'a', 'b', 'c'})\n\n    def test_cycle_returns_empty(self):\n        graph = {'a': ['b'], 'b': ['c'], 'c': ['a']}\n        result = topological_sort(graph)\n        self.assertEqual(result, [])\n\n    def test_self_loop_returns_empty(self):\n        graph = {'a': ['a']}\n        result = topological_sort(graph)\n        self.assertEqual(result, [])\n\n    def test_complex_dag(self):\n        graph = {\n            'a': ['b', 'c'],\n            'b': ['d'],\n            'c': ['d', 'e'],\n            'd': ['f'],\n            'e': ['f'],\n            'f': []\n        }\n        result = topological_sort(graph)\n        self.assertTrue(self._is_valid_topological_order(graph, result))\n\n    def test_empty_graph(self):\n        graph = {}\n        result = topological_sort(graph)\n        self.assertEqual(result, [])\n\n    def test_two_node_cycle(self):\n        graph = {'a': ['b'], 'b': ['a']}\n        result = topological_sort(graph)\n        self.assertEqual(result, [])\n\n    def test_partial_cycle(self):\n        graph = {'a': ['b'], 'b': ['c'], 'c': ['b'], 'd': []}\n        result = topological_sort(graph)\n        self.assertEqual(result, [])",
    "tags": ["graph", "topological_sort", "bfs", "kahn_algorithm", "dag"],
    "time_limit_seconds": 10
  }
]

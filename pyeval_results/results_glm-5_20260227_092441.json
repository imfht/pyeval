[
  {
    "id": "algo_001",
    "category": "algorithms",
    "difficulty": "easy",
    "title": "Binary Search",
    "passed": true,
    "error": null,
    "generated_code": "def binary_search(arr: list[int], target: int) -> int:\n    \"\"\"Search for target in a sorted list of integers using binary search.\n\n    Args:\n        arr: A sorted list of integers in ascending order.\n        target: The integer to search for.\n\n    Returns:\n        The index of target in arr if found, otherwise -1.\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1",
    "stdout": "",
    "stderr": "...........\n----------------------------------------------------------------------\nRan 11 tests in 0.000s\n\nOK\n"
  },
  {
    "id": "algo_002",
    "category": "algorithms",
    "difficulty": "easy",
    "title": "Bubble Sort",
    "passed": true,
    "error": null,
    "generated_code": "def bubble_sort(arr: list[int]) -> list[int]:\n    \"\"\"Sort a list of integers in ascending order using bubble sort.\n\n    Args:\n        arr: A list of integers to sort.\n\n    Returns:\n        A new list containing the same elements sorted in ascending order.\n        The original list must not be modified.\n    \"\"\"\n    result = list(arr)\n    n = len(result)\n    \n    for i in range(n):\n        for j in range(0, n - i - 1):\n            if result[j] > result[j + 1]:\n                result[j], result[j + 1] = result[j + 1], result[j]\n    \n    return result",
    "stdout": "",
    "stderr": ".........\n----------------------------------------------------------------------\nRan 9 tests in 0.000s\n\nOK\n"
  },
  {
    "id": "algo_003",
    "category": "algorithms",
    "difficulty": "medium",
    "title": "Merge Sort",
    "passed": true,
    "error": null,
    "generated_code": "def merge_sort(arr: list[int]) -> list[int]:\n    \"\"\"Sort a list of integers in ascending order using merge sort.\n\n    Args:\n        arr: A list of integers to sort.\n\n    Returns:\n        A new sorted list. The original list must not be modified.\n    \"\"\"\n    def merge(left: list[int], right: list[int]) -> list[int]:\n        \"\"\"Merge two sorted lists into one sorted list.\"\"\"\n        result = []\n        i = j = 0\n        \n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n        \n        # Add remaining elements\n        result.extend(left[i:])\n        result.extend(right[j:])\n        \n        return result\n    \n    # Base case: list with 0 or 1 elements is already sorted\n    if len(arr) <= 1:\n        return arr.copy()\n    \n    # Divide the list into two halves\n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n    \n    # Merge the sorted halves\n    return merge(left_half, right_half)",
    "stdout": "",
    "stderr": "...........\n----------------------------------------------------------------------\nRan 11 tests in 0.002s\n\nOK\n"
  },
  {
    "id": "algo_004",
    "category": "algorithms",
    "difficulty": "medium",
    "title": "Longest Common Subsequence",
    "passed": true,
    "error": null,
    "generated_code": "def longest_common_subsequence(s1: str, s2: str) -> int:\n    \"\"\"Find the length of the longest common subsequence of two strings.\n\n    A subsequence is a sequence that can be derived from another sequence\n    by deleting some or no elements without changing the order of the\n    remaining elements.\n\n    Args:\n        s1: The first string.\n        s2: The second string.\n\n    Returns:\n        The length of the longest common subsequence.\n    \"\"\"\n    m, n = len(s1), len(s2)\n    \n    # Create a 2D DP table with (m+1) x (n+1) dimensions\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    \n    return dp[m][n]",
    "stdout": "",
    "stderr": "...........\n----------------------------------------------------------------------\nRan 11 tests in 0.000s\n\nOK\n"
  },
  {
    "id": "algo_005",
    "category": "algorithms",
    "difficulty": "medium",
    "title": "Valid Parentheses",
    "passed": true,
    "error": null,
    "generated_code": "def valid_parentheses(s: str) -> bool:\n    \"\"\"Check if a string of brackets is valid.\n\n    A string is valid if:\n    - Open brackets are closed by the same type of brackets.\n    - Open brackets are closed in the correct order.\n    - Every close bracket has a corresponding open bracket of the same type.\n\n    Supported bracket types: (), [], {}\n\n    Args:\n        s: A string containing only the characters '(', ')', '[', ']', '{', '}'.\n\n    Returns:\n        True if the string is valid, False otherwise.\n    \"\"\"\n    stack = []\n    mapping = {')': '(', ']': '[', '}': '{'}\n    \n    for char in s:\n        if char in mapping.values():\n            stack.append(char)\n        else:\n            if not stack or stack[-1] != mapping[char]:\n                return False\n            stack.pop()\n    \n    return len(stack) == 0",
    "stdout": "",
    "stderr": ".............\n----------------------------------------------------------------------\nRan 13 tests in 0.000s\n\nOK\n"
  },
  {
    "id": "algo_006",
    "category": "algorithms",
    "difficulty": "hard",
    "title": "0/1 Knapsack",
    "passed": false,
    "error": "API request timed out",
    "generated_code": "",
    "stdout": "",
    "stderr": ""
  },
  {
    "id": "algo_007",
    "category": "algorithms",
    "difficulty": "hard",
    "title": "Topological Sort",
    "passed": true,
    "error": null,
    "generated_code": "def topological_sort(graph: dict[str, list[str]]) -> list[str]:\n    \"\"\"Return a topological ordering of a directed acyclic graph (DAG).\n\n    Args:\n        graph: An adjacency list representation of a directed graph.\n               Keys are node names (strings), values are lists of nodes\n               that the key node has edges TO. For example,\n               {'a': ['b', 'c']} means edges a->b and a->c.\n               All nodes in the graph appear as keys (even if they\n               have no outgoing edges).\n\n    Returns:\n        A list of node names in a valid topological order. If the graph\n        contains a cycle, return an empty list.\n    \"\"\"\n    from collections import deque\n    \n    # Calculate in-degree for each node\n    in_degree = {node: 0 for node in graph}\n    for node in graph:\n        for neighbor in graph[node]:\n            in_degree[neighbor] += 1\n    \n    # Initialize queue with all nodes having in-degree 0\n    queue = deque([node for node in graph if in_degree[node] == 0])\n    result = []\n    \n    # Process nodes in topological order\n    while queue:\n        node = queue.popleft()\n        result.append(node)\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    # If not all nodes are in result, there's a cycle\n    if len(result) == len(graph):\n        return result\n    else:\n        return []",
    "stdout": "",
    "stderr": "...........\n----------------------------------------------------------------------\nRan 11 tests in 0.001s\n\nOK\n"
  },
  {
    "id": "bs_001",
    "category": "basic_syntax",
    "difficulty": "easy",
    "title": "FizzBuzz",
    "passed": true,
    "error": null,
    "generated_code": "def fizzbuzz(n: int) -> list:\n    \"\"\"\n    Given a positive integer n, return a list of strings from 1 to n where:\n    - Multiples of 3 are replaced with \"Fizz\"\n    - Multiples of 5 are replaced with \"Buzz\"\n    - Multiples of both 3 and 5 are replaced with \"FizzBuzz\"\n    - All other numbers are converted to their string representation\n\n    Example:\n        fizzbuzz(5) -> [\"1\", \"2\", \"Fizz\", \"4\", \"Buzz\"]\n        fizzbuzz(15) -> [\"1\", \"2\", \"Fizz\", \"4\", \"Buzz\", \"Fizz\", \"7\", \"8\", \"Fizz\", \"Buzz\", \"11\", \"Fizz\", \"13\", \"14\", \"FizzBuzz\"]\n    \"\"\"\n    result = []\n    for i in range(1, n + 1):\n        if i % 3 == 0 and i % 5 == 0:\n            result.append(\"FizzBuzz\")\n        elif i % 3 == 0:\n            result.append(\"Fizz\")\n        elif i % 5 == 0:\n            result.append(\"Buzz\")\n        else:\n            result.append(str(i))\n    return result",
    "stdout": "",
    "stderr": "........\n----------------------------------------------------------------------\nRan 8 tests in 0.000s\n\nOK\n"
  },
  {
    "id": "bs_002",
    "category": "basic_syntax",
    "difficulty": "easy",
    "title": "Swap Variables",
    "passed": true,
    "error": null,
    "generated_code": "def swap_variables(d: dict) -> dict:\n    \"\"\"\n    Given a dictionary with keys 'a' and 'b', return a new dictionary\n    where the values of 'a' and 'b' are swapped.\n\n    The original dictionary must not be modified.\n\n    Example:\n        swap_variables({'a': 1, 'b': 2}) -> {'a': 2, 'b': 1}\n        swap_variables({'a': 'hello', 'b': 'world'}) -> {'a': 'world', 'b': 'hello'}\n    \"\"\"\n    return {'a': d['b'], 'b': d['a']}",
    "stdout": "",
    "stderr": ".......\n----------------------------------------------------------------------\nRan 7 tests in 0.000s\n\nOK\n"
  },
  {
    "id": "bs_003",
    "category": "basic_syntax",
    "difficulty": "easy",
    "title": "Number to Words",
    "passed": false,
    "error": "API request timed out",
    "generated_code": "",
    "stdout": "",
    "stderr": ""
  },
  {
    "id": "bs_004",
    "category": "basic_syntax",
    "difficulty": "medium",
    "title": "Flatten Nested List",
    "passed": false,
    "error": "API error: HTTP Error 500: Internal Server Error",
    "generated_code": "",
    "stdout": "",
    "stderr": ""
  },
  {
    "id": "bs_005",
    "category": "basic_syntax",
    "difficulty": "hard",
    "title": "Matrix Spiral Order",
    "passed": false,
    "error": "API request timed out",
    "generated_code": "",
    "stdout": "",
    "stderr": ""
  },
  {
    "id": "con_001",
    "category": "concurrency",
    "difficulty": "easy",
    "title": "Thread-Safe Counter",
    "passed": true,
    "error": null,
    "generated_code": "import threading\n\nclass ThreadSafeCounter:\n    \"\"\"\n    A thread-safe counter that can be safely incremented and decremented\n    from multiple threads simultaneously.\n\n    Methods:\n        __init__(self, initial=0): Initialize the counter with an optional\n            starting value (default 0).\n        increment(self): Atomically increase the counter by 1.\n        decrement(self): Atomically decrease the counter by 1.\n        get_value(self): Return the current counter value.\n\n    The counter must use threading.Lock to ensure thread safety.\n\n    Examples:\n        counter = ThreadSafeCounter()\n        counter.increment()\n        counter.increment()\n        counter.get_value()  # -> 2\n        counter.decrement()\n        counter.get_value()  # -> 1\n\n        counter = ThreadSafeCounter(10)\n        counter.get_value()  # -> 10\n    \"\"\"\n\n    def __init__(self, initial=0):\n        self._value = initial\n        self._lock = threading.Lock()\n\n    def increment(self):\n        with self._lock:\n            self._value += 1\n\n    def decrement(self):\n        with self._lock:\n            self._value -= 1\n\n    def get_value(self):\n        with self._lock:\n            return self._value",
    "stdout": "",
    "stderr": "..........\n----------------------------------------------------------------------\nRan 10 tests in 0.234s\n\nOK\n"
  },
  {
    "id": "con_002",
    "category": "concurrency",
    "difficulty": "medium",
    "title": "Parallel Map",
    "passed": true,
    "error": null,
    "generated_code": "from concurrent.futures import ThreadPoolExecutor\n\ndef parallel_map(func, items: list, max_workers: int = 4) -> list:\n    \"\"\"\n    Apply a function to each item in a list using parallel execution with\n    a thread pool. Return the results in the same order as the input items.\n\n    Args:\n        func: A callable to apply to each item.\n        items: A list of items to process.\n        max_workers: Maximum number of threads to use (default 4).\n\n    Returns:\n        A list of results in the same order as the input.\n\n    Examples:\n        parallel_map(lambda x: x ** 2, [1, 2, 3, 4])  # -> [1, 4, 9, 16]\n        parallel_map(str.upper, [\"hello\", \"world\"])  # -> [\"HELLO\", \"WORLD\"]\n        parallel_map(lambda x: x + 1, [], max_workers=2)  # -> []\n    \"\"\"\n    with ThreadPoolExecutor(max_workers=max_workers) as executor:\n        results = list(executor.map(func, items))\n    return results",
    "stdout": "",
    "stderr": "..........\n----------------------------------------------------------------------\nRan 10 tests in 0.117s\n\nOK\n"
  },
  {
    "id": "con_003",
    "category": "concurrency",
    "difficulty": "medium",
    "title": "Producer Consumer",
    "passed": false,
    "error": "API request timed out",
    "generated_code": "",
    "stdout": "",
    "stderr": ""
  },
  {
    "id": "con_004",
    "category": "concurrency",
    "difficulty": "hard",
    "title": "Async Gather with Timeout",
    "passed": true,
    "error": null,
    "generated_code": "import asyncio\n\nasync def async_gather_results(async_callables: list, timeout: float = None) -> list:\n    \"\"\"\n    Run a list of async callables (coroutine functions) concurrently and\n    return their results.\n\n    Args:\n        async_callables: A list of async callables (coroutine functions that\n            take no arguments). Each one, when called, returns a coroutine.\n        timeout: Optional timeout in seconds. If provided and the total\n            execution exceeds this duration, raise asyncio.TimeoutError.\n            If None, no timeout is applied.\n\n    Returns:\n        A list of results in the same order as the input callables.\n\n    Behavior:\n        - Call each async callable to create a coroutine.\n        - Run all coroutines concurrently using asyncio.gather.\n        - If timeout is specified, use asyncio.wait_for to enforce the timeout\n          around the gather call.\n        - Return the list of results.\n\n    Examples:\n        async def make_value(v):\n            await asyncio.sleep(0.01)\n            return v\n\n        results = await async_gather_results([\n            lambda: make_value(1),\n            lambda: make_value(2),\n            lambda: make_value(3)\n        ])\n        # results -> [1, 2, 3]\n\n        # With timeout (this would raise asyncio.TimeoutError if too slow):\n        results = await async_gather_results(\n            [lambda: make_value(42)],\n            timeout=5.0\n        )\n        # results -> [42]\n    \"\"\"\n    coroutines = [callable() for callable in async_callables]\n    gather_task = asyncio.gather(*coroutines)\n    \n    if timeout is not None:\n        results = await asyncio.wait_for(gather_task, timeout=timeout)\n    else:\n        results = await gather_task\n    \n    return results",
    "stdout": "",
    "stderr": "/tmp/tmp4sphnvdl.py:63: DeprecationWarning: There is no current event loop\n  self.loop = asyncio.get_event_loop()\n...........\n----------------------------------------------------------------------\nRan 11 tests in 0.265s\n\nOK\n"
  },
  {
    "id": "ds_001",
    "category": "data_structures",
    "difficulty": "easy",
    "title": "Two Sum",
    "passed": true,
    "error": null,
    "generated_code": "def two_sum(nums: list, target: int) -> list:\n    \"\"\"\n    Given a list of integers and a target integer, return the indices of the\n    two numbers that add up to the target.\n\n    Assumptions:\n    - Each input has exactly one solution.\n    - You may not use the same element twice.\n    - Return the indices in ascending order.\n\n    Examples:\n        two_sum([2, 7, 11, 15], 9) -> [0, 1]\n        two_sum([3, 2, 4], 6) -> [1, 2]\n        two_sum([3, 3], 6) -> [0, 1]\n    \"\"\"\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return sorted([seen[complement], i])\n        seen[num] = i\n    return []",
    "stdout": "",
    "stderr": "........\n----------------------------------------------------------------------\nRan 8 tests in 0.000s\n\nOK\n"
  },
  {
    "id": "ds_002",
    "category": "data_structures",
    "difficulty": "easy",
    "title": "Reverse Linked List",
    "passed": true,
    "error": null,
    "generated_code": "def reverse_linked_list(values: list) -> list:\n    \"\"\"\n    Given a list of values representing a singly linked list (head to tail),\n    return a new list with the values in reversed order.\n\n    This simulates reversing a linked list using list representation.\n    You should implement the reversal logic iteratively, simulating\n    pointer manipulation (not just using built-in reverse).\n\n    Examples:\n        reverse_linked_list([1, 2, 3, 4, 5]) -> [5, 4, 3, 2, 1]\n        reverse_linked_list([1]) -> [1]\n        reverse_linked_list([]) -> []\n    \"\"\"\n    # Simulate iterative linked list reversal with pointer manipulation\n    # prev (result) starts as empty list (analogous to None)\n    # current traverses through the input values\n    result = []  # Represents the \"prev\" pointer in linked list reversal\n    \n    for value in values:\n        # Simulate: next_node = current.next\n        #           current.next = prev\n        #           prev = current\n        #           current = next_node\n        # In list terms: current value becomes new head of result\n        result = [value] + result\n    \n    return result",
    "stdout": "",
    "stderr": "........\n----------------------------------------------------------------------\nRan 8 tests in 0.000s\n\nOK\n"
  },
  {
    "id": "ds_003",
    "category": "data_structures",
    "difficulty": "medium",
    "title": "LRU Cache",
    "passed": true,
    "error": null,
    "generated_code": "from collections import OrderedDict\n\nclass LRUCache:\n    \"\"\"\n    Implement a Least Recently Used (LRU) Cache.\n\n    The cache has a fixed capacity. When the cache is full and a new key\n    is inserted, the least recently used key is evicted.\n\n    Both get and put operations count as \"using\" a key.\n\n    Methods:\n        __init__(capacity: int) - Initialize the cache with positive capacity.\n        get(key: int) -> int - Return the value if key exists, otherwise -1.\n        put(key: int, value: int) -> None - Insert or update the key-value pair.\n\n    Example:\n        cache = LRUCache(2)\n        cache.put(1, 1)\n        cache.put(2, 2)\n        cache.get(1)       # returns 1\n        cache.put(3, 3)    # evicts key 2\n        cache.get(2)       # returns -1 (not found)\n        cache.get(3)       # returns 3\n    \"\"\"\n    \n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = OrderedDict()\n    \n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        self.cache.move_to_end(key)\n        return self.cache[key]\n    \n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.cache.move_to_end(key)\n        elif len(self.cache) >= self.capacity:\n            self.cache.popitem(last=False)\n        self.cache[key] = value",
    "stdout": "",
    "stderr": ".......\n----------------------------------------------------------------------\nRan 7 tests in 0.000s\n\nOK\n"
  },
  {
    "id": "ds_004",
    "category": "data_structures",
    "difficulty": "medium",
    "title": "Group Anagrams",
    "passed": true,
    "error": null,
    "generated_code": "def group_anagrams(strs: list) -> list:\n    \"\"\"\n    Given a list of strings, group the anagrams together.\n    Return a list of groups, where each group is a sorted list of anagram strings.\n    The groups themselves should be sorted by their first element.\n\n    Two strings are anagrams if they contain the same characters with the\n    same frequencies, regardless of order.\n\n    Examples:\n        group_anagrams([\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"])\n        -> [[\"ate\", \"eat\", \"tea\"], [\"bat\"], [\"nat\", \"tan\"]]\n\n        group_anagrams([\"\"]) -> [[\"\"]]\n        group_anagrams([\"a\"]) -> [[\"a\"]]\n    \"\"\"\n    anagram_groups = {}\n    \n    for s in strs:\n        key = ''.join(sorted(s))\n        if key not in anagram_groups:\n            anagram_groups[key] = []\n        anagram_groups[key].append(s)\n    \n    result = [sorted(group) for group in anagram_groups.values()]\n    result.sort(key=lambda x: x[0])\n    \n    return result",
    "stdout": "",
    "stderr": ".........\n----------------------------------------------------------------------\nRan 9 tests in 0.000s\n\nOK\n"
  },
  {
    "id": "ds_005",
    "category": "data_structures",
    "difficulty": "hard",
    "title": "Merge K Sorted Lists",
    "passed": true,
    "error": null,
    "generated_code": "import heapq\n\ndef merge_k_sorted(lists: list) -> list:\n    \"\"\"\n    Merge k sorted lists into one sorted list.\n\n    Use a min-heap for efficient merging. Each input list is sorted\n    in ascending order. Return a single sorted list containing all elements.\n\n    Examples:\n        merge_k_sorted([[1, 4, 5], [1, 3, 4], [2, 6]])\n        -> [1, 1, 2, 3, 4, 4, 5, 6]\n\n        merge_k_sorted([]) -> []\n        merge_k_sorted([[], []]) -> []\n        merge_k_sorted([[1]]) -> [1]\n    \"\"\"\n    if not lists:\n        return []\n    \n    # Initialize min-heap with (value, list_index, element_index)\n    heap = []\n    for i, lst in enumerate(lists):\n        if lst:\n            heapq.heappush(heap, (lst[0], i, 0))\n    \n    result = []\n    \n    while heap:\n        val, list_idx, elem_idx = heapq.heappop(heap)\n        result.append(val)\n        \n        # Push next element from the same list if available\n        if elem_idx + 1 < len(lists[list_idx]):\n            next_val = lists[list_idx][elem_idx + 1]\n            heapq.heappush(heap, (next_val, list_idx, elem_idx + 1))\n    \n    return result",
    "stdout": "",
    "stderr": "...........\n----------------------------------------------------------------------\nRan 11 tests in 0.001s\n\nOK\n"
  },
  {
    "id": "exc_001",
    "category": "exceptions",
    "difficulty": "easy",
    "title": "Safe Divide",
    "passed": true,
    "error": null,
    "generated_code": "def safe_divide(a, b):\n    \"\"\"Divide a by b safely.\n\n    Args:\n        a: The numerator.\n        b: The denominator.\n\n    Returns:\n        The result of a / b, or None if b is zero.\n\n    Raises:\n        TypeError: If either a or b is not a number (int or float).\n    \"\"\"\n    if not isinstance(a, (int, float)):\n        raise TypeError(\"a must be a number (int or float)\")\n    if not isinstance(b, (int, float)):\n        raise TypeError(\"b must be a number (int or float)\")\n    \n    if b == 0:\n        return None\n    \n    return a / b",
    "stdout": "",
    "stderr": ".............\n----------------------------------------------------------------------\nRan 13 tests in 0.001s\n\nOK\n"
  },
  {
    "id": "exc_002",
    "category": "exceptions",
    "difficulty": "medium",
    "title": "Retry Decorator",
    "passed": true,
    "error": null,
    "generated_code": "import time\nimport functools\n\n\ndef retry(max_attempts=3, exceptions=(Exception,), delay=0):\n    \"\"\"A decorator that retries a function on failure.\n\n    Args:\n        max_attempts (int): Maximum number of attempts (including the first call).\n            Must be >= 1.\n        exceptions (tuple): A tuple of exception types to catch and retry on.\n            Any other exception types should propagate immediately.\n        delay (float): Seconds to wait between retries. Defaults to 0.\n\n    Returns:\n        A decorator that wraps the target function with retry logic.\n\n    Behavior:\n        - Call the decorated function. If it succeeds, return its result.\n        - If it raises one of the specified exception types and attempts remain,\n          wait `delay` seconds, then retry.\n        - If all attempts are exhausted, raise the last exception.\n        - The decorator should preserve the original function's name and docstring\n          (use functools.wraps).\n    \"\"\"\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            last_exception = None\n            for attempt in range(max_attempts):\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    last_exception = e\n                    if attempt < max_attempts - 1:\n                        time.sleep(delay)\n            raise last_exception\n        return wrapper\n    return decorator",
    "stdout": "",
    "stderr": "..........\n----------------------------------------------------------------------\nRan 10 tests in 0.101s\n\nOK\n"
  },
  {
    "id": "exc_003",
    "category": "exceptions",
    "difficulty": "hard",
    "title": "Custom Exception Hierarchy and Schema Validation",
    "passed": false,
    "error": "API request timed out",
    "generated_code": "",
    "stdout": "",
    "stderr": ""
  },
  {
    "id": "fio_001",
    "category": "file_io",
    "difficulty": "easy",
    "title": "Read CSV Data",
    "passed": true,
    "error": null,
    "generated_code": "import csv\nimport io\n\ndef read_csv_data(csv_string: str) -> list:\n    \"\"\"\n    Parse a CSV-formatted string into a list of dictionaries.\n\n    The first row of the CSV string contains the headers, which become\n    the dictionary keys. Each subsequent row becomes a dictionary with\n    values mapped to the corresponding headers.\n\n    Use the csv module for parsing. Handle quoted fields correctly.\n\n    Args:\n        csv_string: A string containing CSV-formatted data\n\n    Returns:\n        A list of dictionaries, one per data row\n\n    Examples:\n        read_csv_data('name,age\\nAlice,30\\nBob,25')\n        -> [{'name': 'Alice', 'age': '30'}, {'name': 'Bob', 'age': '25'}]\n\n        read_csv_data('a,b\\n1,2')\n        -> [{'a': '1', 'b': '2'}]\n    \"\"\"\n    reader = csv.DictReader(io.StringIO(csv_string))\n    return list(reader)",
    "stdout": "",
    "stderr": "........\n----------------------------------------------------------------------\nRan 8 tests in 0.001s\n\nOK\n"
  },
  {
    "id": "fio_002",
    "category": "file_io",
    "difficulty": "medium",
    "title": "Merge JSON Files",
    "passed": false,
    "error": "API request timed out",
    "generated_code": "",
    "stdout": "",
    "stderr": ""
  },
  {
    "id": "fio_003",
    "category": "file_io",
    "difficulty": "hard",
    "title": "Log Parser",
    "passed": false,
    "error": "API request timed out",
    "generated_code": "",
    "stdout": "",
    "stderr": ""
  },
  {
    "id": "fn_001",
    "category": "functional",
    "difficulty": "easy",
    "title": "Apply Pipeline",
    "passed": true,
    "error": null,
    "generated_code": "def apply_pipeline(value, functions: list):\n    \"\"\"\n    Given an initial value and a list of single-argument functions,\n    apply each function in sequence (left to right) to the value,\n    passing the result of each function as input to the next.\n    Return the final result.\n\n    If the functions list is empty, return the original value.\n\n    Examples:\n        apply_pipeline(5, [lambda x: x + 1, lambda x: x * 2]) -> 12\n        apply_pipeline(\"hello\", [str.upper, lambda s: s + \"!\"]) -> \"HELLO!\"\n        apply_pipeline(10, []) -> 10\n        apply_pipeline(-3, [abs, lambda x: x ** 2]) -> 9\n    \"\"\"\n    result = value\n    for func in functions:\n        result = func(result)\n    return result",
    "stdout": "",
    "stderr": "..........\n----------------------------------------------------------------------\nRan 10 tests in 0.000s\n\nOK\n"
  },
  {
    "id": "fn_002",
    "category": "functional",
    "difficulty": "medium",
    "title": "Memoize Decorator",
    "passed": true,
    "error": null,
    "generated_code": "def memoize(func):\n    \"\"\"\n    Implement a memoize decorator that caches the results of function calls.\n    If the function is called again with the same positional arguments,\n    return the cached result instead of recomputing.\n\n    Assume all arguments are hashable (can be used as dict keys via tuple).\n    Only positional arguments need to be supported (no kwargs).\n\n    The decorated function should also have a .cache attribute that is\n    the dictionary used for caching (mapping argument tuples to results).\n\n    Examples:\n        @memoize\n        def add(a, b):\n            return a + b\n\n        add(1, 2)  # computes and caches\n        add(1, 2)  # returns cached result\n        add.cache  # {(1, 2): 3}\n    \"\"\"\n    cache = {}\n    \n    def wrapper(*args):\n        if args in cache:\n            return cache[args]\n        result = func(*args)\n        cache[args] = result\n        return result\n    \n    wrapper.cache = cache\n    return wrapper",
    "stdout": "",
    "stderr": "........\n----------------------------------------------------------------------\nRan 8 tests in 0.000s\n\nOK\n"
  },
  {
    "id": "fn_003",
    "category": "functional",
    "difficulty": "medium",
    "title": "Group By",
    "passed": true,
    "error": null,
    "generated_code": "def group_by(items: list, key_func) -> dict:\n    \"\"\"\n    Group elements of a list by the result of applying key_func to each element.\n    Return a dictionary where keys are the results of key_func and values are\n    lists of items that produced that key, in their original order.\n\n    Examples:\n        group_by([1, 2, 3, 4, 5, 6], lambda x: x % 2 == 0)\n        # -> {False: [1, 3, 5], True: [2, 4, 6]}\n\n        group_by([\"apple\", \"banana\", \"avocado\", \"blueberry\"], lambda s: s[0])\n        # -> {\"a\": [\"apple\", \"avocado\"], \"b\": [\"banana\", \"blueberry\"]}\n\n        group_by([], lambda x: x)\n        # -> {}\n\n        group_by([1, 2, 3, 4, 5], lambda x: \"even\" if x % 2 == 0 else \"odd\")\n        # -> {\"odd\": [1, 3, 5], \"even\": [2, 4]}\n    \"\"\"\n    result = {}\n    for item in items:\n        key = key_func(item)\n        if key not in result:\n            result[key] = []\n        result[key].append(item)\n    return result",
    "stdout": "",
    "stderr": "..........\n----------------------------------------------------------------------\nRan 10 tests in 0.000s\n\nOK\n"
  },
  {
    "id": "fn_004",
    "category": "functional",
    "difficulty": "hard",
    "title": "Lazy Evaluation",
    "passed": false,
    "error": "API request timed out",
    "generated_code": "",
    "stdout": "",
    "stderr": ""
  },
  {
    "id": "oop_001",
    "category": "oop",
    "difficulty": "easy",
    "title": "Stack Class",
    "passed": true,
    "error": null,
    "generated_code": "class Stack:\n    \"\"\"A stack data structure with standard operations.\n\n    Methods:\n        push(item): Add an item to the top of the stack.\n        pop(): Remove and return the top item. Raise IndexError if empty.\n        peek(): Return the top item without removing it. Raise IndexError if empty.\n        is_empty(): Return True if the stack is empty, False otherwise.\n        size(): Return the number of items in the stack.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize an empty stack.\"\"\"\n        self._items = []\n\n    def push(self, item):\n        \"\"\"Add an item to the top of the stack.\"\"\"\n        self._items.append(item)\n\n    def pop(self):\n        \"\"\"Remove and return the top item. Raise IndexError if empty.\"\"\"\n        if self.is_empty():\n            raise IndexError(\"pop from empty stack\")\n        return self._items.pop()\n\n    def peek(self):\n        \"\"\"Return the top item without removing it. Raise IndexError if empty.\"\"\"\n        if self.is_empty():\n            raise IndexError(\"peek from empty stack\")\n        return self._items[-1]\n\n    def is_empty(self):\n        \"\"\"Return True if the stack is empty, False otherwise.\"\"\"\n        return len(self._items) == 0\n\n    def size(self):\n        \"\"\"Return the number of items in the stack.\"\"\"\n        return len(self._items)",
    "stdout": "",
    "stderr": "........\n----------------------------------------------------------------------\nRan 8 tests in 0.000s\n\nOK\n"
  },
  {
    "id": "oop_002",
    "category": "oop",
    "difficulty": "medium",
    "title": "Shape Hierarchy with Abstract Base Class",
    "passed": true,
    "error": null,
    "generated_code": "from abc import ABC, abstractmethod\nimport math\n\n\nclass Shape(ABC):\n    \"\"\"Abstract base class for shapes.\n\n    Abstract Methods:\n        area() -> float: Return the area of the shape.\n        perimeter() -> float: Return the perimeter of the shape.\n    \"\"\"\n    \n    @abstractmethod\n    def area(self) -> float:\n        \"\"\"Return the area of the shape.\"\"\"\n        pass\n    \n    @abstractmethod\n    def perimeter(self) -> float:\n        \"\"\"Return the perimeter of the shape.\"\"\"\n        pass\n\n\nclass Circle(Shape):\n    \"\"\"A circle defined by its radius.\n\n    Args:\n        radius (float): The radius of the circle. Must be positive.\n            Raise ValueError if radius <= 0.\n    \"\"\"\n    \n    def __init__(self, radius: float):\n        if radius <= 0:\n            raise ValueError(\"Radius must be positive\")\n        self.radius = radius\n    \n    def area(self) -> float:\n        return math.pi * self.radius ** 2\n    \n    def perimeter(self) -> float:\n        return 2 * math.pi * self.radius\n\n\nclass Rectangle(Shape):\n    \"\"\"A rectangle defined by width and height.\n\n    Args:\n        width (float): The width of the rectangle. Must be positive.\n        height (float): The height of the rectangle. Must be positive.\n            Raise ValueError if width or height <= 0.\n    \"\"\"\n    \n    def __init__(self, width: float, height: float):\n        if width <= 0:\n            raise ValueError(\"Width must be positive\")\n        if height <= 0:\n            raise ValueError(\"Height must be positive\")\n        self.width = width\n        self.height = height\n    \n    def area(self) -> float:\n        return self.width * self.height\n    \n    def perimeter(self) -> float:\n        return 2 * (self.width + self.height)\n\n\ndef calculate_total_area(shapes):\n    \"\"\"Return the sum of areas of all shapes in the list.\n\n    Args:\n        shapes: A list of Shape instances.\n\n    Returns:\n        float: The total area.\n    \"\"\"\n    return sum(shape.area() for shape in shapes)",
    "stdout": "",
    "stderr": "...............\n----------------------------------------------------------------------\nRan 15 tests in 0.001s\n\nOK\n"
  },
  {
    "id": "oop_003",
    "category": "oop",
    "difficulty": "medium",
    "title": "BankAccount with Transaction History",
    "passed": false,
    "error": "API request timed out",
    "generated_code": "",
    "stdout": "",
    "stderr": ""
  },
  {
    "id": "oop_004",
    "category": "oop",
    "difficulty": "hard",
    "title": "EventEmitter - Observer Pattern",
    "passed": true,
    "error": null,
    "generated_code": "class EventEmitter:\n    \"\"\"An event emitter implementing the observer pattern.\n\n    Methods:\n        on(event: str, callback: callable) -> None:\n            Register a callback for the given event.\n            The same callback can be registered multiple times for the same event;\n            each registration counts separately.\n\n        off(event: str, callback: callable) -> None:\n            Remove one registration of callback for the given event.\n            If the callback is registered multiple times, only remove the first one.\n            If callback is not registered for this event, do nothing (no error).\n\n        emit(event: str, *args, **kwargs) -> None:\n            Call all registered callbacks for the event with the given arguments.\n            Callbacks are called in the order they were registered.\n            If no callbacks are registered for the event, do nothing.\n\n        once(event: str, callback: callable) -> None:\n            Register a callback that is automatically removed after it fires once.\n\n        listener_count(event: str) -> int:\n            Return the number of listeners registered for the given event.\n    \"\"\"\n\n    def __init__(self):\n        self._events = {}\n\n    def on(self, event, callback):\n        \"\"\"Register a callback for the given event.\"\"\"\n        if event not in self._events:\n            self._events[event] = []\n        self._events[event].append(callback)\n\n    def off(self, event, callback):\n        \"\"\"Remove one registration of callback for the given event.\"\"\"\n        if event in self._events:\n            try:\n                self._events[event].remove(callback)\n            except ValueError:\n                pass\n\n    def emit(self, event, *args, **kwargs):\n        \"\"\"Call all registered callbacks for the event with the given arguments.\"\"\"\n        if event in self._events:\n            for callback in self._events[event][:]:\n                callback(*args, **kwargs)\n\n    def once(self, event, callback):\n        \"\"\"Register a callback that is automatically removed after it fires once.\"\"\"\n        def wrapper(*args, **kwargs):\n            self.off(event, wrapper)\n            callback(*args, **kwargs)\n        self.on(event, wrapper)\n\n    def listener_count(self, event):\n        \"\"\"Return the number of listeners registered for the given event.\"\"\"\n        return len(self._events.get(event, []))",
    "stdout": "",
    "stderr": "...............\n----------------------------------------------------------------------\nRan 15 tests in 0.001s\n\nOK\n"
  },
  {
    "id": "oop_005",
    "category": "oop",
    "difficulty": "hard",
    "title": "ValidatedField Descriptor",
    "passed": false,
    "error": "API request timed out",
    "generated_code": "",
    "stdout": "",
    "stderr": ""
  },
  {
    "id": "std_001",
    "category": "stdlib",
    "difficulty": "easy",
    "title": "Count Words",
    "passed": true,
    "error": null,
    "generated_code": "from collections import Counter\n\ndef count_words(text: str) -> dict[str, int]:\n    \"\"\"Count the frequency of each word in a string.\n\n    Words are separated by whitespace. Counting is case-sensitive\n    (i.e., 'Hello' and 'hello' are different words).\n\n    Args:\n        text: A string of words separated by whitespace.\n\n    Returns:\n        A dictionary mapping each word to the number of times it appears.\n    \"\"\"\n    return dict(Counter(text.split()))",
    "stdout": "",
    "stderr": ".........\n----------------------------------------------------------------------\nRan 9 tests in 0.001s\n\nOK\n"
  },
  {
    "id": "std_002",
    "category": "stdlib",
    "difficulty": "easy",
    "title": "Parse Date",
    "passed": true,
    "error": null,
    "generated_code": "from datetime import datetime\n\ndef parse_date(date_str: str) -> str:\n    \"\"\"Parse a date string in 'YYYY-MM-DD' format and return the day of the week.\n\n    Args:\n        date_str: A date string in the format 'YYYY-MM-DD'.\n\n    Returns:\n        The day of the week as a full string, e.g. 'Monday', 'Tuesday', etc.\n    \"\"\"\n    date_obj = datetime.strptime(date_str, '%Y-%m-%d')\n    return date_obj.strftime('%A')",
    "stdout": "",
    "stderr": "...........\n----------------------------------------------------------------------\nRan 11 tests in 0.004s\n\nOK\n"
  },
  {
    "id": "std_003",
    "category": "stdlib",
    "difficulty": "medium",
    "title": "Validate Email",
    "passed": false,
    "error": "API request timed out",
    "generated_code": "",
    "stdout": "",
    "stderr": ""
  },
  {
    "id": "std_004",
    "category": "stdlib",
    "difficulty": "medium",
    "title": "Cartesian Product Filter",
    "passed": true,
    "error": null,
    "generated_code": "from itertools import product\n\ndef cartesian_filter(lists: list[list[int]], threshold: int) -> list[tuple[int, ...]]:\n    \"\"\"Generate the cartesian product of multiple lists of integers and\n    filter to keep only tuples whose element sum exceeds a threshold.\n\n    Args:\n        lists: A list of lists of integers. The cartesian product is\n               computed across all provided lists.\n        threshold: An integer threshold. Only tuples whose sum is\n                   strictly greater than this value are included.\n\n    Returns:\n        A list of tuples (in the order produced by itertools.product)\n        where the sum of elements is strictly greater than the threshold.\n        Returns an empty list if lists is empty.\n    \"\"\"\n    if not lists:\n        return []\n    \n    return [tup for tup in product(*lists) if sum(tup) > threshold]",
    "stdout": "",
    "stderr": "............\n----------------------------------------------------------------------\nRan 12 tests in 0.001s\n\nOK\n"
  },
  {
    "id": "std_005",
    "category": "stdlib",
    "difficulty": "hard",
    "title": "Parallel Map",
    "passed": true,
    "error": null,
    "generated_code": "from concurrent.futures import ThreadPoolExecutor\nfrom typing import Callable, TypeVar\n\nT = TypeVar('T')\nR = TypeVar('R')\n\ndef parallel_map(func: Callable[[T], R], items: list[T], max_workers: int = 4) -> list[R]:\n    \"\"\"Apply a function to each item in a list using parallel threads.\n\n    Uses concurrent.futures.ThreadPoolExecutor to apply func to each\n    element of items in parallel, then returns the results in the same\n    order as the input items.\n\n    Args:\n        func: A callable that takes a single argument and returns a result.\n        items: A list of items to process.\n        max_workers: Maximum number of threads to use (default 4).\n\n    Returns:\n        A list of results in the same order as the input items.\n        Returns an empty list if items is empty.\n    \"\"\"\n    if not items:\n        return []\n    \n    with ThreadPoolExecutor(max_workers=max_workers) as executor:\n        results = list(executor.map(func, items))\n    \n    return results",
    "stdout": "",
    "stderr": "............\n----------------------------------------------------------------------\nRan 12 tests in 0.123s\n\nOK\n"
  },
  {
    "id": "str_001",
    "category": "string_processing",
    "difficulty": "easy",
    "title": "Is Palindrome",
    "passed": true,
    "error": null,
    "generated_code": "import re\n\ndef is_palindrome(s: str) -> bool:\n    \"\"\"\n    Check if a string is a palindrome, ignoring case, spaces, and punctuation.\n\n    Only consider alphanumeric characters when determining if the string\n    is a palindrome.\n\n    Args:\n        s: The input string\n\n    Returns:\n        True if the string is a palindrome, False otherwise\n\n    Examples:\n        is_palindrome('racecar') -> True\n        is_palindrome('A man, a plan, a canal: Panama') -> True\n        is_palindrome('hello') -> False\n        is_palindrome('') -> True\n    \"\"\"\n    # Keep only alphanumeric characters and convert to lowercase\n    cleaned = re.sub(r'[^a-zA-Z0-9]', '', s).lower()\n    # Check if the cleaned string reads the same forwards and backwards\n    return cleaned == cleaned[::-1]",
    "stdout": "",
    "stderr": ".............\n----------------------------------------------------------------------\nRan 13 tests in 0.001s\n\nOK\n"
  },
  {
    "id": "str_002",
    "category": "string_processing",
    "difficulty": "easy",
    "title": "Caesar Cipher",
    "passed": true,
    "error": null,
    "generated_code": "def caesar_cipher(text: str, shift: int, mode: str = 'encrypt') -> str:\n    \"\"\"\n    Encrypt or decrypt text using a Caesar cipher.\n\n    Shift each letter by the given amount. Preserve case. Non-alphabetic\n    characters (spaces, punctuation, digits) are left unchanged.\n\n    For encryption, shift letters forward in the alphabet.\n    For decryption, shift letters backward.\n\n    The shift value can be any integer and will be normalized mod 26.\n\n    Args:\n        text: The input string\n        shift: Integer shift value\n        mode: 'encrypt' or 'decrypt'\n\n    Returns:\n        The encrypted or decrypted string\n\n    Examples:\n        caesar_cipher('Hello, World!', 3, 'encrypt') -> 'Khoor, Zruog!'\n        caesar_cipher('Khoor, Zruog!', 3, 'decrypt') -> 'Hello, World!'\n        caesar_cipher('abc', 1, 'encrypt') -> 'bcd'\n        caesar_cipher('xyz', 3, 'encrypt') -> 'abc'\n    \"\"\"\n    shift = shift % 26\n    \n    if mode == 'decrypt':\n        shift = -shift\n    \n    result = []\n    \n    for char in text:\n        if char.isupper():\n            shifted = chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n            result.append(shifted)\n        elif char.islower():\n            shifted = chr((ord(char) - ord('a') + shift) % 26 + ord('a'))\n            result.append(shifted)\n        else:\n            result.append(char)\n    \n    return ''.join(result)",
    "stdout": "",
    "stderr": ".............\n----------------------------------------------------------------------\nRan 13 tests in 0.001s\n\nOK\n"
  },
  {
    "id": "str_003",
    "category": "string_processing",
    "difficulty": "medium",
    "title": "Extract URLs",
    "passed": false,
    "error": "API request timed out",
    "generated_code": "",
    "stdout": "",
    "stderr": ""
  },
  {
    "id": "str_004",
    "category": "string_processing",
    "difficulty": "hard",
    "title": "Template Engine",
    "passed": false,
    "error": "API request timed out",
    "generated_code": "",
    "stdout": "",
    "stderr": ""
  }
]